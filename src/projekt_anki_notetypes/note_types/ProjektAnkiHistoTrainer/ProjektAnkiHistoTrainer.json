{
  "id": 160000005,
  "name": "ProjektAnkiHistoTrainer",
  "type": 0,
  "mod": 1600000000,
  "usn": -1,
  "sortf": 0,
  "did": 1,
  "tmpls": [
    {
      "name": "Markierung 1",
      "ord": 0,
      "qfmt": "<!-- version 0fd8612 -->\n{{#Markierung 1}}\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TIMER CONFIG  ##############\n// Timer config (timer length, timer finished message)\nvar minutes =  0\nvar seconds = 15\nvar timeOverMsg = \"<span style='color:#CC5B5B'>!!!</span>\"\n\n  // ##############  TAG SHORTCUT  ##############\nvar toggleTagsShortcut = \"C\";\n\n// ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\nvar tagID = \"XXXYYYZZZ\"\n\n// WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\nvar numTagLevelsToShow = 0;\n\n// ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\nvar tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n// Enable experimental heuristic indentation feature\nvar indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n// Enable experimental DIVI medication formatting feature\nvar formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n// Enable experimental confounder formatting feature\nvar formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n// Enable bionic reading feature (based on AnKing add-on)\nvar bionicReading = false;\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button\n        id=\"button-tags\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n      >\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button\n        id=\"button-src\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n      >\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button\n        id=\"button-nid\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n      >\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button\n          id=\"button-ankihub\"\n          class=\"button-general\"\n          title=\"Karte in AnkiHub\"\n        >\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) {}\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button\n      id=\"button-tags\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button\n      id=\"button-src\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">Quelle: {{Quelle}}</div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button\n      id=\"button-nid\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    <i>Was</i> wird hier bei <b>①</b> gezeigt?\n\n    <br>\n    <br>\n\n    {{#Hint / Hinweis}}\n      <span style=\"color:IndianRed; font-weight: bold;\">Hinweis:</span> {{hint:Hint / Hinweis}}\n\n      <br>\n      <br>\n    {{/Hint / Hinweis}}\n    \n    {{Bild}}\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\"></div>\n\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n<script>\n  //DONT FADE BETWEEN CARDS\n  qFade = 0;\n  if (typeof anki !== 'undefined') anki.qFade = qFade;\n</script>\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\nfunction getTextWidth(text, font) {\n // re-use canvas object for better performance\n const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n const context = canvas.getContext(\"2d\");\n context.font = font;\n const metrics = context.measureText(text);\n return metrics.width;\n}\n\nfunction getCSSStyle(element, prop) {\n return window.getComputedStyle(element, null).getPropertyValue(prop);\n}\n\nfunction getCanvasFont(el = document.body) {\n const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n const fontSize = getCSSStyle(el, 'font-size') || '16px';\n const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n return `${fontWeight} ${fontSize} ${fontFamily}`;\n}\n\n/**\n* Iterates over a list of divs containing text to be indented\n*\n* @param {HTMLCollection} divs: The divs to be iterated over.\n*/\nfunction indentText(divs) {\n // setup the indentation markers\n var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n var bulletP = \"•\"\n var minus = \"– \"\n var enter = \"↳(?!( ↳|↳))\"\n var arrow = \"→\"\n\n // heuristic indentation hierarchy\n hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n // set up RegEx to analyze the provided divs\n // negative lookbehinds unfortunately do not work yet on iPad / Android\n var beginning = '(?<=<br>)(?<!cloze=\")('\n var middle = \".*?)((?:<br>)(?=(\"\n var end = \"))|(?=(<\\/indent>|<\\/div>|<br><br>)))\"\n\n const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n // iterate over divs\n for (const div of divs) {\n   // calculate indentation depths\n   var canvasFont = getCanvasFont(div)\n   var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n   var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n   var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n   var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n   var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n   var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n   var indentEnd = ';\">$1</indent>'\n\n   // do the indentation\n   divHTML = div.outerHTML\n   divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n   divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n   div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\")\n }\n}\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function(type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function(ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n  <script>\n    var tagContainer = document.getElementById(\"tags-container\")\n\n    if (tagContainer.childElementCount == 0) {\n      var tagList = tagContainer.innerHTML.trim().split(\" \");\n      var kbdList = [];\n      var newTagContent = document.createElement(\"div\");\n\n      for (var i = 0; i < tagList.length; i++) {\n        var newTag = document.createElement(\"kbd\");\n        var tag = tagList[i];\n        // numTagLevelsToShow == 0 means the whole tag should be shown\n        if (numTagLevelsToShow != 0) {\n          tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n        }\n\n        // Zankiphil / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n        if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) continue;\n        if (tag.split(\"::\")[1] == \"!NEW_CARDS\") continue;\n        if (tag.split(\"::\")[1] == \"§Projekt_Anki\") continue;\n        if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") continue;\n\n        // improve legibility of tags\n        tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n        tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\");\n        tag = tag.replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n        newTag.innerHTML = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"_\", \" \");\n        newTagContent.append(newTag)\n      }\n\n      tagContainer.innerHTML = newTagContent.innerHTML;\n      tagContainer.style.cursor = \"default\";\n    }\n\n    if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n      tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n    }\n\n    function showtags() {\n      var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n      if (tagContainerShortcut.style.display === \"none\") {\n        tagContainerShortcut.style.display = \"inline\";\n      } else {\n        tagContainerShortcut.style.display = \"none\";\n      }\n    }\n\n    var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n    ankingAddEventListener('keyup', function (e) {\n      if (isShortcut(e)) {\n        toggleHintBtn('hint-tags');\n        showtags();\n      }\n    });\n  </script>\n  <script>\n    for (const tag of document.getElementsByTagName('kbd')) {\n      tag.innerHTML = tag.innerHTML.replace(/::/g, '::<wbr>')\n    }\n  </script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (el.style.display === 'none') {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits( n ) {\n      return (n <= 9 ? \"0\" + n : n); \n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n      \n      if ( msLeft < 1000 ) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date( msLeft );\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout( updateTimer, time.getUTCMilliseconds() + 500 );\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60*minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds ); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function(key, dictionary){\n        return dictionary[key];\n      }\n    }\n    \n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n      \n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n      \n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n/**\n * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n * Full credit to the original authors, except where modified or otherwise indicated.\n */\n\n/**\n *\n * We try to respect that people use various note types\n * which may do 'weird' stuff.\n * Elements may have event listeners that can be removed if we just innerHTML stuff\n * <i> may be styled 'i { display: block }', etc.\n *\n * Another problem that complicate the design of this script is that\n * a word may not be cleanly separated by html tags.\n * e.g. \"A<i>long</i>word\"\n *\n */\n\n(function () {\n  /**\n   * @param {String} text\n   * @returns {number}\n   */\n  function getBoldLength(text) {\n    return Math.floor(text.length / 2);\n  }\n\n  // Ignore node if any of the filters return true\n  const excludeFilters = [\n    (elem) => elem.tagName === \"SCRIPT\",\n    (elem) => elem.tagName === \"STYLE\",\n    (elem) => elem.classList.contains(\"cloze\"),\n  ];\n\n  function newBoldElement(text) {\n    const elem = document.createElement(\"strong\");\n    elem.innerText = text;\n    return elem;\n  }\n\n  function indexOfWhitespace(text, startPos) {\n    const whitespaces = [\n      \" \",\n      \"\\n\",\n      \"\\t\",\n      \" \",\n      \"&nbsp;\",\n      \"‑\",\n      \"-\",\n      \"/\",\n      \"(\",\n      \")\",\n    ];\n    let nextPos = text.length;\n    for (const whitespace of whitespaces) {\n      const next = text.indexOf(whitespace, startPos);\n      if (next !== -1 && next < nextPos) {\n        nextPos = next;\n      }\n    }\n    if (nextPos === text.length) {\n      nextPos = -1;\n    }\n    return nextPos;\n  }\n\n  // Bolds a line of words\n  class BionicReaderBolder {\n    constructor(nodes) {\n      this.nodes = nodes;\n      this.startNodeIndex = 0;\n      this.startPos = 0;\n      this.replaceNodes = [];\n      while (!this.isFinished()) {\n        this.runWithinNode();\n        this.runInterNode();\n      }\n    }\n\n    static run(nodes) {\n      new BionicReaderBolder(nodes);\n    }\n\n    isFinished() {\n      return this.startNodeIndex === this.nodes.length;\n    }\n\n    replaceNode() {\n      const node = this.nodes[this.startNodeIndex];\n      const parent = node.parentNode;\n      for (let add of this.replaceNodes) {\n        parent.insertBefore(add, node);\n      }\n      parent.removeChild(node);\n      this.replaceNodes = [];\n    }\n\n    runWithinNode() {\n      const textContent = this.nodes[this.startNodeIndex].textContent;\n      let nextPos = indexOfWhitespace(textContent, this.startPos);\n      while (nextPos !== -1) {\n        const word = textContent.substring(this.startPos, nextPos);\n        const boldLength = getBoldLength(word);\n        this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n        this.replaceNodes.push(\n          document.createTextNode(\n            word.substring(boldLength, nextPos) + textContent[nextPos]\n          )\n        );\n        this.startPos = nextPos + 1;\n        nextPos = indexOfWhitespace(textContent, this.startPos);\n      }\n    }\n\n    // after this, startPos is likely to be at whitespace char\n    runInterNode() {\n      let word = \"\";\n      let endNodeIndex = this.startNodeIndex;\n      let endPos = this.startPos; // last word char pos + 1\n\n      // Find word boundary\n      while (endNodeIndex < this.nodes.length) {\n        const textContent = this.nodes[endNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, endPos);\n        if (nextPos === -1) {\n          word += textContent.substring(endPos);\n          endNodeIndex += 1;\n          endPos = 0;\n        } else {\n          word += textContent.substring(endPos, nextPos);\n          endPos = nextPos;\n          break;\n        }\n      }\n      // Calculate bold length\n      let remainingBoldLength = getBoldLength(word);\n\n      // Bold part of word\n      while (remainingBoldLength > 0) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        if (remainingBoldLength > textContent.length - this.startPos) {\n          const wordPart = textContent.substring(this.startPos);\n          remainingBoldLength -= wordPart.length;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        } else {\n          const wordPart = textContent.substring(\n            this.startPos,\n            this.startPos + remainingBoldLength\n          );\n          this.startPos += remainingBoldLength;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          remainingBoldLength -= wordPart.length;\n        }\n      }\n\n      // Add non-bolded part of words\n      while (this.startNodeIndex < endNodeIndex) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.replaceNode();\n        this.startNodeIndex += 1;\n        this.startPos = 0;\n      }\n\n      if (this.startPos < endPos) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos, endPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.startPos = endPos;\n      }\n    }\n  }\n\n  /**\n   * Builds a list of (list of nodes that makes up one non-line-broken line)\n   * @param {Node} elem\n   * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n   * @returns {void}\n   */\n  function forTextNodesInTree(elem, nodes, exclude = false) {\n    const children = elem.childNodes;\n    for (const filter of excludeFilters) {\n      if (filter(elem)) {\n        exclude = true;\n        break;\n      }\n    }\n    for (const child of children) {\n      if (child.nodeType === Node.ELEMENT_NODE) {\n        const style = window.getComputedStyle(child);\n        if (\n          child.tagName !== \"BR\" &&\n          (style === \"inline\" || style === \"inline-block\")\n        ) {\n          forTextNodesInTree(child, nodes, exclude);\n        } else {\n          if (nodes[nodes.length - 1].length > 0) {\n            nodes.push([]);\n          }\n          forTextNodesInTree(child, nodes, exclude);\n        }\n      } else if (\n        !exclude &&\n        child.nodeType === Node.TEXT_NODE &&\n        child.textContent.length > 0\n      ) {\n        nodes[nodes.length - 1].push(child);\n      }\n    }\n  }\n\n  function makeBionic() {\n    const cardContainer = document.getElementById(\"container\");\n    cardContainer.normalize();\n\n    let nodesLines = [[]];\n    forTextNodesInTree(cardContainer, nodesLines);\n    for (const nodes of nodesLines) {\n      BionicReaderBolder.run(nodes);\n    }\n\n    cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n      \"<strong></strong>\",\n      \"\"\n    );\n    cardContainer.normalize();\n  }\n\n  let start = performance.now();\n  if (bionicReading) {\n    makeBionic();\n  }\n  let end = performance.now();\n  console.log(`Initialized bionic reading: ${end - start}ms`);\n})();\n</script>\n\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\nvar userJs1 = undefined\nvar userJs2 = undefined\nvar userJs3 = undefined\nvar userJs4 = undefined\nvar userJs5 = undefined\nvar userJs6 = undefined\nvar userJs7 = undefined\nvar userJs8 = undefined\n</script>\n\n\n{{/Markierung 1}}",
      "afmt": "<!-- version 0fd8612 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Eigene Notizen & Bilder\": \"Alt + 1\",\n    \"Eigene Prüfungsfragen\": \"Alt + 2\",\n    \"Definitionen\": \"Alt + 3\",\n    \"Merksprüche\": \"Alt + 4\",\n    \"Klinik\": \"Alt + 5\",\n    \"Präparat\": \"Alt + 6\",\n    \"Memes\": \"Alt + 7\",\n    \"linkContainer\": \"Alt + L\",\n    \"Meditricks\": \"Alt + M\",\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Eigene Notizen & Bilder\": false,\n    \"Eigene Prüfungsfragen\": false,\n    \"Definitionen\": false,\n    \"Merksprüche\": false,\n    \"Klinik\": false,\n    \"Präparat\": false,\n    \"Memes\": false,\n    \"linkContainer\": true,\n    \"Meditricks\": false,\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\":false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\nvar toggleTagsShortcut = \"C\";\n\n// ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\nvar tagID = \"XXXYYYZZZ\"\n\n// WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\nvar numTagLevelsToShow = 0;\n\n// ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\nvar tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n// Enable experimental heuristic indentation feature\nvar indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n// Enable experimental DIVI medication formatting feature\nvar formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n// Enable experimental confounder formatting feature\nvar formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n// Enable bionic reading feature (based on AnKing add-on)\nvar bionicReading = false;\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button\n        id=\"button-tags\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n      >\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button\n        id=\"button-src\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n      >\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button\n        id=\"button-nid\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n      >\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button\n          id=\"button-ankihub\"\n          class=\"button-general\"\n          title=\"Karte in AnkiHub\"\n        >\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) {}\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button\n      id=\"button-tags\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button\n      id=\"button-src\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">Quelle: {{Quelle}}</div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button\n      id=\"button-nid\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    <i>Was</i> wird hier bei <b>①</b> gezeigt?\n\n    <br>\n    <br>\n\n    {{#Hint / Hinweis}}\n      <span style=\"color:IndianRed; font-weight: bold;\">Hinweis:</span> {{hint:Hint / Hinweis}}\n\n      <br>\n      <br>\n    {{/Hint / Hinweis}}\n    \n    {{Bild}}\n\n    <br>\n    <br>\n\n    <span class=\"cloze\">{{Markierung 1}}</span>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- BUTTON FIELDS -->\n    {{#Eigene Notizen & Bilder}}\n  <span id=\"hint-zusatz\" class=\"hintBtn\" data-name=\"Eigene Notizen & Bilder\" style=\"display: none;\">\n    <button id=\"button-zusatz\" class=\"button-general\" onclick=\"toggleHintBtn('hint-zusatz'); event.stopPropagation()\">\n      <img src=\"__zusatz.svg\" style=\"height: 10px;\"> Eigene Notizen & Bilder\n    </button>\n    <div id=\"zusatz\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Notizen & Bilder}}</div>\n  </span>\n{{/Eigene Notizen & Bilder}}\n\n    {{#Eigene Prüfungsfragen}}\n  <span id=\"hint-hammer\" class=\"hintBtn\" data-name=\"Eigene Prüfungsfragen\" style=\"display: none;\">\n    <button id=\"button-hammer\" class=\"button-general\" onclick=\"toggleHintBtn('hint-hammer'); event.stopPropagation()\">\n      <img src=\"__hammer.svg\" style=\"height: 10px;\"> Eigene Prüfungsfragen\n    </button>\n    <div id=\"hammer\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Prüfungsfragen}}</div>\n  </span>\n{{/Eigene Prüfungsfragen}}\n\n    {{#Definitionen}}\n  <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Definitionen\" style=\"display: none;\">\n    <button id=\"button-definition\" class=\"button-general\" onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n      <img src=\"__explanation.svg\" style=\"height: 10px;\"> Definitionen\n    </button>\n    <div id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Definitionen}}</div>\n  </span>\n{{/Definitionen}}\n\n    {{#Merksprüche}}\n  <span id=\"hint-merksprueche\" class=\"hintBtn\" data-name=\"Merksprüche\" style=\"display: none;\">\n    <button id=\"button-merksprueche\" class=\"button-general\" onclick=\"toggleHintBtn('hint-merksprueche'); event.stopPropagation()\">\n      <img src=\"__merkhilfe.svg\" style=\"height: 10px;\"> Merksprüche\n    </button>\n    <div id=\"merksprueche\" class=\"hints\" style=\"display: none;\">{{edit:Merksprüche}}</div>\n  </span>\n{{/Merksprüche}}\n\n    {{#Klinik}}\n  <span id=\"hint-klinik\" class=\"hintBtn\" data-name=\"Klinik\" style=\"display: none;\">\n    <button id=\"button-klinik\" class=\"button-general\" onclick=\"toggleHintBtn('hint-klinik'); event.stopPropagation()\">\n      <img src=\"__stethoscope.svg\" style=\"height: 10px;\"> Klinik\n    </button>\n    <div id=\"klinik\" class=\"hints\" style=\"display: none;\">{{edit:Klinik}}</div>\n  </span>\n{{/Klinik}}\n\n    {{#Präparat}}\n      <span id=\"hint-praeparat-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Präparat}}\">\n          <button id=\"button-praeparat\" class=\"button-general\">\n            <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n          </button>\n        </a>\n      </span>\n    {{/Präparat}}\n\n    {{#Virtuelle Mikroskopie}}\n      <span id=\"hint-microscope-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Virtuelle Mikroskopie}}\">\n          <button id=\"button-microscope\" class=\"button-general\">\n            <img src=\"__microscope.svg\" style=\"height: 10px;\"> Virtuelle Mikroskopie\n          </button>\n        </a>\n      </span>\n    {{/Virtuelle Mikroskopie}}\n\n    {{#Smart Zoom}}\n      <span id=\"hint-smartzoom-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Präparat}}\">\n          <button id=\"button-smartzoom\" class=\"button-general\">\n            <img src=\"__microscope.svg\" style=\"height: 10px;\"> Smart Zoom\n          </button>\n        </a>\n      </span>\n    {{/Smart Zoom}}\n\n    {{#HistoTrainer}}\n  <span id=\"hint-praeparat\" class=\"hintBtn\" data-name=\"HistoTrainer\" style=\"display: none;\">\n    <button id=\"button-praeparat\" class=\"button-general\" onclick=\"toggleHintBtn('hint-praeparat'); event.stopPropagation()\">\n      <img src=\"__microscope.svg\" style=\"height: 10px;\"> HistoTrainer\n    </button>\n    <div id=\"praeparat\" class=\"hints\" style=\"display: none;\">{{edit:HistoTrainer}}</div>\n  </span>\n{{/HistoTrainer}}\n\n    {{#Memes}}\n  <span id=\"hint-memes\" class=\"hintBtn\" data-name=\"Memes\" style=\"display: none;\">\n    <button id=\"button-memes\" class=\"button-general\" onclick=\"toggleHintBtn('hint-memes'); event.stopPropagation()\">\n      <img src=\"__sonstiges.svg\" style=\"height: 10px;\"> Memes\n    </button>\n    <div id=\"memes\" class=\"hints\" style=\"display: none;\">{{edit:Memes}}</div>\n  </span>\n{{/Memes}}\n\n    <!-- Extra field -->\n    {{#Extra}}\n      <div id=\"extra\" style=\"display: none;\">\n        <br><br>{{edit:Extra}}</div>\n    {{/Extra}}\n\n    {{#AMBOSS-Link}}\n      <span id=\"hint-amboss\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:AMBOSS-Link}}\">\n          <button id=\"button-amboss\" class=\"button-general\">\n            <img src=\"__amboss.svg\" style=\"height: 10px;\"> AMBOSS&#8203;\n          </button>\n        </a>\n      </span>\n    {{/AMBOSS-Link}}\n    \n    {{#Thieme via medici-Link}}\n      <span id=\"hint-thieme\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Thieme via medici-Link}}\">\n          <button id=\"button-thieme\" class=\"button-general\">\n            <img id=\"button-thieme-img\" src=\"__thieme-heart.svg\" style=\"height: 10px;\"> Thieme via medici\n          </button>\n        </a>\n      </span>\n    {{/Thieme via medici-Link}}\n\n    {{#Meditricks}}\n  <span id=\"hint-meditricks\" class=\"hintBtn\" data-name=\"Meditricks\" style=\"display: none;\">\n    <button id=\"button-meditricks\" class=\"button-general\" onclick=\"toggleHintBtn('hint-meditricks'); event.stopPropagation()\">\n      <img src=\"__meditricks.svg\" style=\"height: 10px;\"> Meditricks\n    </button>\n    <div id=\"meditricks\" class=\"hints\" style=\"display: none;\">{{edit:Meditricks}}</div>\n  </span>\n{{/Meditricks}}\n\n    {{#weitere Links}}\n    <span id=\"hint-linkcontainer\" class=\"hintBtn\" data-name=\"linkContainer\" style=\"display: none;\">\n      <button id=\"button-linkcontainer\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-linkcontainer'); event.stopPropagation()\">\n        <img src=\"__internet.svg\" style=\"height: 10px;\"> weitere Links\n      </button>\n      <div id=\"linkcontainer\" class=\"hints\" style=\"display: none;\"></div>\n      <span id=\"linkContainerLinks\" style=\"display: none;\">{{edit:weitere Links}}</span>\n    </span>\n  {{/weitere Links}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function(type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function(ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n  <script>\n    var tagContainer = document.getElementById(\"tags-container\")\n\n    if (tagContainer.childElementCount == 0) {\n      var tagList = tagContainer.innerHTML.trim().split(\" \");\n      var kbdList = [];\n      var newTagContent = document.createElement(\"div\");\n\n      for (var i = 0; i < tagList.length; i++) {\n        var newTag = document.createElement(\"kbd\");\n        var tag = tagList[i];\n        // numTagLevelsToShow == 0 means the whole tag should be shown\n        if (numTagLevelsToShow != 0) {\n          tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n        }\n\n        // Zankiphil / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n        if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) continue;\n        if (tag.split(\"::\")[1] == \"!NEW_CARDS\") continue;\n        if (tag.split(\"::\")[1] == \"§Projekt_Anki\") continue;\n        if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") continue;\n\n        // improve legibility of tags\n        tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n        tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\");\n        tag = tag.replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n        newTag.innerHTML = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"_\", \" \");\n        newTagContent.append(newTag)\n      }\n\n      tagContainer.innerHTML = newTagContent.innerHTML;\n      tagContainer.style.cursor = \"default\";\n    }\n\n    if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n      tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n    }\n\n    function showtags() {\n      var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n      if (tagContainerShortcut.style.display === \"none\") {\n        tagContainerShortcut.style.display = \"inline\";\n      } else {\n        tagContainerShortcut.style.display = \"none\";\n      }\n    }\n\n    var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n    ankingAddEventListener('keyup', function (e) {\n      if (isShortcut(e)) {\n        toggleHintBtn('hint-tags');\n        showtags();\n      }\n    });\n  </script>\n  <script>\n    for (const tag of document.getElementsByTagName('kbd')) {\n      tag.innerHTML = tag.innerHTML.replace(/::/g, '::<wbr>')\n    }\n  </script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (el.style.display === 'none') {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n    try {\n        for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n            href = link.href\n            text = link.innerText\n\n            const el = document.createElement('a');\n            el.setAttribute('href', link.href);\n\n            const btn = document.createElement('button');\n            btn.classList.add('button-general');\n            btn.classList.add('expanded-button');\n\n            domain = href.replace(/.+\\/\\/|(www|flexikon|de|next|com).|\\..+/g, '');\n            domainDict = {\n                \"amboss\": \"__amboss.svg\",\n                \"wikipedia\": \"__wikipedia.svg\",\n                \"doccheck\": \"__doccheck.png\",\n                \"notfallguru\": \"__notfallguru.svg\",\n            }\n            if (domain in domainDict) {\n                icon = domainDict[domain]\n            } else {\n                icon = \"__internet.svg\"\n            }\n\n            const img = document.createElement('img');\n            img.setAttribute('src', icon);\n            img.setAttribute('style', 'height: 10px;');\n\n            btn.appendChild(img);\n            btn.innerHTML = btn.innerHTML + \" \" + text;\n\n            el.appendChild(btn);\n\n            document.getElementById(\"linkcontainer\").appendChild(el)\n        }\n    }\n    catch (err) {\n        console.log(err)\n    }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\nfunction getTextWidth(text, font) {\n // re-use canvas object for better performance\n const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n const context = canvas.getContext(\"2d\");\n context.font = font;\n const metrics = context.measureText(text);\n return metrics.width;\n}\n\nfunction getCSSStyle(element, prop) {\n return window.getComputedStyle(element, null).getPropertyValue(prop);\n}\n\nfunction getCanvasFont(el = document.body) {\n const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n const fontSize = getCSSStyle(el, 'font-size') || '16px';\n const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n return `${fontWeight} ${fontSize} ${fontFamily}`;\n}\n\n/**\n* Iterates over a list of divs containing text to be indented\n*\n* @param {HTMLCollection} divs: The divs to be iterated over.\n*/\nfunction indentText(divs) {\n // setup the indentation markers\n var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n var bulletP = \"•\"\n var minus = \"– \"\n var enter = \"↳(?!( ↳|↳))\"\n var arrow = \"→\"\n\n // heuristic indentation hierarchy\n hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n // set up RegEx to analyze the provided divs\n // negative lookbehinds unfortunately do not work yet on iPad / Android\n var beginning = '(?<=<br>)(?<!cloze=\")('\n var middle = \".*?)((?:<br>)(?=(\"\n var end = \"))|(?=(<\\/indent>|<\\/div>|<br><br>)))\"\n\n const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n // iterate over divs\n for (const div of divs) {\n   // calculate indentation depths\n   var canvasFont = getCanvasFont(div)\n   var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n   var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n   var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n   var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n   var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n   var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n   var indentEnd = ';\">$1</indent>'\n\n   // do the indentation\n   divHTML = div.outerHTML\n   divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n   divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n   div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\")\n }\n}\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits( n ) {\n      return (n <= 9 ? \"0\" + n : n); \n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n      \n      if ( msLeft < 1000 ) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date( msLeft );\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout( updateTimer, time.getUTCMilliseconds() + 500 );\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60*minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds ); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function(key, dictionary){\n        return dictionary[key];\n      }\n    }\n    \n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n      \n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n      \n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n/**\n * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n * Full credit to the original authors, except where modified or otherwise indicated.\n */\n\n/**\n *\n * We try to respect that people use various note types\n * which may do 'weird' stuff.\n * Elements may have event listeners that can be removed if we just innerHTML stuff\n * <i> may be styled 'i { display: block }', etc.\n *\n * Another problem that complicate the design of this script is that\n * a word may not be cleanly separated by html tags.\n * e.g. \"A<i>long</i>word\"\n *\n */\n\n(function () {\n  /**\n   * @param {String} text\n   * @returns {number}\n   */\n  function getBoldLength(text) {\n    return Math.floor(text.length / 2);\n  }\n\n  // Ignore node if any of the filters return true\n  const excludeFilters = [\n    (elem) => elem.tagName === \"SCRIPT\",\n    (elem) => elem.tagName === \"STYLE\",\n    (elem) => elem.classList.contains(\"cloze\"),\n  ];\n\n  function newBoldElement(text) {\n    const elem = document.createElement(\"strong\");\n    elem.innerText = text;\n    return elem;\n  }\n\n  function indexOfWhitespace(text, startPos) {\n    const whitespaces = [\n      \" \",\n      \"\\n\",\n      \"\\t\",\n      \" \",\n      \"&nbsp;\",\n      \"‑\",\n      \"-\",\n      \"/\",\n      \"(\",\n      \")\",\n    ];\n    let nextPos = text.length;\n    for (const whitespace of whitespaces) {\n      const next = text.indexOf(whitespace, startPos);\n      if (next !== -1 && next < nextPos) {\n        nextPos = next;\n      }\n    }\n    if (nextPos === text.length) {\n      nextPos = -1;\n    }\n    return nextPos;\n  }\n\n  // Bolds a line of words\n  class BionicReaderBolder {\n    constructor(nodes) {\n      this.nodes = nodes;\n      this.startNodeIndex = 0;\n      this.startPos = 0;\n      this.replaceNodes = [];\n      while (!this.isFinished()) {\n        this.runWithinNode();\n        this.runInterNode();\n      }\n    }\n\n    static run(nodes) {\n      new BionicReaderBolder(nodes);\n    }\n\n    isFinished() {\n      return this.startNodeIndex === this.nodes.length;\n    }\n\n    replaceNode() {\n      const node = this.nodes[this.startNodeIndex];\n      const parent = node.parentNode;\n      for (let add of this.replaceNodes) {\n        parent.insertBefore(add, node);\n      }\n      parent.removeChild(node);\n      this.replaceNodes = [];\n    }\n\n    runWithinNode() {\n      const textContent = this.nodes[this.startNodeIndex].textContent;\n      let nextPos = indexOfWhitespace(textContent, this.startPos);\n      while (nextPos !== -1) {\n        const word = textContent.substring(this.startPos, nextPos);\n        const boldLength = getBoldLength(word);\n        this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n        this.replaceNodes.push(\n          document.createTextNode(\n            word.substring(boldLength, nextPos) + textContent[nextPos]\n          )\n        );\n        this.startPos = nextPos + 1;\n        nextPos = indexOfWhitespace(textContent, this.startPos);\n      }\n    }\n\n    // after this, startPos is likely to be at whitespace char\n    runInterNode() {\n      let word = \"\";\n      let endNodeIndex = this.startNodeIndex;\n      let endPos = this.startPos; // last word char pos + 1\n\n      // Find word boundary\n      while (endNodeIndex < this.nodes.length) {\n        const textContent = this.nodes[endNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, endPos);\n        if (nextPos === -1) {\n          word += textContent.substring(endPos);\n          endNodeIndex += 1;\n          endPos = 0;\n        } else {\n          word += textContent.substring(endPos, nextPos);\n          endPos = nextPos;\n          break;\n        }\n      }\n      // Calculate bold length\n      let remainingBoldLength = getBoldLength(word);\n\n      // Bold part of word\n      while (remainingBoldLength > 0) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        if (remainingBoldLength > textContent.length - this.startPos) {\n          const wordPart = textContent.substring(this.startPos);\n          remainingBoldLength -= wordPart.length;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        } else {\n          const wordPart = textContent.substring(\n            this.startPos,\n            this.startPos + remainingBoldLength\n          );\n          this.startPos += remainingBoldLength;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          remainingBoldLength -= wordPart.length;\n        }\n      }\n\n      // Add non-bolded part of words\n      while (this.startNodeIndex < endNodeIndex) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.replaceNode();\n        this.startNodeIndex += 1;\n        this.startPos = 0;\n      }\n\n      if (this.startPos < endPos) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos, endPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.startPos = endPos;\n      }\n    }\n  }\n\n  /**\n   * Builds a list of (list of nodes that makes up one non-line-broken line)\n   * @param {Node} elem\n   * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n   * @returns {void}\n   */\n  function forTextNodesInTree(elem, nodes, exclude = false) {\n    const children = elem.childNodes;\n    for (const filter of excludeFilters) {\n      if (filter(elem)) {\n        exclude = true;\n        break;\n      }\n    }\n    for (const child of children) {\n      if (child.nodeType === Node.ELEMENT_NODE) {\n        const style = window.getComputedStyle(child);\n        if (\n          child.tagName !== \"BR\" &&\n          (style === \"inline\" || style === \"inline-block\")\n        ) {\n          forTextNodesInTree(child, nodes, exclude);\n        } else {\n          if (nodes[nodes.length - 1].length > 0) {\n            nodes.push([]);\n          }\n          forTextNodesInTree(child, nodes, exclude);\n        }\n      } else if (\n        !exclude &&\n        child.nodeType === Node.TEXT_NODE &&\n        child.textContent.length > 0\n      ) {\n        nodes[nodes.length - 1].push(child);\n      }\n    }\n  }\n\n  function makeBionic() {\n    const cardContainer = document.getElementById(\"container\");\n    cardContainer.normalize();\n\n    let nodesLines = [[]];\n    forTextNodesInTree(cardContainer, nodesLines);\n    for (const nodes of nodesLines) {\n      BionicReaderBolder.run(nodes);\n    }\n\n    cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n      \"<strong></strong>\",\n      \"\"\n    );\n    cardContainer.normalize();\n  }\n\n  let start = performance.now();\n  if (bionicReading) {\n    makeBionic();\n  }\n  let end = performance.now();\n  console.log(`Initialized bionic reading: ${end - start}ms`);\n})();\n</script>\n\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\nvar userJs1 = undefined\nvar userJs2 = undefined\nvar userJs3 = undefined\nvar userJs4 = undefined\nvar userJs5 = undefined\nvar userJs6 = undefined\nvar userJs7 = undefined\nvar userJs8 = undefined\n</script>\n",
      "bqfmt": "{{Titel}}",
      "bafmt": "{{Markierung 1}}",
      "did": null,
      "bfont": "Helvetica",
      "bsize": 12
    },
    {
      "name": "Markierung 2",
      "ord": 1,
      "qfmt": "<!-- version 0fd8612 -->\n{{#Markierung 2}}\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TIMER CONFIG  ##############\n// Timer config (timer length, timer finished message)\nvar minutes =  0\nvar seconds = 15\nvar timeOverMsg = \"<span style='color:#CC5B5B'>!!!</span>\"\n\n  // ##############  TAG SHORTCUT  ##############\nvar toggleTagsShortcut = \"C\";\n\n// ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\nvar tagID = \"XXXYYYZZZ\"\n\n// WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\nvar numTagLevelsToShow = 0;\n\n// ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\nvar tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n// Enable experimental heuristic indentation feature\nvar indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n// Enable experimental DIVI medication formatting feature\nvar formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n// Enable experimental confounder formatting feature\nvar formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n// Enable bionic reading feature (based on AnKing add-on)\nvar bionicReading = false;\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button\n        id=\"button-tags\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n      >\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button\n        id=\"button-src\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n      >\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button\n        id=\"button-nid\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n      >\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button\n          id=\"button-ankihub\"\n          class=\"button-general\"\n          title=\"Karte in AnkiHub\"\n        >\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) {}\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button\n      id=\"button-tags\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button\n      id=\"button-src\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">Quelle: {{Quelle}}</div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button\n      id=\"button-nid\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    <i>Was</i> wird hier bei <b>②</b> gezeigt?\n\n    <br>\n    <br>\n\n    {{#Hint / Hinweis}}\n      <span style=\"color:IndianRed; font-weight: bold;\">Hinweis:</span> {{hint:Hint / Hinweis}}\n\n      <br>\n      <br>\n    {{/Hint / Hinweis}}\n    \n    {{Bild}}\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\"></div>\n\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n<script>\n  //DONT FADE BETWEEN CARDS\n  qFade = 0;\n  if (typeof anki !== 'undefined') anki.qFade = qFade;\n</script>\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\nfunction getTextWidth(text, font) {\n // re-use canvas object for better performance\n const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n const context = canvas.getContext(\"2d\");\n context.font = font;\n const metrics = context.measureText(text);\n return metrics.width;\n}\n\nfunction getCSSStyle(element, prop) {\n return window.getComputedStyle(element, null).getPropertyValue(prop);\n}\n\nfunction getCanvasFont(el = document.body) {\n const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n const fontSize = getCSSStyle(el, 'font-size') || '16px';\n const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n return `${fontWeight} ${fontSize} ${fontFamily}`;\n}\n\n/**\n* Iterates over a list of divs containing text to be indented\n*\n* @param {HTMLCollection} divs: The divs to be iterated over.\n*/\nfunction indentText(divs) {\n // setup the indentation markers\n var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n var bulletP = \"•\"\n var minus = \"– \"\n var enter = \"↳(?!( ↳|↳))\"\n var arrow = \"→\"\n\n // heuristic indentation hierarchy\n hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n // set up RegEx to analyze the provided divs\n // negative lookbehinds unfortunately do not work yet on iPad / Android\n var beginning = '(?<=<br>)(?<!cloze=\")('\n var middle = \".*?)((?:<br>)(?=(\"\n var end = \"))|(?=(<\\/indent>|<\\/div>|<br><br>)))\"\n\n const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n // iterate over divs\n for (const div of divs) {\n   // calculate indentation depths\n   var canvasFont = getCanvasFont(div)\n   var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n   var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n   var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n   var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n   var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n   var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n   var indentEnd = ';\">$1</indent>'\n\n   // do the indentation\n   divHTML = div.outerHTML\n   divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n   divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n   div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\")\n }\n}\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function(type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function(ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n  <script>\n    var tagContainer = document.getElementById(\"tags-container\")\n\n    if (tagContainer.childElementCount == 0) {\n      var tagList = tagContainer.innerHTML.trim().split(\" \");\n      var kbdList = [];\n      var newTagContent = document.createElement(\"div\");\n\n      for (var i = 0; i < tagList.length; i++) {\n        var newTag = document.createElement(\"kbd\");\n        var tag = tagList[i];\n        // numTagLevelsToShow == 0 means the whole tag should be shown\n        if (numTagLevelsToShow != 0) {\n          tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n        }\n\n        // Zankiphil / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n        if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) continue;\n        if (tag.split(\"::\")[1] == \"!NEW_CARDS\") continue;\n        if (tag.split(\"::\")[1] == \"§Projekt_Anki\") continue;\n        if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") continue;\n\n        // improve legibility of tags\n        tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n        tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\");\n        tag = tag.replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n        newTag.innerHTML = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"_\", \" \");\n        newTagContent.append(newTag)\n      }\n\n      tagContainer.innerHTML = newTagContent.innerHTML;\n      tagContainer.style.cursor = \"default\";\n    }\n\n    if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n      tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n    }\n\n    function showtags() {\n      var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n      if (tagContainerShortcut.style.display === \"none\") {\n        tagContainerShortcut.style.display = \"inline\";\n      } else {\n        tagContainerShortcut.style.display = \"none\";\n      }\n    }\n\n    var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n    ankingAddEventListener('keyup', function (e) {\n      if (isShortcut(e)) {\n        toggleHintBtn('hint-tags');\n        showtags();\n      }\n    });\n  </script>\n  <script>\n    for (const tag of document.getElementsByTagName('kbd')) {\n      tag.innerHTML = tag.innerHTML.replace(/::/g, '::<wbr>')\n    }\n  </script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (el.style.display === 'none') {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits( n ) {\n      return (n <= 9 ? \"0\" + n : n); \n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n      \n      if ( msLeft < 1000 ) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date( msLeft );\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout( updateTimer, time.getUTCMilliseconds() + 500 );\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60*minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds ); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function(key, dictionary){\n        return dictionary[key];\n      }\n    }\n    \n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n      \n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n      \n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n/**\n * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n * Full credit to the original authors, except where modified or otherwise indicated.\n */\n\n/**\n *\n * We try to respect that people use various note types\n * which may do 'weird' stuff.\n * Elements may have event listeners that can be removed if we just innerHTML stuff\n * <i> may be styled 'i { display: block }', etc.\n *\n * Another problem that complicate the design of this script is that\n * a word may not be cleanly separated by html tags.\n * e.g. \"A<i>long</i>word\"\n *\n */\n\n(function () {\n  /**\n   * @param {String} text\n   * @returns {number}\n   */\n  function getBoldLength(text) {\n    return Math.floor(text.length / 2);\n  }\n\n  // Ignore node if any of the filters return true\n  const excludeFilters = [\n    (elem) => elem.tagName === \"SCRIPT\",\n    (elem) => elem.tagName === \"STYLE\",\n    (elem) => elem.classList.contains(\"cloze\"),\n  ];\n\n  function newBoldElement(text) {\n    const elem = document.createElement(\"strong\");\n    elem.innerText = text;\n    return elem;\n  }\n\n  function indexOfWhitespace(text, startPos) {\n    const whitespaces = [\n      \" \",\n      \"\\n\",\n      \"\\t\",\n      \" \",\n      \"&nbsp;\",\n      \"‑\",\n      \"-\",\n      \"/\",\n      \"(\",\n      \")\",\n    ];\n    let nextPos = text.length;\n    for (const whitespace of whitespaces) {\n      const next = text.indexOf(whitespace, startPos);\n      if (next !== -1 && next < nextPos) {\n        nextPos = next;\n      }\n    }\n    if (nextPos === text.length) {\n      nextPos = -1;\n    }\n    return nextPos;\n  }\n\n  // Bolds a line of words\n  class BionicReaderBolder {\n    constructor(nodes) {\n      this.nodes = nodes;\n      this.startNodeIndex = 0;\n      this.startPos = 0;\n      this.replaceNodes = [];\n      while (!this.isFinished()) {\n        this.runWithinNode();\n        this.runInterNode();\n      }\n    }\n\n    static run(nodes) {\n      new BionicReaderBolder(nodes);\n    }\n\n    isFinished() {\n      return this.startNodeIndex === this.nodes.length;\n    }\n\n    replaceNode() {\n      const node = this.nodes[this.startNodeIndex];\n      const parent = node.parentNode;\n      for (let add of this.replaceNodes) {\n        parent.insertBefore(add, node);\n      }\n      parent.removeChild(node);\n      this.replaceNodes = [];\n    }\n\n    runWithinNode() {\n      const textContent = this.nodes[this.startNodeIndex].textContent;\n      let nextPos = indexOfWhitespace(textContent, this.startPos);\n      while (nextPos !== -1) {\n        const word = textContent.substring(this.startPos, nextPos);\n        const boldLength = getBoldLength(word);\n        this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n        this.replaceNodes.push(\n          document.createTextNode(\n            word.substring(boldLength, nextPos) + textContent[nextPos]\n          )\n        );\n        this.startPos = nextPos + 1;\n        nextPos = indexOfWhitespace(textContent, this.startPos);\n      }\n    }\n\n    // after this, startPos is likely to be at whitespace char\n    runInterNode() {\n      let word = \"\";\n      let endNodeIndex = this.startNodeIndex;\n      let endPos = this.startPos; // last word char pos + 1\n\n      // Find word boundary\n      while (endNodeIndex < this.nodes.length) {\n        const textContent = this.nodes[endNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, endPos);\n        if (nextPos === -1) {\n          word += textContent.substring(endPos);\n          endNodeIndex += 1;\n          endPos = 0;\n        } else {\n          word += textContent.substring(endPos, nextPos);\n          endPos = nextPos;\n          break;\n        }\n      }\n      // Calculate bold length\n      let remainingBoldLength = getBoldLength(word);\n\n      // Bold part of word\n      while (remainingBoldLength > 0) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        if (remainingBoldLength > textContent.length - this.startPos) {\n          const wordPart = textContent.substring(this.startPos);\n          remainingBoldLength -= wordPart.length;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        } else {\n          const wordPart = textContent.substring(\n            this.startPos,\n            this.startPos + remainingBoldLength\n          );\n          this.startPos += remainingBoldLength;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          remainingBoldLength -= wordPart.length;\n        }\n      }\n\n      // Add non-bolded part of words\n      while (this.startNodeIndex < endNodeIndex) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.replaceNode();\n        this.startNodeIndex += 1;\n        this.startPos = 0;\n      }\n\n      if (this.startPos < endPos) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos, endPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.startPos = endPos;\n      }\n    }\n  }\n\n  /**\n   * Builds a list of (list of nodes that makes up one non-line-broken line)\n   * @param {Node} elem\n   * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n   * @returns {void}\n   */\n  function forTextNodesInTree(elem, nodes, exclude = false) {\n    const children = elem.childNodes;\n    for (const filter of excludeFilters) {\n      if (filter(elem)) {\n        exclude = true;\n        break;\n      }\n    }\n    for (const child of children) {\n      if (child.nodeType === Node.ELEMENT_NODE) {\n        const style = window.getComputedStyle(child);\n        if (\n          child.tagName !== \"BR\" &&\n          (style === \"inline\" || style === \"inline-block\")\n        ) {\n          forTextNodesInTree(child, nodes, exclude);\n        } else {\n          if (nodes[nodes.length - 1].length > 0) {\n            nodes.push([]);\n          }\n          forTextNodesInTree(child, nodes, exclude);\n        }\n      } else if (\n        !exclude &&\n        child.nodeType === Node.TEXT_NODE &&\n        child.textContent.length > 0\n      ) {\n        nodes[nodes.length - 1].push(child);\n      }\n    }\n  }\n\n  function makeBionic() {\n    const cardContainer = document.getElementById(\"container\");\n    cardContainer.normalize();\n\n    let nodesLines = [[]];\n    forTextNodesInTree(cardContainer, nodesLines);\n    for (const nodes of nodesLines) {\n      BionicReaderBolder.run(nodes);\n    }\n\n    cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n      \"<strong></strong>\",\n      \"\"\n    );\n    cardContainer.normalize();\n  }\n\n  let start = performance.now();\n  if (bionicReading) {\n    makeBionic();\n  }\n  let end = performance.now();\n  console.log(`Initialized bionic reading: ${end - start}ms`);\n})();\n</script>\n\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\nvar userJs1 = undefined\nvar userJs2 = undefined\nvar userJs3 = undefined\nvar userJs4 = undefined\nvar userJs5 = undefined\nvar userJs6 = undefined\nvar userJs7 = undefined\nvar userJs8 = undefined\n</script>\n\n\n{{/Markierung 2}}",
      "afmt": "<!-- version 0fd8612 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Eigene Notizen & Bilder\": \"Alt + 1\",\n    \"Eigene Prüfungsfragen\": \"Alt + 2\",\n    \"Definitionen\": \"Alt + 3\",\n    \"Merksprüche\": \"Alt + 4\",\n    \"Klinik\": \"Alt + 5\",\n    \"Präparat\": \"Alt + 6\",\n    \"Memes\": \"Alt + 7\",\n    \"linkContainer\": \"Alt + L\",\n    \"Meditricks\": \"Alt + M\",\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Eigene Notizen & Bilder\": false,\n    \"Eigene Prüfungsfragen\": false,\n    \"Definitionen\": false,\n    \"Merksprüche\": false,\n    \"Klinik\": false,\n    \"Präparat\": false,\n    \"Memes\": false,\n    \"linkContainer\": true,\n    \"Meditricks\": false,\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\":false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\nvar toggleTagsShortcut = \"C\";\n\n// ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\nvar tagID = \"XXXYYYZZZ\"\n\n// WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\nvar numTagLevelsToShow = 0;\n\n// ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\nvar tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n// Enable experimental heuristic indentation feature\nvar indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n// Enable experimental DIVI medication formatting feature\nvar formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n// Enable experimental confounder formatting feature\nvar formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n// Enable bionic reading feature (based on AnKing add-on)\nvar bionicReading = false;\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button\n        id=\"button-tags\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n      >\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button\n        id=\"button-src\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n      >\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button\n        id=\"button-nid\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n      >\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button\n          id=\"button-ankihub\"\n          class=\"button-general\"\n          title=\"Karte in AnkiHub\"\n        >\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) {}\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button\n      id=\"button-tags\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button\n      id=\"button-src\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">Quelle: {{Quelle}}</div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button\n      id=\"button-nid\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    <i>Was</i> wird hier bei <b>②</b> gezeigt?\n\n    <br>\n    <br>\n\n    {{#Hint / Hinweis}}\n      <span style=\"color:IndianRed; font-weight: bold;\">Hinweis:</span> {{hint:Hint / Hinweis}}\n\n      <br>\n      <br>\n    {{/Hint / Hinweis}}\n    \n    {{Bild}}\n\n    <br>\n    <br>\n\n    <span class=\"cloze\">{{Markierung 2}}</span>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- BUTTON FIELDS -->\n    {{#Eigene Notizen & Bilder}}\n  <span id=\"hint-zusatz\" class=\"hintBtn\" data-name=\"Eigene Notizen & Bilder\" style=\"display: none;\">\n    <button id=\"button-zusatz\" class=\"button-general\" onclick=\"toggleHintBtn('hint-zusatz'); event.stopPropagation()\">\n      <img src=\"__zusatz.svg\" style=\"height: 10px;\"> Eigene Notizen & Bilder\n    </button>\n    <div id=\"zusatz\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Notizen & Bilder}}</div>\n  </span>\n{{/Eigene Notizen & Bilder}}\n\n    {{#Eigene Prüfungsfragen}}\n  <span id=\"hint-hammer\" class=\"hintBtn\" data-name=\"Eigene Prüfungsfragen\" style=\"display: none;\">\n    <button id=\"button-hammer\" class=\"button-general\" onclick=\"toggleHintBtn('hint-hammer'); event.stopPropagation()\">\n      <img src=\"__hammer.svg\" style=\"height: 10px;\"> Eigene Prüfungsfragen\n    </button>\n    <div id=\"hammer\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Prüfungsfragen}}</div>\n  </span>\n{{/Eigene Prüfungsfragen}}\n\n    {{#Definitionen}}\n  <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Definitionen\" style=\"display: none;\">\n    <button id=\"button-definition\" class=\"button-general\" onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n      <img src=\"__explanation.svg\" style=\"height: 10px;\"> Definitionen\n    </button>\n    <div id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Definitionen}}</div>\n  </span>\n{{/Definitionen}}\n\n    {{#Merksprüche}}\n  <span id=\"hint-merksprueche\" class=\"hintBtn\" data-name=\"Merksprüche\" style=\"display: none;\">\n    <button id=\"button-merksprueche\" class=\"button-general\" onclick=\"toggleHintBtn('hint-merksprueche'); event.stopPropagation()\">\n      <img src=\"__merkhilfe.svg\" style=\"height: 10px;\"> Merksprüche\n    </button>\n    <div id=\"merksprueche\" class=\"hints\" style=\"display: none;\">{{edit:Merksprüche}}</div>\n  </span>\n{{/Merksprüche}}\n\n    {{#Klinik}}\n  <span id=\"hint-klinik\" class=\"hintBtn\" data-name=\"Klinik\" style=\"display: none;\">\n    <button id=\"button-klinik\" class=\"button-general\" onclick=\"toggleHintBtn('hint-klinik'); event.stopPropagation()\">\n      <img src=\"__stethoscope.svg\" style=\"height: 10px;\"> Klinik\n    </button>\n    <div id=\"klinik\" class=\"hints\" style=\"display: none;\">{{edit:Klinik}}</div>\n  </span>\n{{/Klinik}}\n\n    {{#Präparat}}\n      <span id=\"hint-praeparat-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Präparat}}\">\n          <button id=\"button-praeparat\" class=\"button-general\">\n            <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n          </button>\n        </a>\n      </span>\n    {{/Präparat}}\n\n    {{#Virtuelle Mikroskopie}}\n      <span id=\"hint-microscope-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Virtuelle Mikroskopie}}\">\n          <button id=\"button-microscope\" class=\"button-general\">\n            <img src=\"__microscope.svg\" style=\"height: 10px;\"> Virtuelle Mikroskopie\n          </button>\n        </a>\n      </span>\n    {{/Virtuelle Mikroskopie}}\n\n    {{#Smart Zoom}}\n      <span id=\"hint-smartzoom-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Präparat}}\">\n          <button id=\"button-smartzoom\" class=\"button-general\">\n            <img src=\"__microscope.svg\" style=\"height: 10px;\"> Smart Zoom\n          </button>\n        </a>\n      </span>\n    {{/Smart Zoom}}\n\n    {{#HistoTrainer}}\n  <span id=\"hint-praeparat\" class=\"hintBtn\" data-name=\"HistoTrainer\" style=\"display: none;\">\n    <button id=\"button-praeparat\" class=\"button-general\" onclick=\"toggleHintBtn('hint-praeparat'); event.stopPropagation()\">\n      <img src=\"__microscope.svg\" style=\"height: 10px;\"> HistoTrainer\n    </button>\n    <div id=\"praeparat\" class=\"hints\" style=\"display: none;\">{{edit:HistoTrainer}}</div>\n  </span>\n{{/HistoTrainer}}\n\n    {{#Memes}}\n  <span id=\"hint-memes\" class=\"hintBtn\" data-name=\"Memes\" style=\"display: none;\">\n    <button id=\"button-memes\" class=\"button-general\" onclick=\"toggleHintBtn('hint-memes'); event.stopPropagation()\">\n      <img src=\"__sonstiges.svg\" style=\"height: 10px;\"> Memes\n    </button>\n    <div id=\"memes\" class=\"hints\" style=\"display: none;\">{{edit:Memes}}</div>\n  </span>\n{{/Memes}}\n\n    <!-- Extra field -->\n    {{#Extra}}\n      <div id=\"extra\" style=\"display: none;\">\n        <br><br>{{edit:Extra}}</div>\n    {{/Extra}}\n\n    {{#AMBOSS-Link}}\n      <span id=\"hint-amboss\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:AMBOSS-Link}}\">\n          <button id=\"button-amboss\" class=\"button-general\">\n            <img src=\"__amboss.svg\" style=\"height: 10px;\"> AMBOSS&#8203;\n          </button>\n        </a>\n      </span>\n    {{/AMBOSS-Link}}\n    \n    {{#Thieme via medici-Link}}\n      <span id=\"hint-thieme\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Thieme via medici-Link}}\">\n          <button id=\"button-thieme\" class=\"button-general\">\n            <img id=\"button-thieme-img\" src=\"__thieme-heart.svg\" style=\"height: 10px;\"> Thieme via medici\n          </button>\n        </a>\n      </span>\n    {{/Thieme via medici-Link}}\n\n    {{#Meditricks}}\n  <span id=\"hint-meditricks\" class=\"hintBtn\" data-name=\"Meditricks\" style=\"display: none;\">\n    <button id=\"button-meditricks\" class=\"button-general\" onclick=\"toggleHintBtn('hint-meditricks'); event.stopPropagation()\">\n      <img src=\"__meditricks.svg\" style=\"height: 10px;\"> Meditricks\n    </button>\n    <div id=\"meditricks\" class=\"hints\" style=\"display: none;\">{{edit:Meditricks}}</div>\n  </span>\n{{/Meditricks}}\n\n    {{#weitere Links}}\n    <span id=\"hint-linkcontainer\" class=\"hintBtn\" data-name=\"linkContainer\" style=\"display: none;\">\n      <button id=\"button-linkcontainer\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-linkcontainer'); event.stopPropagation()\">\n        <img src=\"__internet.svg\" style=\"height: 10px;\"> weitere Links\n      </button>\n      <div id=\"linkcontainer\" class=\"hints\" style=\"display: none;\"></div>\n      <span id=\"linkContainerLinks\" style=\"display: none;\">{{edit:weitere Links}}</span>\n    </span>\n  {{/weitere Links}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function(type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function(ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n  <script>\n    var tagContainer = document.getElementById(\"tags-container\")\n\n    if (tagContainer.childElementCount == 0) {\n      var tagList = tagContainer.innerHTML.trim().split(\" \");\n      var kbdList = [];\n      var newTagContent = document.createElement(\"div\");\n\n      for (var i = 0; i < tagList.length; i++) {\n        var newTag = document.createElement(\"kbd\");\n        var tag = tagList[i];\n        // numTagLevelsToShow == 0 means the whole tag should be shown\n        if (numTagLevelsToShow != 0) {\n          tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n        }\n\n        // Zankiphil / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n        if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) continue;\n        if (tag.split(\"::\")[1] == \"!NEW_CARDS\") continue;\n        if (tag.split(\"::\")[1] == \"§Projekt_Anki\") continue;\n        if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") continue;\n\n        // improve legibility of tags\n        tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n        tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\");\n        tag = tag.replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n        newTag.innerHTML = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"_\", \" \");\n        newTagContent.append(newTag)\n      }\n\n      tagContainer.innerHTML = newTagContent.innerHTML;\n      tagContainer.style.cursor = \"default\";\n    }\n\n    if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n      tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n    }\n\n    function showtags() {\n      var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n      if (tagContainerShortcut.style.display === \"none\") {\n        tagContainerShortcut.style.display = \"inline\";\n      } else {\n        tagContainerShortcut.style.display = \"none\";\n      }\n    }\n\n    var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n    ankingAddEventListener('keyup', function (e) {\n      if (isShortcut(e)) {\n        toggleHintBtn('hint-tags');\n        showtags();\n      }\n    });\n  </script>\n  <script>\n    for (const tag of document.getElementsByTagName('kbd')) {\n      tag.innerHTML = tag.innerHTML.replace(/::/g, '::<wbr>')\n    }\n  </script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (el.style.display === 'none') {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n    try {\n        for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n            href = link.href\n            text = link.innerText\n\n            const el = document.createElement('a');\n            el.setAttribute('href', link.href);\n\n            const btn = document.createElement('button');\n            btn.classList.add('button-general');\n            btn.classList.add('expanded-button');\n\n            domain = href.replace(/.+\\/\\/|(www|flexikon|de|next|com).|\\..+/g, '');\n            domainDict = {\n                \"amboss\": \"__amboss.svg\",\n                \"wikipedia\": \"__wikipedia.svg\",\n                \"doccheck\": \"__doccheck.png\",\n                \"notfallguru\": \"__notfallguru.svg\",\n            }\n            if (domain in domainDict) {\n                icon = domainDict[domain]\n            } else {\n                icon = \"__internet.svg\"\n            }\n\n            const img = document.createElement('img');\n            img.setAttribute('src', icon);\n            img.setAttribute('style', 'height: 10px;');\n\n            btn.appendChild(img);\n            btn.innerHTML = btn.innerHTML + \" \" + text;\n\n            el.appendChild(btn);\n\n            document.getElementById(\"linkcontainer\").appendChild(el)\n        }\n    }\n    catch (err) {\n        console.log(err)\n    }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\nfunction getTextWidth(text, font) {\n // re-use canvas object for better performance\n const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n const context = canvas.getContext(\"2d\");\n context.font = font;\n const metrics = context.measureText(text);\n return metrics.width;\n}\n\nfunction getCSSStyle(element, prop) {\n return window.getComputedStyle(element, null).getPropertyValue(prop);\n}\n\nfunction getCanvasFont(el = document.body) {\n const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n const fontSize = getCSSStyle(el, 'font-size') || '16px';\n const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n return `${fontWeight} ${fontSize} ${fontFamily}`;\n}\n\n/**\n* Iterates over a list of divs containing text to be indented\n*\n* @param {HTMLCollection} divs: The divs to be iterated over.\n*/\nfunction indentText(divs) {\n // setup the indentation markers\n var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n var bulletP = \"•\"\n var minus = \"– \"\n var enter = \"↳(?!( ↳|↳))\"\n var arrow = \"→\"\n\n // heuristic indentation hierarchy\n hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n // set up RegEx to analyze the provided divs\n // negative lookbehinds unfortunately do not work yet on iPad / Android\n var beginning = '(?<=<br>)(?<!cloze=\")('\n var middle = \".*?)((?:<br>)(?=(\"\n var end = \"))|(?=(<\\/indent>|<\\/div>|<br><br>)))\"\n\n const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n // iterate over divs\n for (const div of divs) {\n   // calculate indentation depths\n   var canvasFont = getCanvasFont(div)\n   var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n   var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n   var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n   var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n   var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n   var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n   var indentEnd = ';\">$1</indent>'\n\n   // do the indentation\n   divHTML = div.outerHTML\n   divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n   divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n   div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\")\n }\n}\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits( n ) {\n      return (n <= 9 ? \"0\" + n : n); \n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n      \n      if ( msLeft < 1000 ) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date( msLeft );\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout( updateTimer, time.getUTCMilliseconds() + 500 );\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60*minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds ); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function(key, dictionary){\n        return dictionary[key];\n      }\n    }\n    \n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n      \n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n      \n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n/**\n * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n * Full credit to the original authors, except where modified or otherwise indicated.\n */\n\n/**\n *\n * We try to respect that people use various note types\n * which may do 'weird' stuff.\n * Elements may have event listeners that can be removed if we just innerHTML stuff\n * <i> may be styled 'i { display: block }', etc.\n *\n * Another problem that complicate the design of this script is that\n * a word may not be cleanly separated by html tags.\n * e.g. \"A<i>long</i>word\"\n *\n */\n\n(function () {\n  /**\n   * @param {String} text\n   * @returns {number}\n   */\n  function getBoldLength(text) {\n    return Math.floor(text.length / 2);\n  }\n\n  // Ignore node if any of the filters return true\n  const excludeFilters = [\n    (elem) => elem.tagName === \"SCRIPT\",\n    (elem) => elem.tagName === \"STYLE\",\n    (elem) => elem.classList.contains(\"cloze\"),\n  ];\n\n  function newBoldElement(text) {\n    const elem = document.createElement(\"strong\");\n    elem.innerText = text;\n    return elem;\n  }\n\n  function indexOfWhitespace(text, startPos) {\n    const whitespaces = [\n      \" \",\n      \"\\n\",\n      \"\\t\",\n      \" \",\n      \"&nbsp;\",\n      \"‑\",\n      \"-\",\n      \"/\",\n      \"(\",\n      \")\",\n    ];\n    let nextPos = text.length;\n    for (const whitespace of whitespaces) {\n      const next = text.indexOf(whitespace, startPos);\n      if (next !== -1 && next < nextPos) {\n        nextPos = next;\n      }\n    }\n    if (nextPos === text.length) {\n      nextPos = -1;\n    }\n    return nextPos;\n  }\n\n  // Bolds a line of words\n  class BionicReaderBolder {\n    constructor(nodes) {\n      this.nodes = nodes;\n      this.startNodeIndex = 0;\n      this.startPos = 0;\n      this.replaceNodes = [];\n      while (!this.isFinished()) {\n        this.runWithinNode();\n        this.runInterNode();\n      }\n    }\n\n    static run(nodes) {\n      new BionicReaderBolder(nodes);\n    }\n\n    isFinished() {\n      return this.startNodeIndex === this.nodes.length;\n    }\n\n    replaceNode() {\n      const node = this.nodes[this.startNodeIndex];\n      const parent = node.parentNode;\n      for (let add of this.replaceNodes) {\n        parent.insertBefore(add, node);\n      }\n      parent.removeChild(node);\n      this.replaceNodes = [];\n    }\n\n    runWithinNode() {\n      const textContent = this.nodes[this.startNodeIndex].textContent;\n      let nextPos = indexOfWhitespace(textContent, this.startPos);\n      while (nextPos !== -1) {\n        const word = textContent.substring(this.startPos, nextPos);\n        const boldLength = getBoldLength(word);\n        this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n        this.replaceNodes.push(\n          document.createTextNode(\n            word.substring(boldLength, nextPos) + textContent[nextPos]\n          )\n        );\n        this.startPos = nextPos + 1;\n        nextPos = indexOfWhitespace(textContent, this.startPos);\n      }\n    }\n\n    // after this, startPos is likely to be at whitespace char\n    runInterNode() {\n      let word = \"\";\n      let endNodeIndex = this.startNodeIndex;\n      let endPos = this.startPos; // last word char pos + 1\n\n      // Find word boundary\n      while (endNodeIndex < this.nodes.length) {\n        const textContent = this.nodes[endNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, endPos);\n        if (nextPos === -1) {\n          word += textContent.substring(endPos);\n          endNodeIndex += 1;\n          endPos = 0;\n        } else {\n          word += textContent.substring(endPos, nextPos);\n          endPos = nextPos;\n          break;\n        }\n      }\n      // Calculate bold length\n      let remainingBoldLength = getBoldLength(word);\n\n      // Bold part of word\n      while (remainingBoldLength > 0) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        if (remainingBoldLength > textContent.length - this.startPos) {\n          const wordPart = textContent.substring(this.startPos);\n          remainingBoldLength -= wordPart.length;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        } else {\n          const wordPart = textContent.substring(\n            this.startPos,\n            this.startPos + remainingBoldLength\n          );\n          this.startPos += remainingBoldLength;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          remainingBoldLength -= wordPart.length;\n        }\n      }\n\n      // Add non-bolded part of words\n      while (this.startNodeIndex < endNodeIndex) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.replaceNode();\n        this.startNodeIndex += 1;\n        this.startPos = 0;\n      }\n\n      if (this.startPos < endPos) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos, endPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.startPos = endPos;\n      }\n    }\n  }\n\n  /**\n   * Builds a list of (list of nodes that makes up one non-line-broken line)\n   * @param {Node} elem\n   * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n   * @returns {void}\n   */\n  function forTextNodesInTree(elem, nodes, exclude = false) {\n    const children = elem.childNodes;\n    for (const filter of excludeFilters) {\n      if (filter(elem)) {\n        exclude = true;\n        break;\n      }\n    }\n    for (const child of children) {\n      if (child.nodeType === Node.ELEMENT_NODE) {\n        const style = window.getComputedStyle(child);\n        if (\n          child.tagName !== \"BR\" &&\n          (style === \"inline\" || style === \"inline-block\")\n        ) {\n          forTextNodesInTree(child, nodes, exclude);\n        } else {\n          if (nodes[nodes.length - 1].length > 0) {\n            nodes.push([]);\n          }\n          forTextNodesInTree(child, nodes, exclude);\n        }\n      } else if (\n        !exclude &&\n        child.nodeType === Node.TEXT_NODE &&\n        child.textContent.length > 0\n      ) {\n        nodes[nodes.length - 1].push(child);\n      }\n    }\n  }\n\n  function makeBionic() {\n    const cardContainer = document.getElementById(\"container\");\n    cardContainer.normalize();\n\n    let nodesLines = [[]];\n    forTextNodesInTree(cardContainer, nodesLines);\n    for (const nodes of nodesLines) {\n      BionicReaderBolder.run(nodes);\n    }\n\n    cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n      \"<strong></strong>\",\n      \"\"\n    );\n    cardContainer.normalize();\n  }\n\n  let start = performance.now();\n  if (bionicReading) {\n    makeBionic();\n  }\n  let end = performance.now();\n  console.log(`Initialized bionic reading: ${end - start}ms`);\n})();\n</script>\n\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\nvar userJs1 = undefined\nvar userJs2 = undefined\nvar userJs3 = undefined\nvar userJs4 = undefined\nvar userJs5 = undefined\nvar userJs6 = undefined\nvar userJs7 = undefined\nvar userJs8 = undefined\n</script>\n",
      "bqfmt": "{{Titel}}",
      "bafmt": "{{Markierung 2}}",
      "did": null,
      "bfont": "Helvetica",
      "bsize": 12
    },
    {
      "name": "Markierung 3",
      "ord": 2,
      "qfmt": "<!-- version 0fd8612 -->\n{{#Markierung 3}}\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TIMER CONFIG  ##############\n// Timer config (timer length, timer finished message)\nvar minutes =  0\nvar seconds = 15\nvar timeOverMsg = \"<span style='color:#CC5B5B'>!!!</span>\"\n\n  // ##############  TAG SHORTCUT  ##############\nvar toggleTagsShortcut = \"C\";\n\n// ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\nvar tagID = \"XXXYYYZZZ\"\n\n// WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\nvar numTagLevelsToShow = 0;\n\n// ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\nvar tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n// Enable experimental heuristic indentation feature\nvar indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n// Enable experimental DIVI medication formatting feature\nvar formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n// Enable experimental confounder formatting feature\nvar formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n// Enable bionic reading feature (based on AnKing add-on)\nvar bionicReading = false;\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button\n        id=\"button-tags\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n      >\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button\n        id=\"button-src\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n      >\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button\n        id=\"button-nid\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n      >\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button\n          id=\"button-ankihub\"\n          class=\"button-general\"\n          title=\"Karte in AnkiHub\"\n        >\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) {}\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button\n      id=\"button-tags\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button\n      id=\"button-src\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">Quelle: {{Quelle}}</div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button\n      id=\"button-nid\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    <i>Was</i> wird hier bei <b>③</b> gezeigt?\n\n    <br>\n    <br>\n\n    {{#Hint / Hinweis}}\n      <span style=\"color:IndianRed; font-weight: bold;\">Hinweis:</span> {{hint:Hint / Hinweis}}\n\n      <br>\n      <br>\n    {{/Hint / Hinweis}}\n    \n    {{Bild}}\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\"></div>\n\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n<script>\n  //DONT FADE BETWEEN CARDS\n  qFade = 0;\n  if (typeof anki !== 'undefined') anki.qFade = qFade;\n</script>\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\nfunction getTextWidth(text, font) {\n // re-use canvas object for better performance\n const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n const context = canvas.getContext(\"2d\");\n context.font = font;\n const metrics = context.measureText(text);\n return metrics.width;\n}\n\nfunction getCSSStyle(element, prop) {\n return window.getComputedStyle(element, null).getPropertyValue(prop);\n}\n\nfunction getCanvasFont(el = document.body) {\n const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n const fontSize = getCSSStyle(el, 'font-size') || '16px';\n const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n return `${fontWeight} ${fontSize} ${fontFamily}`;\n}\n\n/**\n* Iterates over a list of divs containing text to be indented\n*\n* @param {HTMLCollection} divs: The divs to be iterated over.\n*/\nfunction indentText(divs) {\n // setup the indentation markers\n var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n var bulletP = \"•\"\n var minus = \"– \"\n var enter = \"↳(?!( ↳|↳))\"\n var arrow = \"→\"\n\n // heuristic indentation hierarchy\n hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n // set up RegEx to analyze the provided divs\n // negative lookbehinds unfortunately do not work yet on iPad / Android\n var beginning = '(?<=<br>)(?<!cloze=\")('\n var middle = \".*?)((?:<br>)(?=(\"\n var end = \"))|(?=(<\\/indent>|<\\/div>|<br><br>)))\"\n\n const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n // iterate over divs\n for (const div of divs) {\n   // calculate indentation depths\n   var canvasFont = getCanvasFont(div)\n   var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n   var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n   var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n   var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n   var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n   var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n   var indentEnd = ';\">$1</indent>'\n\n   // do the indentation\n   divHTML = div.outerHTML\n   divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n   divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n   div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\")\n }\n}\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function(type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function(ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n  <script>\n    var tagContainer = document.getElementById(\"tags-container\")\n\n    if (tagContainer.childElementCount == 0) {\n      var tagList = tagContainer.innerHTML.trim().split(\" \");\n      var kbdList = [];\n      var newTagContent = document.createElement(\"div\");\n\n      for (var i = 0; i < tagList.length; i++) {\n        var newTag = document.createElement(\"kbd\");\n        var tag = tagList[i];\n        // numTagLevelsToShow == 0 means the whole tag should be shown\n        if (numTagLevelsToShow != 0) {\n          tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n        }\n\n        // Zankiphil / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n        if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) continue;\n        if (tag.split(\"::\")[1] == \"!NEW_CARDS\") continue;\n        if (tag.split(\"::\")[1] == \"§Projekt_Anki\") continue;\n        if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") continue;\n\n        // improve legibility of tags\n        tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n        tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\");\n        tag = tag.replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n        newTag.innerHTML = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"_\", \" \");\n        newTagContent.append(newTag)\n      }\n\n      tagContainer.innerHTML = newTagContent.innerHTML;\n      tagContainer.style.cursor = \"default\";\n    }\n\n    if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n      tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n    }\n\n    function showtags() {\n      var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n      if (tagContainerShortcut.style.display === \"none\") {\n        tagContainerShortcut.style.display = \"inline\";\n      } else {\n        tagContainerShortcut.style.display = \"none\";\n      }\n    }\n\n    var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n    ankingAddEventListener('keyup', function (e) {\n      if (isShortcut(e)) {\n        toggleHintBtn('hint-tags');\n        showtags();\n      }\n    });\n  </script>\n  <script>\n    for (const tag of document.getElementsByTagName('kbd')) {\n      tag.innerHTML = tag.innerHTML.replace(/::/g, '::<wbr>')\n    }\n  </script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (el.style.display === 'none') {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits( n ) {\n      return (n <= 9 ? \"0\" + n : n); \n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n      \n      if ( msLeft < 1000 ) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date( msLeft );\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout( updateTimer, time.getUTCMilliseconds() + 500 );\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60*minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds ); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function(key, dictionary){\n        return dictionary[key];\n      }\n    }\n    \n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n      \n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n      \n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n/**\n * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n * Full credit to the original authors, except where modified or otherwise indicated.\n */\n\n/**\n *\n * We try to respect that people use various note types\n * which may do 'weird' stuff.\n * Elements may have event listeners that can be removed if we just innerHTML stuff\n * <i> may be styled 'i { display: block }', etc.\n *\n * Another problem that complicate the design of this script is that\n * a word may not be cleanly separated by html tags.\n * e.g. \"A<i>long</i>word\"\n *\n */\n\n(function () {\n  /**\n   * @param {String} text\n   * @returns {number}\n   */\n  function getBoldLength(text) {\n    return Math.floor(text.length / 2);\n  }\n\n  // Ignore node if any of the filters return true\n  const excludeFilters = [\n    (elem) => elem.tagName === \"SCRIPT\",\n    (elem) => elem.tagName === \"STYLE\",\n    (elem) => elem.classList.contains(\"cloze\"),\n  ];\n\n  function newBoldElement(text) {\n    const elem = document.createElement(\"strong\");\n    elem.innerText = text;\n    return elem;\n  }\n\n  function indexOfWhitespace(text, startPos) {\n    const whitespaces = [\n      \" \",\n      \"\\n\",\n      \"\\t\",\n      \" \",\n      \"&nbsp;\",\n      \"‑\",\n      \"-\",\n      \"/\",\n      \"(\",\n      \")\",\n    ];\n    let nextPos = text.length;\n    for (const whitespace of whitespaces) {\n      const next = text.indexOf(whitespace, startPos);\n      if (next !== -1 && next < nextPos) {\n        nextPos = next;\n      }\n    }\n    if (nextPos === text.length) {\n      nextPos = -1;\n    }\n    return nextPos;\n  }\n\n  // Bolds a line of words\n  class BionicReaderBolder {\n    constructor(nodes) {\n      this.nodes = nodes;\n      this.startNodeIndex = 0;\n      this.startPos = 0;\n      this.replaceNodes = [];\n      while (!this.isFinished()) {\n        this.runWithinNode();\n        this.runInterNode();\n      }\n    }\n\n    static run(nodes) {\n      new BionicReaderBolder(nodes);\n    }\n\n    isFinished() {\n      return this.startNodeIndex === this.nodes.length;\n    }\n\n    replaceNode() {\n      const node = this.nodes[this.startNodeIndex];\n      const parent = node.parentNode;\n      for (let add of this.replaceNodes) {\n        parent.insertBefore(add, node);\n      }\n      parent.removeChild(node);\n      this.replaceNodes = [];\n    }\n\n    runWithinNode() {\n      const textContent = this.nodes[this.startNodeIndex].textContent;\n      let nextPos = indexOfWhitespace(textContent, this.startPos);\n      while (nextPos !== -1) {\n        const word = textContent.substring(this.startPos, nextPos);\n        const boldLength = getBoldLength(word);\n        this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n        this.replaceNodes.push(\n          document.createTextNode(\n            word.substring(boldLength, nextPos) + textContent[nextPos]\n          )\n        );\n        this.startPos = nextPos + 1;\n        nextPos = indexOfWhitespace(textContent, this.startPos);\n      }\n    }\n\n    // after this, startPos is likely to be at whitespace char\n    runInterNode() {\n      let word = \"\";\n      let endNodeIndex = this.startNodeIndex;\n      let endPos = this.startPos; // last word char pos + 1\n\n      // Find word boundary\n      while (endNodeIndex < this.nodes.length) {\n        const textContent = this.nodes[endNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, endPos);\n        if (nextPos === -1) {\n          word += textContent.substring(endPos);\n          endNodeIndex += 1;\n          endPos = 0;\n        } else {\n          word += textContent.substring(endPos, nextPos);\n          endPos = nextPos;\n          break;\n        }\n      }\n      // Calculate bold length\n      let remainingBoldLength = getBoldLength(word);\n\n      // Bold part of word\n      while (remainingBoldLength > 0) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        if (remainingBoldLength > textContent.length - this.startPos) {\n          const wordPart = textContent.substring(this.startPos);\n          remainingBoldLength -= wordPart.length;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        } else {\n          const wordPart = textContent.substring(\n            this.startPos,\n            this.startPos + remainingBoldLength\n          );\n          this.startPos += remainingBoldLength;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          remainingBoldLength -= wordPart.length;\n        }\n      }\n\n      // Add non-bolded part of words\n      while (this.startNodeIndex < endNodeIndex) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.replaceNode();\n        this.startNodeIndex += 1;\n        this.startPos = 0;\n      }\n\n      if (this.startPos < endPos) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos, endPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.startPos = endPos;\n      }\n    }\n  }\n\n  /**\n   * Builds a list of (list of nodes that makes up one non-line-broken line)\n   * @param {Node} elem\n   * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n   * @returns {void}\n   */\n  function forTextNodesInTree(elem, nodes, exclude = false) {\n    const children = elem.childNodes;\n    for (const filter of excludeFilters) {\n      if (filter(elem)) {\n        exclude = true;\n        break;\n      }\n    }\n    for (const child of children) {\n      if (child.nodeType === Node.ELEMENT_NODE) {\n        const style = window.getComputedStyle(child);\n        if (\n          child.tagName !== \"BR\" &&\n          (style === \"inline\" || style === \"inline-block\")\n        ) {\n          forTextNodesInTree(child, nodes, exclude);\n        } else {\n          if (nodes[nodes.length - 1].length > 0) {\n            nodes.push([]);\n          }\n          forTextNodesInTree(child, nodes, exclude);\n        }\n      } else if (\n        !exclude &&\n        child.nodeType === Node.TEXT_NODE &&\n        child.textContent.length > 0\n      ) {\n        nodes[nodes.length - 1].push(child);\n      }\n    }\n  }\n\n  function makeBionic() {\n    const cardContainer = document.getElementById(\"container\");\n    cardContainer.normalize();\n\n    let nodesLines = [[]];\n    forTextNodesInTree(cardContainer, nodesLines);\n    for (const nodes of nodesLines) {\n      BionicReaderBolder.run(nodes);\n    }\n\n    cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n      \"<strong></strong>\",\n      \"\"\n    );\n    cardContainer.normalize();\n  }\n\n  let start = performance.now();\n  if (bionicReading) {\n    makeBionic();\n  }\n  let end = performance.now();\n  console.log(`Initialized bionic reading: ${end - start}ms`);\n})();\n</script>\n\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\nvar userJs1 = undefined\nvar userJs2 = undefined\nvar userJs3 = undefined\nvar userJs4 = undefined\nvar userJs5 = undefined\nvar userJs6 = undefined\nvar userJs7 = undefined\nvar userJs8 = undefined\n</script>\n\n\n{{/Markierung 3}}",
      "afmt": "<!-- version 0fd8612 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Eigene Notizen & Bilder\": \"Alt + 1\",\n    \"Eigene Prüfungsfragen\": \"Alt + 2\",\n    \"Definitionen\": \"Alt + 3\",\n    \"Merksprüche\": \"Alt + 4\",\n    \"Klinik\": \"Alt + 5\",\n    \"Präparat\": \"Alt + 6\",\n    \"Memes\": \"Alt + 7\",\n    \"linkContainer\": \"Alt + L\",\n    \"Meditricks\": \"Alt + M\",\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Eigene Notizen & Bilder\": false,\n    \"Eigene Prüfungsfragen\": false,\n    \"Definitionen\": false,\n    \"Merksprüche\": false,\n    \"Klinik\": false,\n    \"Präparat\": false,\n    \"Memes\": false,\n    \"linkContainer\": true,\n    \"Meditricks\": false,\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\":false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\nvar toggleTagsShortcut = \"C\";\n\n// ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\nvar tagID = \"XXXYYYZZZ\"\n\n// WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\nvar numTagLevelsToShow = 0;\n\n// ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\nvar tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n// Enable experimental heuristic indentation feature\nvar indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n// Enable experimental DIVI medication formatting feature\nvar formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n// Enable experimental confounder formatting feature\nvar formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n// Enable bionic reading feature (based on AnKing add-on)\nvar bionicReading = false;\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button\n        id=\"button-tags\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n      >\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button\n        id=\"button-src\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n      >\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button\n        id=\"button-nid\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n      >\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button\n          id=\"button-ankihub\"\n          class=\"button-general\"\n          title=\"Karte in AnkiHub\"\n        >\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) {}\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button\n      id=\"button-tags\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button\n      id=\"button-src\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">Quelle: {{Quelle}}</div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button\n      id=\"button-nid\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    <i>Was</i> wird hier bei <b>③</b> gezeigt?\n\n    <br>\n    <br>\n\n    {{#Hint / Hinweis}}\n      <span style=\"color:IndianRed; font-weight: bold;\">Hinweis:</span> {{hint:Hint / Hinweis}}\n\n      <br>\n      <br>\n    {{/Hint / Hinweis}}\n    \n    {{Bild}}\n\n    <br>\n    <br>\n\n    <span class=\"cloze\">{{Markierung 3}}</span>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- BUTTON FIELDS -->\n    {{#Eigene Notizen & Bilder}}\n  <span id=\"hint-zusatz\" class=\"hintBtn\" data-name=\"Eigene Notizen & Bilder\" style=\"display: none;\">\n    <button id=\"button-zusatz\" class=\"button-general\" onclick=\"toggleHintBtn('hint-zusatz'); event.stopPropagation()\">\n      <img src=\"__zusatz.svg\" style=\"height: 10px;\"> Eigene Notizen & Bilder\n    </button>\n    <div id=\"zusatz\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Notizen & Bilder}}</div>\n  </span>\n{{/Eigene Notizen & Bilder}}\n\n    {{#Eigene Prüfungsfragen}}\n  <span id=\"hint-hammer\" class=\"hintBtn\" data-name=\"Eigene Prüfungsfragen\" style=\"display: none;\">\n    <button id=\"button-hammer\" class=\"button-general\" onclick=\"toggleHintBtn('hint-hammer'); event.stopPropagation()\">\n      <img src=\"__hammer.svg\" style=\"height: 10px;\"> Eigene Prüfungsfragen\n    </button>\n    <div id=\"hammer\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Prüfungsfragen}}</div>\n  </span>\n{{/Eigene Prüfungsfragen}}\n\n    {{#Definitionen}}\n  <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Definitionen\" style=\"display: none;\">\n    <button id=\"button-definition\" class=\"button-general\" onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n      <img src=\"__explanation.svg\" style=\"height: 10px;\"> Definitionen\n    </button>\n    <div id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Definitionen}}</div>\n  </span>\n{{/Definitionen}}\n\n    {{#Merksprüche}}\n  <span id=\"hint-merksprueche\" class=\"hintBtn\" data-name=\"Merksprüche\" style=\"display: none;\">\n    <button id=\"button-merksprueche\" class=\"button-general\" onclick=\"toggleHintBtn('hint-merksprueche'); event.stopPropagation()\">\n      <img src=\"__merkhilfe.svg\" style=\"height: 10px;\"> Merksprüche\n    </button>\n    <div id=\"merksprueche\" class=\"hints\" style=\"display: none;\">{{edit:Merksprüche}}</div>\n  </span>\n{{/Merksprüche}}\n\n    {{#Klinik}}\n  <span id=\"hint-klinik\" class=\"hintBtn\" data-name=\"Klinik\" style=\"display: none;\">\n    <button id=\"button-klinik\" class=\"button-general\" onclick=\"toggleHintBtn('hint-klinik'); event.stopPropagation()\">\n      <img src=\"__stethoscope.svg\" style=\"height: 10px;\"> Klinik\n    </button>\n    <div id=\"klinik\" class=\"hints\" style=\"display: none;\">{{edit:Klinik}}</div>\n  </span>\n{{/Klinik}}\n\n    {{#Präparat}}\n      <span id=\"hint-praeparat-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Präparat}}\">\n          <button id=\"button-praeparat\" class=\"button-general\">\n            <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n          </button>\n        </a>\n      </span>\n    {{/Präparat}}\n\n    {{#Virtuelle Mikroskopie}}\n      <span id=\"hint-microscope-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Virtuelle Mikroskopie}}\">\n          <button id=\"button-microscope\" class=\"button-general\">\n            <img src=\"__microscope.svg\" style=\"height: 10px;\"> Virtuelle Mikroskopie\n          </button>\n        </a>\n      </span>\n    {{/Virtuelle Mikroskopie}}\n\n    {{#Smart Zoom}}\n      <span id=\"hint-smartzoom-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Präparat}}\">\n          <button id=\"button-smartzoom\" class=\"button-general\">\n            <img src=\"__microscope.svg\" style=\"height: 10px;\"> Smart Zoom\n          </button>\n        </a>\n      </span>\n    {{/Smart Zoom}}\n\n    {{#HistoTrainer}}\n  <span id=\"hint-praeparat\" class=\"hintBtn\" data-name=\"HistoTrainer\" style=\"display: none;\">\n    <button id=\"button-praeparat\" class=\"button-general\" onclick=\"toggleHintBtn('hint-praeparat'); event.stopPropagation()\">\n      <img src=\"__microscope.svg\" style=\"height: 10px;\"> HistoTrainer\n    </button>\n    <div id=\"praeparat\" class=\"hints\" style=\"display: none;\">{{edit:HistoTrainer}}</div>\n  </span>\n{{/HistoTrainer}}\n\n    {{#Memes}}\n  <span id=\"hint-memes\" class=\"hintBtn\" data-name=\"Memes\" style=\"display: none;\">\n    <button id=\"button-memes\" class=\"button-general\" onclick=\"toggleHintBtn('hint-memes'); event.stopPropagation()\">\n      <img src=\"__sonstiges.svg\" style=\"height: 10px;\"> Memes\n    </button>\n    <div id=\"memes\" class=\"hints\" style=\"display: none;\">{{edit:Memes}}</div>\n  </span>\n{{/Memes}}\n\n    <!-- Extra field -->\n    {{#Extra}}\n      <div id=\"extra\" style=\"display: none;\">\n        <br><br>{{edit:Extra}}</div>\n    {{/Extra}}\n\n    {{#AMBOSS-Link}}\n      <span id=\"hint-amboss\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:AMBOSS-Link}}\">\n          <button id=\"button-amboss\" class=\"button-general\">\n            <img src=\"__amboss.svg\" style=\"height: 10px;\"> AMBOSS&#8203;\n          </button>\n        </a>\n      </span>\n    {{/AMBOSS-Link}}\n    \n    {{#Thieme via medici-Link}}\n      <span id=\"hint-thieme\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Thieme via medici-Link}}\">\n          <button id=\"button-thieme\" class=\"button-general\">\n            <img id=\"button-thieme-img\" src=\"__thieme-heart.svg\" style=\"height: 10px;\"> Thieme via medici\n          </button>\n        </a>\n      </span>\n    {{/Thieme via medici-Link}}\n\n    {{#Meditricks}}\n  <span id=\"hint-meditricks\" class=\"hintBtn\" data-name=\"Meditricks\" style=\"display: none;\">\n    <button id=\"button-meditricks\" class=\"button-general\" onclick=\"toggleHintBtn('hint-meditricks'); event.stopPropagation()\">\n      <img src=\"__meditricks.svg\" style=\"height: 10px;\"> Meditricks\n    </button>\n    <div id=\"meditricks\" class=\"hints\" style=\"display: none;\">{{edit:Meditricks}}</div>\n  </span>\n{{/Meditricks}}\n\n    {{#weitere Links}}\n    <span id=\"hint-linkcontainer\" class=\"hintBtn\" data-name=\"linkContainer\" style=\"display: none;\">\n      <button id=\"button-linkcontainer\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-linkcontainer'); event.stopPropagation()\">\n        <img src=\"__internet.svg\" style=\"height: 10px;\"> weitere Links\n      </button>\n      <div id=\"linkcontainer\" class=\"hints\" style=\"display: none;\"></div>\n      <span id=\"linkContainerLinks\" style=\"display: none;\">{{edit:weitere Links}}</span>\n    </span>\n  {{/weitere Links}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function(type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function(ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n  <script>\n    var tagContainer = document.getElementById(\"tags-container\")\n\n    if (tagContainer.childElementCount == 0) {\n      var tagList = tagContainer.innerHTML.trim().split(\" \");\n      var kbdList = [];\n      var newTagContent = document.createElement(\"div\");\n\n      for (var i = 0; i < tagList.length; i++) {\n        var newTag = document.createElement(\"kbd\");\n        var tag = tagList[i];\n        // numTagLevelsToShow == 0 means the whole tag should be shown\n        if (numTagLevelsToShow != 0) {\n          tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n        }\n\n        // Zankiphil / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n        if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) continue;\n        if (tag.split(\"::\")[1] == \"!NEW_CARDS\") continue;\n        if (tag.split(\"::\")[1] == \"§Projekt_Anki\") continue;\n        if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") continue;\n\n        // improve legibility of tags\n        tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n        tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\");\n        tag = tag.replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n        newTag.innerHTML = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"_\", \" \");\n        newTagContent.append(newTag)\n      }\n\n      tagContainer.innerHTML = newTagContent.innerHTML;\n      tagContainer.style.cursor = \"default\";\n    }\n\n    if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n      tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n    }\n\n    function showtags() {\n      var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n      if (tagContainerShortcut.style.display === \"none\") {\n        tagContainerShortcut.style.display = \"inline\";\n      } else {\n        tagContainerShortcut.style.display = \"none\";\n      }\n    }\n\n    var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n    ankingAddEventListener('keyup', function (e) {\n      if (isShortcut(e)) {\n        toggleHintBtn('hint-tags');\n        showtags();\n      }\n    });\n  </script>\n  <script>\n    for (const tag of document.getElementsByTagName('kbd')) {\n      tag.innerHTML = tag.innerHTML.replace(/::/g, '::<wbr>')\n    }\n  </script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (el.style.display === 'none') {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n    try {\n        for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n            href = link.href\n            text = link.innerText\n\n            const el = document.createElement('a');\n            el.setAttribute('href', link.href);\n\n            const btn = document.createElement('button');\n            btn.classList.add('button-general');\n            btn.classList.add('expanded-button');\n\n            domain = href.replace(/.+\\/\\/|(www|flexikon|de|next|com).|\\..+/g, '');\n            domainDict = {\n                \"amboss\": \"__amboss.svg\",\n                \"wikipedia\": \"__wikipedia.svg\",\n                \"doccheck\": \"__doccheck.png\",\n                \"notfallguru\": \"__notfallguru.svg\",\n            }\n            if (domain in domainDict) {\n                icon = domainDict[domain]\n            } else {\n                icon = \"__internet.svg\"\n            }\n\n            const img = document.createElement('img');\n            img.setAttribute('src', icon);\n            img.setAttribute('style', 'height: 10px;');\n\n            btn.appendChild(img);\n            btn.innerHTML = btn.innerHTML + \" \" + text;\n\n            el.appendChild(btn);\n\n            document.getElementById(\"linkcontainer\").appendChild(el)\n        }\n    }\n    catch (err) {\n        console.log(err)\n    }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\nfunction getTextWidth(text, font) {\n // re-use canvas object for better performance\n const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n const context = canvas.getContext(\"2d\");\n context.font = font;\n const metrics = context.measureText(text);\n return metrics.width;\n}\n\nfunction getCSSStyle(element, prop) {\n return window.getComputedStyle(element, null).getPropertyValue(prop);\n}\n\nfunction getCanvasFont(el = document.body) {\n const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n const fontSize = getCSSStyle(el, 'font-size') || '16px';\n const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n return `${fontWeight} ${fontSize} ${fontFamily}`;\n}\n\n/**\n* Iterates over a list of divs containing text to be indented\n*\n* @param {HTMLCollection} divs: The divs to be iterated over.\n*/\nfunction indentText(divs) {\n // setup the indentation markers\n var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n var bulletP = \"•\"\n var minus = \"– \"\n var enter = \"↳(?!( ↳|↳))\"\n var arrow = \"→\"\n\n // heuristic indentation hierarchy\n hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n // set up RegEx to analyze the provided divs\n // negative lookbehinds unfortunately do not work yet on iPad / Android\n var beginning = '(?<=<br>)(?<!cloze=\")('\n var middle = \".*?)((?:<br>)(?=(\"\n var end = \"))|(?=(<\\/indent>|<\\/div>|<br><br>)))\"\n\n const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n // iterate over divs\n for (const div of divs) {\n   // calculate indentation depths\n   var canvasFont = getCanvasFont(div)\n   var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n   var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n   var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n   var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n   var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n   var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n   var indentEnd = ';\">$1</indent>'\n\n   // do the indentation\n   divHTML = div.outerHTML\n   divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n   divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n   div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\")\n }\n}\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits( n ) {\n      return (n <= 9 ? \"0\" + n : n); \n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n      \n      if ( msLeft < 1000 ) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date( msLeft );\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout( updateTimer, time.getUTCMilliseconds() + 500 );\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60*minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds ); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function(key, dictionary){\n        return dictionary[key];\n      }\n    }\n    \n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n      \n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n      \n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n/**\n * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n * Full credit to the original authors, except where modified or otherwise indicated.\n */\n\n/**\n *\n * We try to respect that people use various note types\n * which may do 'weird' stuff.\n * Elements may have event listeners that can be removed if we just innerHTML stuff\n * <i> may be styled 'i { display: block }', etc.\n *\n * Another problem that complicate the design of this script is that\n * a word may not be cleanly separated by html tags.\n * e.g. \"A<i>long</i>word\"\n *\n */\n\n(function () {\n  /**\n   * @param {String} text\n   * @returns {number}\n   */\n  function getBoldLength(text) {\n    return Math.floor(text.length / 2);\n  }\n\n  // Ignore node if any of the filters return true\n  const excludeFilters = [\n    (elem) => elem.tagName === \"SCRIPT\",\n    (elem) => elem.tagName === \"STYLE\",\n    (elem) => elem.classList.contains(\"cloze\"),\n  ];\n\n  function newBoldElement(text) {\n    const elem = document.createElement(\"strong\");\n    elem.innerText = text;\n    return elem;\n  }\n\n  function indexOfWhitespace(text, startPos) {\n    const whitespaces = [\n      \" \",\n      \"\\n\",\n      \"\\t\",\n      \" \",\n      \"&nbsp;\",\n      \"‑\",\n      \"-\",\n      \"/\",\n      \"(\",\n      \")\",\n    ];\n    let nextPos = text.length;\n    for (const whitespace of whitespaces) {\n      const next = text.indexOf(whitespace, startPos);\n      if (next !== -1 && next < nextPos) {\n        nextPos = next;\n      }\n    }\n    if (nextPos === text.length) {\n      nextPos = -1;\n    }\n    return nextPos;\n  }\n\n  // Bolds a line of words\n  class BionicReaderBolder {\n    constructor(nodes) {\n      this.nodes = nodes;\n      this.startNodeIndex = 0;\n      this.startPos = 0;\n      this.replaceNodes = [];\n      while (!this.isFinished()) {\n        this.runWithinNode();\n        this.runInterNode();\n      }\n    }\n\n    static run(nodes) {\n      new BionicReaderBolder(nodes);\n    }\n\n    isFinished() {\n      return this.startNodeIndex === this.nodes.length;\n    }\n\n    replaceNode() {\n      const node = this.nodes[this.startNodeIndex];\n      const parent = node.parentNode;\n      for (let add of this.replaceNodes) {\n        parent.insertBefore(add, node);\n      }\n      parent.removeChild(node);\n      this.replaceNodes = [];\n    }\n\n    runWithinNode() {\n      const textContent = this.nodes[this.startNodeIndex].textContent;\n      let nextPos = indexOfWhitespace(textContent, this.startPos);\n      while (nextPos !== -1) {\n        const word = textContent.substring(this.startPos, nextPos);\n        const boldLength = getBoldLength(word);\n        this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n        this.replaceNodes.push(\n          document.createTextNode(\n            word.substring(boldLength, nextPos) + textContent[nextPos]\n          )\n        );\n        this.startPos = nextPos + 1;\n        nextPos = indexOfWhitespace(textContent, this.startPos);\n      }\n    }\n\n    // after this, startPos is likely to be at whitespace char\n    runInterNode() {\n      let word = \"\";\n      let endNodeIndex = this.startNodeIndex;\n      let endPos = this.startPos; // last word char pos + 1\n\n      // Find word boundary\n      while (endNodeIndex < this.nodes.length) {\n        const textContent = this.nodes[endNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, endPos);\n        if (nextPos === -1) {\n          word += textContent.substring(endPos);\n          endNodeIndex += 1;\n          endPos = 0;\n        } else {\n          word += textContent.substring(endPos, nextPos);\n          endPos = nextPos;\n          break;\n        }\n      }\n      // Calculate bold length\n      let remainingBoldLength = getBoldLength(word);\n\n      // Bold part of word\n      while (remainingBoldLength > 0) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        if (remainingBoldLength > textContent.length - this.startPos) {\n          const wordPart = textContent.substring(this.startPos);\n          remainingBoldLength -= wordPart.length;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        } else {\n          const wordPart = textContent.substring(\n            this.startPos,\n            this.startPos + remainingBoldLength\n          );\n          this.startPos += remainingBoldLength;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          remainingBoldLength -= wordPart.length;\n        }\n      }\n\n      // Add non-bolded part of words\n      while (this.startNodeIndex < endNodeIndex) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.replaceNode();\n        this.startNodeIndex += 1;\n        this.startPos = 0;\n      }\n\n      if (this.startPos < endPos) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos, endPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.startPos = endPos;\n      }\n    }\n  }\n\n  /**\n   * Builds a list of (list of nodes that makes up one non-line-broken line)\n   * @param {Node} elem\n   * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n   * @returns {void}\n   */\n  function forTextNodesInTree(elem, nodes, exclude = false) {\n    const children = elem.childNodes;\n    for (const filter of excludeFilters) {\n      if (filter(elem)) {\n        exclude = true;\n        break;\n      }\n    }\n    for (const child of children) {\n      if (child.nodeType === Node.ELEMENT_NODE) {\n        const style = window.getComputedStyle(child);\n        if (\n          child.tagName !== \"BR\" &&\n          (style === \"inline\" || style === \"inline-block\")\n        ) {\n          forTextNodesInTree(child, nodes, exclude);\n        } else {\n          if (nodes[nodes.length - 1].length > 0) {\n            nodes.push([]);\n          }\n          forTextNodesInTree(child, nodes, exclude);\n        }\n      } else if (\n        !exclude &&\n        child.nodeType === Node.TEXT_NODE &&\n        child.textContent.length > 0\n      ) {\n        nodes[nodes.length - 1].push(child);\n      }\n    }\n  }\n\n  function makeBionic() {\n    const cardContainer = document.getElementById(\"container\");\n    cardContainer.normalize();\n\n    let nodesLines = [[]];\n    forTextNodesInTree(cardContainer, nodesLines);\n    for (const nodes of nodesLines) {\n      BionicReaderBolder.run(nodes);\n    }\n\n    cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n      \"<strong></strong>\",\n      \"\"\n    );\n    cardContainer.normalize();\n  }\n\n  let start = performance.now();\n  if (bionicReading) {\n    makeBionic();\n  }\n  let end = performance.now();\n  console.log(`Initialized bionic reading: ${end - start}ms`);\n})();\n</script>\n\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\nvar userJs1 = undefined\nvar userJs2 = undefined\nvar userJs3 = undefined\nvar userJs4 = undefined\nvar userJs5 = undefined\nvar userJs6 = undefined\nvar userJs7 = undefined\nvar userJs8 = undefined\n</script>\n",
      "bqfmt": "{{Titel}}",
      "bafmt": "{{Markierung 3}}",
      "did": null,
      "bfont": "Helvetica",
      "bsize": 12
    },
    {
      "name": "Markierung 4",
      "ord": 3,
      "qfmt": "<!-- version 0fd8612 -->\n{{#Markierung 4}}\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TIMER CONFIG  ##############\n// Timer config (timer length, timer finished message)\nvar minutes =  0\nvar seconds = 15\nvar timeOverMsg = \"<span style='color:#CC5B5B'>!!!</span>\"\n\n  // ##############  TAG SHORTCUT  ##############\nvar toggleTagsShortcut = \"C\";\n\n// ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\nvar tagID = \"XXXYYYZZZ\"\n\n// WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\nvar numTagLevelsToShow = 0;\n\n// ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\nvar tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n// Enable experimental heuristic indentation feature\nvar indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n// Enable experimental DIVI medication formatting feature\nvar formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n// Enable experimental confounder formatting feature\nvar formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n// Enable bionic reading feature (based on AnKing add-on)\nvar bionicReading = false;\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button\n        id=\"button-tags\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n      >\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button\n        id=\"button-src\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n      >\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button\n        id=\"button-nid\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n      >\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button\n          id=\"button-ankihub\"\n          class=\"button-general\"\n          title=\"Karte in AnkiHub\"\n        >\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) {}\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button\n      id=\"button-tags\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button\n      id=\"button-src\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">Quelle: {{Quelle}}</div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button\n      id=\"button-nid\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    <i>Was</i> wird hier bei <b>④</b> gezeigt?\n\n    <br>\n    <br>\n\n    {{#Hint / Hinweis}}\n      <span style=\"color:IndianRed; font-weight: bold;\">Hinweis:</span> {{hint:Hint / Hinweis}}\n\n      <br>\n      <br>\n    {{/Hint / Hinweis}}\n    \n    {{Bild}}\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\"></div>\n\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n<script>\n  //DONT FADE BETWEEN CARDS\n  qFade = 0;\n  if (typeof anki !== 'undefined') anki.qFade = qFade;\n</script>\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\nfunction getTextWidth(text, font) {\n // re-use canvas object for better performance\n const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n const context = canvas.getContext(\"2d\");\n context.font = font;\n const metrics = context.measureText(text);\n return metrics.width;\n}\n\nfunction getCSSStyle(element, prop) {\n return window.getComputedStyle(element, null).getPropertyValue(prop);\n}\n\nfunction getCanvasFont(el = document.body) {\n const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n const fontSize = getCSSStyle(el, 'font-size') || '16px';\n const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n return `${fontWeight} ${fontSize} ${fontFamily}`;\n}\n\n/**\n* Iterates over a list of divs containing text to be indented\n*\n* @param {HTMLCollection} divs: The divs to be iterated over.\n*/\nfunction indentText(divs) {\n // setup the indentation markers\n var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n var bulletP = \"•\"\n var minus = \"– \"\n var enter = \"↳(?!( ↳|↳))\"\n var arrow = \"→\"\n\n // heuristic indentation hierarchy\n hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n // set up RegEx to analyze the provided divs\n // negative lookbehinds unfortunately do not work yet on iPad / Android\n var beginning = '(?<=<br>)(?<!cloze=\")('\n var middle = \".*?)((?:<br>)(?=(\"\n var end = \"))|(?=(<\\/indent>|<\\/div>|<br><br>)))\"\n\n const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n // iterate over divs\n for (const div of divs) {\n   // calculate indentation depths\n   var canvasFont = getCanvasFont(div)\n   var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n   var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n   var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n   var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n   var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n   var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n   var indentEnd = ';\">$1</indent>'\n\n   // do the indentation\n   divHTML = div.outerHTML\n   divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n   divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n   div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\")\n }\n}\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function(type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function(ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n  <script>\n    var tagContainer = document.getElementById(\"tags-container\")\n\n    if (tagContainer.childElementCount == 0) {\n      var tagList = tagContainer.innerHTML.trim().split(\" \");\n      var kbdList = [];\n      var newTagContent = document.createElement(\"div\");\n\n      for (var i = 0; i < tagList.length; i++) {\n        var newTag = document.createElement(\"kbd\");\n        var tag = tagList[i];\n        // numTagLevelsToShow == 0 means the whole tag should be shown\n        if (numTagLevelsToShow != 0) {\n          tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n        }\n\n        // Zankiphil / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n        if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) continue;\n        if (tag.split(\"::\")[1] == \"!NEW_CARDS\") continue;\n        if (tag.split(\"::\")[1] == \"§Projekt_Anki\") continue;\n        if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") continue;\n\n        // improve legibility of tags\n        tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n        tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\");\n        tag = tag.replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n        newTag.innerHTML = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"_\", \" \");\n        newTagContent.append(newTag)\n      }\n\n      tagContainer.innerHTML = newTagContent.innerHTML;\n      tagContainer.style.cursor = \"default\";\n    }\n\n    if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n      tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n    }\n\n    function showtags() {\n      var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n      if (tagContainerShortcut.style.display === \"none\") {\n        tagContainerShortcut.style.display = \"inline\";\n      } else {\n        tagContainerShortcut.style.display = \"none\";\n      }\n    }\n\n    var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n    ankingAddEventListener('keyup', function (e) {\n      if (isShortcut(e)) {\n        toggleHintBtn('hint-tags');\n        showtags();\n      }\n    });\n  </script>\n  <script>\n    for (const tag of document.getElementsByTagName('kbd')) {\n      tag.innerHTML = tag.innerHTML.replace(/::/g, '::<wbr>')\n    }\n  </script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (el.style.display === 'none') {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits( n ) {\n      return (n <= 9 ? \"0\" + n : n); \n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n      \n      if ( msLeft < 1000 ) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date( msLeft );\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout( updateTimer, time.getUTCMilliseconds() + 500 );\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60*minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds ); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function(key, dictionary){\n        return dictionary[key];\n      }\n    }\n    \n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n      \n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n      \n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n/**\n * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n * Full credit to the original authors, except where modified or otherwise indicated.\n */\n\n/**\n *\n * We try to respect that people use various note types\n * which may do 'weird' stuff.\n * Elements may have event listeners that can be removed if we just innerHTML stuff\n * <i> may be styled 'i { display: block }', etc.\n *\n * Another problem that complicate the design of this script is that\n * a word may not be cleanly separated by html tags.\n * e.g. \"A<i>long</i>word\"\n *\n */\n\n(function () {\n  /**\n   * @param {String} text\n   * @returns {number}\n   */\n  function getBoldLength(text) {\n    return Math.floor(text.length / 2);\n  }\n\n  // Ignore node if any of the filters return true\n  const excludeFilters = [\n    (elem) => elem.tagName === \"SCRIPT\",\n    (elem) => elem.tagName === \"STYLE\",\n    (elem) => elem.classList.contains(\"cloze\"),\n  ];\n\n  function newBoldElement(text) {\n    const elem = document.createElement(\"strong\");\n    elem.innerText = text;\n    return elem;\n  }\n\n  function indexOfWhitespace(text, startPos) {\n    const whitespaces = [\n      \" \",\n      \"\\n\",\n      \"\\t\",\n      \" \",\n      \"&nbsp;\",\n      \"‑\",\n      \"-\",\n      \"/\",\n      \"(\",\n      \")\",\n    ];\n    let nextPos = text.length;\n    for (const whitespace of whitespaces) {\n      const next = text.indexOf(whitespace, startPos);\n      if (next !== -1 && next < nextPos) {\n        nextPos = next;\n      }\n    }\n    if (nextPos === text.length) {\n      nextPos = -1;\n    }\n    return nextPos;\n  }\n\n  // Bolds a line of words\n  class BionicReaderBolder {\n    constructor(nodes) {\n      this.nodes = nodes;\n      this.startNodeIndex = 0;\n      this.startPos = 0;\n      this.replaceNodes = [];\n      while (!this.isFinished()) {\n        this.runWithinNode();\n        this.runInterNode();\n      }\n    }\n\n    static run(nodes) {\n      new BionicReaderBolder(nodes);\n    }\n\n    isFinished() {\n      return this.startNodeIndex === this.nodes.length;\n    }\n\n    replaceNode() {\n      const node = this.nodes[this.startNodeIndex];\n      const parent = node.parentNode;\n      for (let add of this.replaceNodes) {\n        parent.insertBefore(add, node);\n      }\n      parent.removeChild(node);\n      this.replaceNodes = [];\n    }\n\n    runWithinNode() {\n      const textContent = this.nodes[this.startNodeIndex].textContent;\n      let nextPos = indexOfWhitespace(textContent, this.startPos);\n      while (nextPos !== -1) {\n        const word = textContent.substring(this.startPos, nextPos);\n        const boldLength = getBoldLength(word);\n        this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n        this.replaceNodes.push(\n          document.createTextNode(\n            word.substring(boldLength, nextPos) + textContent[nextPos]\n          )\n        );\n        this.startPos = nextPos + 1;\n        nextPos = indexOfWhitespace(textContent, this.startPos);\n      }\n    }\n\n    // after this, startPos is likely to be at whitespace char\n    runInterNode() {\n      let word = \"\";\n      let endNodeIndex = this.startNodeIndex;\n      let endPos = this.startPos; // last word char pos + 1\n\n      // Find word boundary\n      while (endNodeIndex < this.nodes.length) {\n        const textContent = this.nodes[endNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, endPos);\n        if (nextPos === -1) {\n          word += textContent.substring(endPos);\n          endNodeIndex += 1;\n          endPos = 0;\n        } else {\n          word += textContent.substring(endPos, nextPos);\n          endPos = nextPos;\n          break;\n        }\n      }\n      // Calculate bold length\n      let remainingBoldLength = getBoldLength(word);\n\n      // Bold part of word\n      while (remainingBoldLength > 0) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        if (remainingBoldLength > textContent.length - this.startPos) {\n          const wordPart = textContent.substring(this.startPos);\n          remainingBoldLength -= wordPart.length;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        } else {\n          const wordPart = textContent.substring(\n            this.startPos,\n            this.startPos + remainingBoldLength\n          );\n          this.startPos += remainingBoldLength;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          remainingBoldLength -= wordPart.length;\n        }\n      }\n\n      // Add non-bolded part of words\n      while (this.startNodeIndex < endNodeIndex) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.replaceNode();\n        this.startNodeIndex += 1;\n        this.startPos = 0;\n      }\n\n      if (this.startPos < endPos) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos, endPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.startPos = endPos;\n      }\n    }\n  }\n\n  /**\n   * Builds a list of (list of nodes that makes up one non-line-broken line)\n   * @param {Node} elem\n   * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n   * @returns {void}\n   */\n  function forTextNodesInTree(elem, nodes, exclude = false) {\n    const children = elem.childNodes;\n    for (const filter of excludeFilters) {\n      if (filter(elem)) {\n        exclude = true;\n        break;\n      }\n    }\n    for (const child of children) {\n      if (child.nodeType === Node.ELEMENT_NODE) {\n        const style = window.getComputedStyle(child);\n        if (\n          child.tagName !== \"BR\" &&\n          (style === \"inline\" || style === \"inline-block\")\n        ) {\n          forTextNodesInTree(child, nodes, exclude);\n        } else {\n          if (nodes[nodes.length - 1].length > 0) {\n            nodes.push([]);\n          }\n          forTextNodesInTree(child, nodes, exclude);\n        }\n      } else if (\n        !exclude &&\n        child.nodeType === Node.TEXT_NODE &&\n        child.textContent.length > 0\n      ) {\n        nodes[nodes.length - 1].push(child);\n      }\n    }\n  }\n\n  function makeBionic() {\n    const cardContainer = document.getElementById(\"container\");\n    cardContainer.normalize();\n\n    let nodesLines = [[]];\n    forTextNodesInTree(cardContainer, nodesLines);\n    for (const nodes of nodesLines) {\n      BionicReaderBolder.run(nodes);\n    }\n\n    cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n      \"<strong></strong>\",\n      \"\"\n    );\n    cardContainer.normalize();\n  }\n\n  let start = performance.now();\n  if (bionicReading) {\n    makeBionic();\n  }\n  let end = performance.now();\n  console.log(`Initialized bionic reading: ${end - start}ms`);\n})();\n</script>\n\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\nvar userJs1 = undefined\nvar userJs2 = undefined\nvar userJs3 = undefined\nvar userJs4 = undefined\nvar userJs5 = undefined\nvar userJs6 = undefined\nvar userJs7 = undefined\nvar userJs8 = undefined\n</script>\n\n\n{{/Markierung 4}}",
      "afmt": "<!-- version 0fd8612 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Eigene Notizen & Bilder\": \"Alt + 1\",\n    \"Eigene Prüfungsfragen\": \"Alt + 2\",\n    \"Definitionen\": \"Alt + 3\",\n    \"Merksprüche\": \"Alt + 4\",\n    \"Klinik\": \"Alt + 5\",\n    \"Präparat\": \"Alt + 6\",\n    \"Memes\": \"Alt + 7\",\n    \"linkContainer\": \"Alt + L\",\n    \"Meditricks\": \"Alt + M\",\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Eigene Notizen & Bilder\": false,\n    \"Eigene Prüfungsfragen\": false,\n    \"Definitionen\": false,\n    \"Merksprüche\": false,\n    \"Klinik\": false,\n    \"Präparat\": false,\n    \"Memes\": false,\n    \"linkContainer\": true,\n    \"Meditricks\": false,\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\":false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\nvar toggleTagsShortcut = \"C\";\n\n// ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\nvar tagID = \"XXXYYYZZZ\"\n\n// WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\nvar numTagLevelsToShow = 0;\n\n// ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\nvar tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n// Enable experimental heuristic indentation feature\nvar indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n// Enable experimental DIVI medication formatting feature\nvar formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n// Enable experimental confounder formatting feature\nvar formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n// Enable bionic reading feature (based on AnKing add-on)\nvar bionicReading = false;\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button\n        id=\"button-tags\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n      >\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button\n        id=\"button-src\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n      >\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button\n        id=\"button-nid\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n      >\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button\n          id=\"button-ankihub\"\n          class=\"button-general\"\n          title=\"Karte in AnkiHub\"\n        >\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) {}\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button\n      id=\"button-tags\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button\n      id=\"button-src\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">Quelle: {{Quelle}}</div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button\n      id=\"button-nid\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    <i>Was</i> wird hier bei <b>④</b> gezeigt?\n\n    <br>\n    <br>\n\n    {{#Hint / Hinweis}}\n      <span style=\"color:IndianRed; font-weight: bold;\">Hinweis:</span> {{hint:Hint / Hinweis}}\n\n      <br>\n      <br>\n    {{/Hint / Hinweis}}\n    \n    {{Bild}}\n\n    <br>\n    <br>\n\n    <span class=\"cloze\">{{Markierung 4}}</span>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- BUTTON FIELDS -->\n    {{#Eigene Notizen & Bilder}}\n  <span id=\"hint-zusatz\" class=\"hintBtn\" data-name=\"Eigene Notizen & Bilder\" style=\"display: none;\">\n    <button id=\"button-zusatz\" class=\"button-general\" onclick=\"toggleHintBtn('hint-zusatz'); event.stopPropagation()\">\n      <img src=\"__zusatz.svg\" style=\"height: 10px;\"> Eigene Notizen & Bilder\n    </button>\n    <div id=\"zusatz\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Notizen & Bilder}}</div>\n  </span>\n{{/Eigene Notizen & Bilder}}\n\n    {{#Eigene Prüfungsfragen}}\n  <span id=\"hint-hammer\" class=\"hintBtn\" data-name=\"Eigene Prüfungsfragen\" style=\"display: none;\">\n    <button id=\"button-hammer\" class=\"button-general\" onclick=\"toggleHintBtn('hint-hammer'); event.stopPropagation()\">\n      <img src=\"__hammer.svg\" style=\"height: 10px;\"> Eigene Prüfungsfragen\n    </button>\n    <div id=\"hammer\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Prüfungsfragen}}</div>\n  </span>\n{{/Eigene Prüfungsfragen}}\n\n    {{#Definitionen}}\n  <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Definitionen\" style=\"display: none;\">\n    <button id=\"button-definition\" class=\"button-general\" onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n      <img src=\"__explanation.svg\" style=\"height: 10px;\"> Definitionen\n    </button>\n    <div id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Definitionen}}</div>\n  </span>\n{{/Definitionen}}\n\n    {{#Merksprüche}}\n  <span id=\"hint-merksprueche\" class=\"hintBtn\" data-name=\"Merksprüche\" style=\"display: none;\">\n    <button id=\"button-merksprueche\" class=\"button-general\" onclick=\"toggleHintBtn('hint-merksprueche'); event.stopPropagation()\">\n      <img src=\"__merkhilfe.svg\" style=\"height: 10px;\"> Merksprüche\n    </button>\n    <div id=\"merksprueche\" class=\"hints\" style=\"display: none;\">{{edit:Merksprüche}}</div>\n  </span>\n{{/Merksprüche}}\n\n    {{#Klinik}}\n  <span id=\"hint-klinik\" class=\"hintBtn\" data-name=\"Klinik\" style=\"display: none;\">\n    <button id=\"button-klinik\" class=\"button-general\" onclick=\"toggleHintBtn('hint-klinik'); event.stopPropagation()\">\n      <img src=\"__stethoscope.svg\" style=\"height: 10px;\"> Klinik\n    </button>\n    <div id=\"klinik\" class=\"hints\" style=\"display: none;\">{{edit:Klinik}}</div>\n  </span>\n{{/Klinik}}\n\n    {{#Präparat}}\n      <span id=\"hint-praeparat-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Präparat}}\">\n          <button id=\"button-praeparat\" class=\"button-general\">\n            <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n          </button>\n        </a>\n      </span>\n    {{/Präparat}}\n\n    {{#Virtuelle Mikroskopie}}\n      <span id=\"hint-microscope-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Virtuelle Mikroskopie}}\">\n          <button id=\"button-microscope\" class=\"button-general\">\n            <img src=\"__microscope.svg\" style=\"height: 10px;\"> Virtuelle Mikroskopie\n          </button>\n        </a>\n      </span>\n    {{/Virtuelle Mikroskopie}}\n\n    {{#Smart Zoom}}\n      <span id=\"hint-smartzoom-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Präparat}}\">\n          <button id=\"button-smartzoom\" class=\"button-general\">\n            <img src=\"__microscope.svg\" style=\"height: 10px;\"> Smart Zoom\n          </button>\n        </a>\n      </span>\n    {{/Smart Zoom}}\n\n    {{#HistoTrainer}}\n  <span id=\"hint-praeparat\" class=\"hintBtn\" data-name=\"HistoTrainer\" style=\"display: none;\">\n    <button id=\"button-praeparat\" class=\"button-general\" onclick=\"toggleHintBtn('hint-praeparat'); event.stopPropagation()\">\n      <img src=\"__microscope.svg\" style=\"height: 10px;\"> HistoTrainer\n    </button>\n    <div id=\"praeparat\" class=\"hints\" style=\"display: none;\">{{edit:HistoTrainer}}</div>\n  </span>\n{{/HistoTrainer}}\n\n    {{#Memes}}\n  <span id=\"hint-memes\" class=\"hintBtn\" data-name=\"Memes\" style=\"display: none;\">\n    <button id=\"button-memes\" class=\"button-general\" onclick=\"toggleHintBtn('hint-memes'); event.stopPropagation()\">\n      <img src=\"__sonstiges.svg\" style=\"height: 10px;\"> Memes\n    </button>\n    <div id=\"memes\" class=\"hints\" style=\"display: none;\">{{edit:Memes}}</div>\n  </span>\n{{/Memes}}\n\n    <!-- Extra field -->\n    {{#Extra}}\n      <div id=\"extra\" style=\"display: none;\">\n        <br><br>{{edit:Extra}}</div>\n    {{/Extra}}\n\n    {{#AMBOSS-Link}}\n      <span id=\"hint-amboss\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:AMBOSS-Link}}\">\n          <button id=\"button-amboss\" class=\"button-general\">\n            <img src=\"__amboss.svg\" style=\"height: 10px;\"> AMBOSS&#8203;\n          </button>\n        </a>\n      </span>\n    {{/AMBOSS-Link}}\n    \n    {{#Thieme via medici-Link}}\n      <span id=\"hint-thieme\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Thieme via medici-Link}}\">\n          <button id=\"button-thieme\" class=\"button-general\">\n            <img id=\"button-thieme-img\" src=\"__thieme-heart.svg\" style=\"height: 10px;\"> Thieme via medici\n          </button>\n        </a>\n      </span>\n    {{/Thieme via medici-Link}}\n\n    {{#Meditricks}}\n  <span id=\"hint-meditricks\" class=\"hintBtn\" data-name=\"Meditricks\" style=\"display: none;\">\n    <button id=\"button-meditricks\" class=\"button-general\" onclick=\"toggleHintBtn('hint-meditricks'); event.stopPropagation()\">\n      <img src=\"__meditricks.svg\" style=\"height: 10px;\"> Meditricks\n    </button>\n    <div id=\"meditricks\" class=\"hints\" style=\"display: none;\">{{edit:Meditricks}}</div>\n  </span>\n{{/Meditricks}}\n\n    {{#weitere Links}}\n    <span id=\"hint-linkcontainer\" class=\"hintBtn\" data-name=\"linkContainer\" style=\"display: none;\">\n      <button id=\"button-linkcontainer\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-linkcontainer'); event.stopPropagation()\">\n        <img src=\"__internet.svg\" style=\"height: 10px;\"> weitere Links\n      </button>\n      <div id=\"linkcontainer\" class=\"hints\" style=\"display: none;\"></div>\n      <span id=\"linkContainerLinks\" style=\"display: none;\">{{edit:weitere Links}}</span>\n    </span>\n  {{/weitere Links}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function(type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function(ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n  <script>\n    var tagContainer = document.getElementById(\"tags-container\")\n\n    if (tagContainer.childElementCount == 0) {\n      var tagList = tagContainer.innerHTML.trim().split(\" \");\n      var kbdList = [];\n      var newTagContent = document.createElement(\"div\");\n\n      for (var i = 0; i < tagList.length; i++) {\n        var newTag = document.createElement(\"kbd\");\n        var tag = tagList[i];\n        // numTagLevelsToShow == 0 means the whole tag should be shown\n        if (numTagLevelsToShow != 0) {\n          tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n        }\n\n        // Zankiphil / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n        if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) continue;\n        if (tag.split(\"::\")[1] == \"!NEW_CARDS\") continue;\n        if (tag.split(\"::\")[1] == \"§Projekt_Anki\") continue;\n        if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") continue;\n\n        // improve legibility of tags\n        tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n        tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\");\n        tag = tag.replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n        newTag.innerHTML = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"_\", \" \");\n        newTagContent.append(newTag)\n      }\n\n      tagContainer.innerHTML = newTagContent.innerHTML;\n      tagContainer.style.cursor = \"default\";\n    }\n\n    if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n      tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n    }\n\n    function showtags() {\n      var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n      if (tagContainerShortcut.style.display === \"none\") {\n        tagContainerShortcut.style.display = \"inline\";\n      } else {\n        tagContainerShortcut.style.display = \"none\";\n      }\n    }\n\n    var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n    ankingAddEventListener('keyup', function (e) {\n      if (isShortcut(e)) {\n        toggleHintBtn('hint-tags');\n        showtags();\n      }\n    });\n  </script>\n  <script>\n    for (const tag of document.getElementsByTagName('kbd')) {\n      tag.innerHTML = tag.innerHTML.replace(/::/g, '::<wbr>')\n    }\n  </script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (el.style.display === 'none') {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n    try {\n        for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n            href = link.href\n            text = link.innerText\n\n            const el = document.createElement('a');\n            el.setAttribute('href', link.href);\n\n            const btn = document.createElement('button');\n            btn.classList.add('button-general');\n            btn.classList.add('expanded-button');\n\n            domain = href.replace(/.+\\/\\/|(www|flexikon|de|next|com).|\\..+/g, '');\n            domainDict = {\n                \"amboss\": \"__amboss.svg\",\n                \"wikipedia\": \"__wikipedia.svg\",\n                \"doccheck\": \"__doccheck.png\",\n                \"notfallguru\": \"__notfallguru.svg\",\n            }\n            if (domain in domainDict) {\n                icon = domainDict[domain]\n            } else {\n                icon = \"__internet.svg\"\n            }\n\n            const img = document.createElement('img');\n            img.setAttribute('src', icon);\n            img.setAttribute('style', 'height: 10px;');\n\n            btn.appendChild(img);\n            btn.innerHTML = btn.innerHTML + \" \" + text;\n\n            el.appendChild(btn);\n\n            document.getElementById(\"linkcontainer\").appendChild(el)\n        }\n    }\n    catch (err) {\n        console.log(err)\n    }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\nfunction getTextWidth(text, font) {\n // re-use canvas object for better performance\n const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n const context = canvas.getContext(\"2d\");\n context.font = font;\n const metrics = context.measureText(text);\n return metrics.width;\n}\n\nfunction getCSSStyle(element, prop) {\n return window.getComputedStyle(element, null).getPropertyValue(prop);\n}\n\nfunction getCanvasFont(el = document.body) {\n const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n const fontSize = getCSSStyle(el, 'font-size') || '16px';\n const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n return `${fontWeight} ${fontSize} ${fontFamily}`;\n}\n\n/**\n* Iterates over a list of divs containing text to be indented\n*\n* @param {HTMLCollection} divs: The divs to be iterated over.\n*/\nfunction indentText(divs) {\n // setup the indentation markers\n var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n var bulletP = \"•\"\n var minus = \"– \"\n var enter = \"↳(?!( ↳|↳))\"\n var arrow = \"→\"\n\n // heuristic indentation hierarchy\n hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n // set up RegEx to analyze the provided divs\n // negative lookbehinds unfortunately do not work yet on iPad / Android\n var beginning = '(?<=<br>)(?<!cloze=\")('\n var middle = \".*?)((?:<br>)(?=(\"\n var end = \"))|(?=(<\\/indent>|<\\/div>|<br><br>)))\"\n\n const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n // iterate over divs\n for (const div of divs) {\n   // calculate indentation depths\n   var canvasFont = getCanvasFont(div)\n   var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n   var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n   var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n   var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n   var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n   var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n   var indentEnd = ';\">$1</indent>'\n\n   // do the indentation\n   divHTML = div.outerHTML\n   divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n   divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n   div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\")\n }\n}\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits( n ) {\n      return (n <= 9 ? \"0\" + n : n); \n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n      \n      if ( msLeft < 1000 ) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date( msLeft );\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout( updateTimer, time.getUTCMilliseconds() + 500 );\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60*minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds ); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function(key, dictionary){\n        return dictionary[key];\n      }\n    }\n    \n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n      \n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n      \n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n/**\n * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n * Full credit to the original authors, except where modified or otherwise indicated.\n */\n\n/**\n *\n * We try to respect that people use various note types\n * which may do 'weird' stuff.\n * Elements may have event listeners that can be removed if we just innerHTML stuff\n * <i> may be styled 'i { display: block }', etc.\n *\n * Another problem that complicate the design of this script is that\n * a word may not be cleanly separated by html tags.\n * e.g. \"A<i>long</i>word\"\n *\n */\n\n(function () {\n  /**\n   * @param {String} text\n   * @returns {number}\n   */\n  function getBoldLength(text) {\n    return Math.floor(text.length / 2);\n  }\n\n  // Ignore node if any of the filters return true\n  const excludeFilters = [\n    (elem) => elem.tagName === \"SCRIPT\",\n    (elem) => elem.tagName === \"STYLE\",\n    (elem) => elem.classList.contains(\"cloze\"),\n  ];\n\n  function newBoldElement(text) {\n    const elem = document.createElement(\"strong\");\n    elem.innerText = text;\n    return elem;\n  }\n\n  function indexOfWhitespace(text, startPos) {\n    const whitespaces = [\n      \" \",\n      \"\\n\",\n      \"\\t\",\n      \" \",\n      \"&nbsp;\",\n      \"‑\",\n      \"-\",\n      \"/\",\n      \"(\",\n      \")\",\n    ];\n    let nextPos = text.length;\n    for (const whitespace of whitespaces) {\n      const next = text.indexOf(whitespace, startPos);\n      if (next !== -1 && next < nextPos) {\n        nextPos = next;\n      }\n    }\n    if (nextPos === text.length) {\n      nextPos = -1;\n    }\n    return nextPos;\n  }\n\n  // Bolds a line of words\n  class BionicReaderBolder {\n    constructor(nodes) {\n      this.nodes = nodes;\n      this.startNodeIndex = 0;\n      this.startPos = 0;\n      this.replaceNodes = [];\n      while (!this.isFinished()) {\n        this.runWithinNode();\n        this.runInterNode();\n      }\n    }\n\n    static run(nodes) {\n      new BionicReaderBolder(nodes);\n    }\n\n    isFinished() {\n      return this.startNodeIndex === this.nodes.length;\n    }\n\n    replaceNode() {\n      const node = this.nodes[this.startNodeIndex];\n      const parent = node.parentNode;\n      for (let add of this.replaceNodes) {\n        parent.insertBefore(add, node);\n      }\n      parent.removeChild(node);\n      this.replaceNodes = [];\n    }\n\n    runWithinNode() {\n      const textContent = this.nodes[this.startNodeIndex].textContent;\n      let nextPos = indexOfWhitespace(textContent, this.startPos);\n      while (nextPos !== -1) {\n        const word = textContent.substring(this.startPos, nextPos);\n        const boldLength = getBoldLength(word);\n        this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n        this.replaceNodes.push(\n          document.createTextNode(\n            word.substring(boldLength, nextPos) + textContent[nextPos]\n          )\n        );\n        this.startPos = nextPos + 1;\n        nextPos = indexOfWhitespace(textContent, this.startPos);\n      }\n    }\n\n    // after this, startPos is likely to be at whitespace char\n    runInterNode() {\n      let word = \"\";\n      let endNodeIndex = this.startNodeIndex;\n      let endPos = this.startPos; // last word char pos + 1\n\n      // Find word boundary\n      while (endNodeIndex < this.nodes.length) {\n        const textContent = this.nodes[endNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, endPos);\n        if (nextPos === -1) {\n          word += textContent.substring(endPos);\n          endNodeIndex += 1;\n          endPos = 0;\n        } else {\n          word += textContent.substring(endPos, nextPos);\n          endPos = nextPos;\n          break;\n        }\n      }\n      // Calculate bold length\n      let remainingBoldLength = getBoldLength(word);\n\n      // Bold part of word\n      while (remainingBoldLength > 0) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        if (remainingBoldLength > textContent.length - this.startPos) {\n          const wordPart = textContent.substring(this.startPos);\n          remainingBoldLength -= wordPart.length;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        } else {\n          const wordPart = textContent.substring(\n            this.startPos,\n            this.startPos + remainingBoldLength\n          );\n          this.startPos += remainingBoldLength;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          remainingBoldLength -= wordPart.length;\n        }\n      }\n\n      // Add non-bolded part of words\n      while (this.startNodeIndex < endNodeIndex) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.replaceNode();\n        this.startNodeIndex += 1;\n        this.startPos = 0;\n      }\n\n      if (this.startPos < endPos) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos, endPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.startPos = endPos;\n      }\n    }\n  }\n\n  /**\n   * Builds a list of (list of nodes that makes up one non-line-broken line)\n   * @param {Node} elem\n   * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n   * @returns {void}\n   */\n  function forTextNodesInTree(elem, nodes, exclude = false) {\n    const children = elem.childNodes;\n    for (const filter of excludeFilters) {\n      if (filter(elem)) {\n        exclude = true;\n        break;\n      }\n    }\n    for (const child of children) {\n      if (child.nodeType === Node.ELEMENT_NODE) {\n        const style = window.getComputedStyle(child);\n        if (\n          child.tagName !== \"BR\" &&\n          (style === \"inline\" || style === \"inline-block\")\n        ) {\n          forTextNodesInTree(child, nodes, exclude);\n        } else {\n          if (nodes[nodes.length - 1].length > 0) {\n            nodes.push([]);\n          }\n          forTextNodesInTree(child, nodes, exclude);\n        }\n      } else if (\n        !exclude &&\n        child.nodeType === Node.TEXT_NODE &&\n        child.textContent.length > 0\n      ) {\n        nodes[nodes.length - 1].push(child);\n      }\n    }\n  }\n\n  function makeBionic() {\n    const cardContainer = document.getElementById(\"container\");\n    cardContainer.normalize();\n\n    let nodesLines = [[]];\n    forTextNodesInTree(cardContainer, nodesLines);\n    for (const nodes of nodesLines) {\n      BionicReaderBolder.run(nodes);\n    }\n\n    cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n      \"<strong></strong>\",\n      \"\"\n    );\n    cardContainer.normalize();\n  }\n\n  let start = performance.now();\n  if (bionicReading) {\n    makeBionic();\n  }\n  let end = performance.now();\n  console.log(`Initialized bionic reading: ${end - start}ms`);\n})();\n</script>\n\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\nvar userJs1 = undefined\nvar userJs2 = undefined\nvar userJs3 = undefined\nvar userJs4 = undefined\nvar userJs5 = undefined\nvar userJs6 = undefined\nvar userJs7 = undefined\nvar userJs8 = undefined\n</script>\n",
      "bqfmt": "{{Titel}}",
      "bafmt": "{{Markierung 4}}",
      "did": null,
      "bfont": "Helvetica",
      "bsize": 12
    },
    {
      "name": "Markierung 5",
      "ord": 4,
      "qfmt": "<!-- version 0fd8612 -->\n{{#Markierung 5}}\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TIMER CONFIG  ##############\n// Timer config (timer length, timer finished message)\nvar minutes =  0\nvar seconds = 15\nvar timeOverMsg = \"<span style='color:#CC5B5B'>!!!</span>\"\n\n  // ##############  TAG SHORTCUT  ##############\nvar toggleTagsShortcut = \"C\";\n\n// ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\nvar tagID = \"XXXYYYZZZ\"\n\n// WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\nvar numTagLevelsToShow = 0;\n\n// ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\nvar tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n// Enable experimental heuristic indentation feature\nvar indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n// Enable experimental DIVI medication formatting feature\nvar formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n// Enable experimental confounder formatting feature\nvar formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n// Enable bionic reading feature (based on AnKing add-on)\nvar bionicReading = false;\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button\n        id=\"button-tags\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n      >\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button\n        id=\"button-src\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n      >\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button\n        id=\"button-nid\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n      >\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button\n          id=\"button-ankihub\"\n          class=\"button-general\"\n          title=\"Karte in AnkiHub\"\n        >\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) {}\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button\n      id=\"button-tags\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button\n      id=\"button-src\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">Quelle: {{Quelle}}</div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button\n      id=\"button-nid\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    <i>Was</i> wird hier bei <b>⑤</b> gezeigt?\n\n    <br>\n    <br>\n\n    {{#Hint / Hinweis}}\n      <span style=\"color:IndianRed; font-weight: bold;\">Hinweis:</span> {{hint:Hint / Hinweis}}\n\n      <br>\n      <br>\n    {{/Hint / Hinweis}}\n    \n    {{Bild}}\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\"></div>\n\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n<script>\n  //DONT FADE BETWEEN CARDS\n  qFade = 0;\n  if (typeof anki !== 'undefined') anki.qFade = qFade;\n</script>\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\nfunction getTextWidth(text, font) {\n // re-use canvas object for better performance\n const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n const context = canvas.getContext(\"2d\");\n context.font = font;\n const metrics = context.measureText(text);\n return metrics.width;\n}\n\nfunction getCSSStyle(element, prop) {\n return window.getComputedStyle(element, null).getPropertyValue(prop);\n}\n\nfunction getCanvasFont(el = document.body) {\n const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n const fontSize = getCSSStyle(el, 'font-size') || '16px';\n const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n return `${fontWeight} ${fontSize} ${fontFamily}`;\n}\n\n/**\n* Iterates over a list of divs containing text to be indented\n*\n* @param {HTMLCollection} divs: The divs to be iterated over.\n*/\nfunction indentText(divs) {\n // setup the indentation markers\n var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n var bulletP = \"•\"\n var minus = \"– \"\n var enter = \"↳(?!( ↳|↳))\"\n var arrow = \"→\"\n\n // heuristic indentation hierarchy\n hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n // set up RegEx to analyze the provided divs\n // negative lookbehinds unfortunately do not work yet on iPad / Android\n var beginning = '(?<=<br>)(?<!cloze=\")('\n var middle = \".*?)((?:<br>)(?=(\"\n var end = \"))|(?=(<\\/indent>|<\\/div>|<br><br>)))\"\n\n const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n // iterate over divs\n for (const div of divs) {\n   // calculate indentation depths\n   var canvasFont = getCanvasFont(div)\n   var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n   var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n   var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n   var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n   var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n   var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n   var indentEnd = ';\">$1</indent>'\n\n   // do the indentation\n   divHTML = div.outerHTML\n   divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n   divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n   div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\")\n }\n}\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function(type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function(ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n  <script>\n    var tagContainer = document.getElementById(\"tags-container\")\n\n    if (tagContainer.childElementCount == 0) {\n      var tagList = tagContainer.innerHTML.trim().split(\" \");\n      var kbdList = [];\n      var newTagContent = document.createElement(\"div\");\n\n      for (var i = 0; i < tagList.length; i++) {\n        var newTag = document.createElement(\"kbd\");\n        var tag = tagList[i];\n        // numTagLevelsToShow == 0 means the whole tag should be shown\n        if (numTagLevelsToShow != 0) {\n          tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n        }\n\n        // Zankiphil / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n        if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) continue;\n        if (tag.split(\"::\")[1] == \"!NEW_CARDS\") continue;\n        if (tag.split(\"::\")[1] == \"§Projekt_Anki\") continue;\n        if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") continue;\n\n        // improve legibility of tags\n        tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n        tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\");\n        tag = tag.replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n        newTag.innerHTML = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"_\", \" \");\n        newTagContent.append(newTag)\n      }\n\n      tagContainer.innerHTML = newTagContent.innerHTML;\n      tagContainer.style.cursor = \"default\";\n    }\n\n    if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n      tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n    }\n\n    function showtags() {\n      var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n      if (tagContainerShortcut.style.display === \"none\") {\n        tagContainerShortcut.style.display = \"inline\";\n      } else {\n        tagContainerShortcut.style.display = \"none\";\n      }\n    }\n\n    var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n    ankingAddEventListener('keyup', function (e) {\n      if (isShortcut(e)) {\n        toggleHintBtn('hint-tags');\n        showtags();\n      }\n    });\n  </script>\n  <script>\n    for (const tag of document.getElementsByTagName('kbd')) {\n      tag.innerHTML = tag.innerHTML.replace(/::/g, '::<wbr>')\n    }\n  </script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (el.style.display === 'none') {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits( n ) {\n      return (n <= 9 ? \"0\" + n : n); \n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n      \n      if ( msLeft < 1000 ) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date( msLeft );\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout( updateTimer, time.getUTCMilliseconds() + 500 );\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60*minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds ); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function(key, dictionary){\n        return dictionary[key];\n      }\n    }\n    \n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n      \n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n      \n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n/**\n * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n * Full credit to the original authors, except where modified or otherwise indicated.\n */\n\n/**\n *\n * We try to respect that people use various note types\n * which may do 'weird' stuff.\n * Elements may have event listeners that can be removed if we just innerHTML stuff\n * <i> may be styled 'i { display: block }', etc.\n *\n * Another problem that complicate the design of this script is that\n * a word may not be cleanly separated by html tags.\n * e.g. \"A<i>long</i>word\"\n *\n */\n\n(function () {\n  /**\n   * @param {String} text\n   * @returns {number}\n   */\n  function getBoldLength(text) {\n    return Math.floor(text.length / 2);\n  }\n\n  // Ignore node if any of the filters return true\n  const excludeFilters = [\n    (elem) => elem.tagName === \"SCRIPT\",\n    (elem) => elem.tagName === \"STYLE\",\n    (elem) => elem.classList.contains(\"cloze\"),\n  ];\n\n  function newBoldElement(text) {\n    const elem = document.createElement(\"strong\");\n    elem.innerText = text;\n    return elem;\n  }\n\n  function indexOfWhitespace(text, startPos) {\n    const whitespaces = [\n      \" \",\n      \"\\n\",\n      \"\\t\",\n      \" \",\n      \"&nbsp;\",\n      \"‑\",\n      \"-\",\n      \"/\",\n      \"(\",\n      \")\",\n    ];\n    let nextPos = text.length;\n    for (const whitespace of whitespaces) {\n      const next = text.indexOf(whitespace, startPos);\n      if (next !== -1 && next < nextPos) {\n        nextPos = next;\n      }\n    }\n    if (nextPos === text.length) {\n      nextPos = -1;\n    }\n    return nextPos;\n  }\n\n  // Bolds a line of words\n  class BionicReaderBolder {\n    constructor(nodes) {\n      this.nodes = nodes;\n      this.startNodeIndex = 0;\n      this.startPos = 0;\n      this.replaceNodes = [];\n      while (!this.isFinished()) {\n        this.runWithinNode();\n        this.runInterNode();\n      }\n    }\n\n    static run(nodes) {\n      new BionicReaderBolder(nodes);\n    }\n\n    isFinished() {\n      return this.startNodeIndex === this.nodes.length;\n    }\n\n    replaceNode() {\n      const node = this.nodes[this.startNodeIndex];\n      const parent = node.parentNode;\n      for (let add of this.replaceNodes) {\n        parent.insertBefore(add, node);\n      }\n      parent.removeChild(node);\n      this.replaceNodes = [];\n    }\n\n    runWithinNode() {\n      const textContent = this.nodes[this.startNodeIndex].textContent;\n      let nextPos = indexOfWhitespace(textContent, this.startPos);\n      while (nextPos !== -1) {\n        const word = textContent.substring(this.startPos, nextPos);\n        const boldLength = getBoldLength(word);\n        this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n        this.replaceNodes.push(\n          document.createTextNode(\n            word.substring(boldLength, nextPos) + textContent[nextPos]\n          )\n        );\n        this.startPos = nextPos + 1;\n        nextPos = indexOfWhitespace(textContent, this.startPos);\n      }\n    }\n\n    // after this, startPos is likely to be at whitespace char\n    runInterNode() {\n      let word = \"\";\n      let endNodeIndex = this.startNodeIndex;\n      let endPos = this.startPos; // last word char pos + 1\n\n      // Find word boundary\n      while (endNodeIndex < this.nodes.length) {\n        const textContent = this.nodes[endNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, endPos);\n        if (nextPos === -1) {\n          word += textContent.substring(endPos);\n          endNodeIndex += 1;\n          endPos = 0;\n        } else {\n          word += textContent.substring(endPos, nextPos);\n          endPos = nextPos;\n          break;\n        }\n      }\n      // Calculate bold length\n      let remainingBoldLength = getBoldLength(word);\n\n      // Bold part of word\n      while (remainingBoldLength > 0) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        if (remainingBoldLength > textContent.length - this.startPos) {\n          const wordPart = textContent.substring(this.startPos);\n          remainingBoldLength -= wordPart.length;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        } else {\n          const wordPart = textContent.substring(\n            this.startPos,\n            this.startPos + remainingBoldLength\n          );\n          this.startPos += remainingBoldLength;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          remainingBoldLength -= wordPart.length;\n        }\n      }\n\n      // Add non-bolded part of words\n      while (this.startNodeIndex < endNodeIndex) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.replaceNode();\n        this.startNodeIndex += 1;\n        this.startPos = 0;\n      }\n\n      if (this.startPos < endPos) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos, endPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.startPos = endPos;\n      }\n    }\n  }\n\n  /**\n   * Builds a list of (list of nodes that makes up one non-line-broken line)\n   * @param {Node} elem\n   * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n   * @returns {void}\n   */\n  function forTextNodesInTree(elem, nodes, exclude = false) {\n    const children = elem.childNodes;\n    for (const filter of excludeFilters) {\n      if (filter(elem)) {\n        exclude = true;\n        break;\n      }\n    }\n    for (const child of children) {\n      if (child.nodeType === Node.ELEMENT_NODE) {\n        const style = window.getComputedStyle(child);\n        if (\n          child.tagName !== \"BR\" &&\n          (style === \"inline\" || style === \"inline-block\")\n        ) {\n          forTextNodesInTree(child, nodes, exclude);\n        } else {\n          if (nodes[nodes.length - 1].length > 0) {\n            nodes.push([]);\n          }\n          forTextNodesInTree(child, nodes, exclude);\n        }\n      } else if (\n        !exclude &&\n        child.nodeType === Node.TEXT_NODE &&\n        child.textContent.length > 0\n      ) {\n        nodes[nodes.length - 1].push(child);\n      }\n    }\n  }\n\n  function makeBionic() {\n    const cardContainer = document.getElementById(\"container\");\n    cardContainer.normalize();\n\n    let nodesLines = [[]];\n    forTextNodesInTree(cardContainer, nodesLines);\n    for (const nodes of nodesLines) {\n      BionicReaderBolder.run(nodes);\n    }\n\n    cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n      \"<strong></strong>\",\n      \"\"\n    );\n    cardContainer.normalize();\n  }\n\n  let start = performance.now();\n  if (bionicReading) {\n    makeBionic();\n  }\n  let end = performance.now();\n  console.log(`Initialized bionic reading: ${end - start}ms`);\n})();\n</script>\n\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\nvar userJs1 = undefined\nvar userJs2 = undefined\nvar userJs3 = undefined\nvar userJs4 = undefined\nvar userJs5 = undefined\nvar userJs6 = undefined\nvar userJs7 = undefined\nvar userJs8 = undefined\n</script>\n\n\n{{/Markierung 5}}",
      "afmt": "<!-- version 0fd8612 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Eigene Notizen & Bilder\": \"Alt + 1\",\n    \"Eigene Prüfungsfragen\": \"Alt + 2\",\n    \"Definitionen\": \"Alt + 3\",\n    \"Merksprüche\": \"Alt + 4\",\n    \"Klinik\": \"Alt + 5\",\n    \"Präparat\": \"Alt + 6\",\n    \"Memes\": \"Alt + 7\",\n    \"linkContainer\": \"Alt + L\",\n    \"Meditricks\": \"Alt + M\",\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Eigene Notizen & Bilder\": false,\n    \"Eigene Prüfungsfragen\": false,\n    \"Definitionen\": false,\n    \"Merksprüche\": false,\n    \"Klinik\": false,\n    \"Präparat\": false,\n    \"Memes\": false,\n    \"linkContainer\": true,\n    \"Meditricks\": false,\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\":false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\nvar toggleTagsShortcut = \"C\";\n\n// ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\nvar tagID = \"XXXYYYZZZ\"\n\n// WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\nvar numTagLevelsToShow = 0;\n\n// ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\nvar tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n// Enable experimental heuristic indentation feature\nvar indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n// Enable experimental DIVI medication formatting feature\nvar formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n// Enable experimental confounder formatting feature\nvar formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n// Enable bionic reading feature (based on AnKing add-on)\nvar bionicReading = false;\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button\n        id=\"button-tags\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n      >\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button\n        id=\"button-src\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n      >\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button\n        id=\"button-nid\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n      >\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button\n          id=\"button-ankihub\"\n          class=\"button-general\"\n          title=\"Karte in AnkiHub\"\n        >\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) {}\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button\n      id=\"button-tags\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button\n      id=\"button-src\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">Quelle: {{Quelle}}</div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button\n      id=\"button-nid\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    <i>Was</i> wird hier bei <b>⑤</b> gezeigt?\n\n    <br>\n    <br>\n\n    {{#Hint / Hinweis}}\n      <span style=\"color:IndianRed; font-weight: bold;\">Hinweis:</span> {{hint:Hint / Hinweis}}\n\n      <br>\n      <br>\n    {{/Hint / Hinweis}}\n    \n    {{Bild}}\n\n    <br>\n    <br>\n\n    <span class=\"cloze\">{{Markierung 5}}</span>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- BUTTON FIELDS -->\n    {{#Eigene Notizen & Bilder}}\n  <span id=\"hint-zusatz\" class=\"hintBtn\" data-name=\"Eigene Notizen & Bilder\" style=\"display: none;\">\n    <button id=\"button-zusatz\" class=\"button-general\" onclick=\"toggleHintBtn('hint-zusatz'); event.stopPropagation()\">\n      <img src=\"__zusatz.svg\" style=\"height: 10px;\"> Eigene Notizen & Bilder\n    </button>\n    <div id=\"zusatz\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Notizen & Bilder}}</div>\n  </span>\n{{/Eigene Notizen & Bilder}}\n\n    {{#Eigene Prüfungsfragen}}\n  <span id=\"hint-hammer\" class=\"hintBtn\" data-name=\"Eigene Prüfungsfragen\" style=\"display: none;\">\n    <button id=\"button-hammer\" class=\"button-general\" onclick=\"toggleHintBtn('hint-hammer'); event.stopPropagation()\">\n      <img src=\"__hammer.svg\" style=\"height: 10px;\"> Eigene Prüfungsfragen\n    </button>\n    <div id=\"hammer\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Prüfungsfragen}}</div>\n  </span>\n{{/Eigene Prüfungsfragen}}\n\n    {{#Definitionen}}\n  <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Definitionen\" style=\"display: none;\">\n    <button id=\"button-definition\" class=\"button-general\" onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n      <img src=\"__explanation.svg\" style=\"height: 10px;\"> Definitionen\n    </button>\n    <div id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Definitionen}}</div>\n  </span>\n{{/Definitionen}}\n\n    {{#Merksprüche}}\n  <span id=\"hint-merksprueche\" class=\"hintBtn\" data-name=\"Merksprüche\" style=\"display: none;\">\n    <button id=\"button-merksprueche\" class=\"button-general\" onclick=\"toggleHintBtn('hint-merksprueche'); event.stopPropagation()\">\n      <img src=\"__merkhilfe.svg\" style=\"height: 10px;\"> Merksprüche\n    </button>\n    <div id=\"merksprueche\" class=\"hints\" style=\"display: none;\">{{edit:Merksprüche}}</div>\n  </span>\n{{/Merksprüche}}\n\n    {{#Klinik}}\n  <span id=\"hint-klinik\" class=\"hintBtn\" data-name=\"Klinik\" style=\"display: none;\">\n    <button id=\"button-klinik\" class=\"button-general\" onclick=\"toggleHintBtn('hint-klinik'); event.stopPropagation()\">\n      <img src=\"__stethoscope.svg\" style=\"height: 10px;\"> Klinik\n    </button>\n    <div id=\"klinik\" class=\"hints\" style=\"display: none;\">{{edit:Klinik}}</div>\n  </span>\n{{/Klinik}}\n\n    {{#Präparat}}\n      <span id=\"hint-praeparat-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Präparat}}\">\n          <button id=\"button-praeparat\" class=\"button-general\">\n            <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n          </button>\n        </a>\n      </span>\n    {{/Präparat}}\n\n    {{#Virtuelle Mikroskopie}}\n      <span id=\"hint-microscope-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Virtuelle Mikroskopie}}\">\n          <button id=\"button-microscope\" class=\"button-general\">\n            <img src=\"__microscope.svg\" style=\"height: 10px;\"> Virtuelle Mikroskopie\n          </button>\n        </a>\n      </span>\n    {{/Virtuelle Mikroskopie}}\n\n    {{#Smart Zoom}}\n      <span id=\"hint-smartzoom-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Präparat}}\">\n          <button id=\"button-smartzoom\" class=\"button-general\">\n            <img src=\"__microscope.svg\" style=\"height: 10px;\"> Smart Zoom\n          </button>\n        </a>\n      </span>\n    {{/Smart Zoom}}\n\n    {{#HistoTrainer}}\n  <span id=\"hint-praeparat\" class=\"hintBtn\" data-name=\"HistoTrainer\" style=\"display: none;\">\n    <button id=\"button-praeparat\" class=\"button-general\" onclick=\"toggleHintBtn('hint-praeparat'); event.stopPropagation()\">\n      <img src=\"__microscope.svg\" style=\"height: 10px;\"> HistoTrainer\n    </button>\n    <div id=\"praeparat\" class=\"hints\" style=\"display: none;\">{{edit:HistoTrainer}}</div>\n  </span>\n{{/HistoTrainer}}\n\n    {{#Memes}}\n  <span id=\"hint-memes\" class=\"hintBtn\" data-name=\"Memes\" style=\"display: none;\">\n    <button id=\"button-memes\" class=\"button-general\" onclick=\"toggleHintBtn('hint-memes'); event.stopPropagation()\">\n      <img src=\"__sonstiges.svg\" style=\"height: 10px;\"> Memes\n    </button>\n    <div id=\"memes\" class=\"hints\" style=\"display: none;\">{{edit:Memes}}</div>\n  </span>\n{{/Memes}}\n\n    <!-- Extra field -->\n    {{#Extra}}\n      <div id=\"extra\" style=\"display: none;\">\n        <br><br>{{edit:Extra}}</div>\n    {{/Extra}}\n\n    {{#AMBOSS-Link}}\n      <span id=\"hint-amboss\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:AMBOSS-Link}}\">\n          <button id=\"button-amboss\" class=\"button-general\">\n            <img src=\"__amboss.svg\" style=\"height: 10px;\"> AMBOSS&#8203;\n          </button>\n        </a>\n      </span>\n    {{/AMBOSS-Link}}\n    \n    {{#Thieme via medici-Link}}\n      <span id=\"hint-thieme\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Thieme via medici-Link}}\">\n          <button id=\"button-thieme\" class=\"button-general\">\n            <img id=\"button-thieme-img\" src=\"__thieme-heart.svg\" style=\"height: 10px;\"> Thieme via medici\n          </button>\n        </a>\n      </span>\n    {{/Thieme via medici-Link}}\n\n    {{#Meditricks}}\n  <span id=\"hint-meditricks\" class=\"hintBtn\" data-name=\"Meditricks\" style=\"display: none;\">\n    <button id=\"button-meditricks\" class=\"button-general\" onclick=\"toggleHintBtn('hint-meditricks'); event.stopPropagation()\">\n      <img src=\"__meditricks.svg\" style=\"height: 10px;\"> Meditricks\n    </button>\n    <div id=\"meditricks\" class=\"hints\" style=\"display: none;\">{{edit:Meditricks}}</div>\n  </span>\n{{/Meditricks}}\n\n    {{#weitere Links}}\n    <span id=\"hint-linkcontainer\" class=\"hintBtn\" data-name=\"linkContainer\" style=\"display: none;\">\n      <button id=\"button-linkcontainer\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-linkcontainer'); event.stopPropagation()\">\n        <img src=\"__internet.svg\" style=\"height: 10px;\"> weitere Links\n      </button>\n      <div id=\"linkcontainer\" class=\"hints\" style=\"display: none;\"></div>\n      <span id=\"linkContainerLinks\" style=\"display: none;\">{{edit:weitere Links}}</span>\n    </span>\n  {{/weitere Links}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function(type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function(ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n  <script>\n    var tagContainer = document.getElementById(\"tags-container\")\n\n    if (tagContainer.childElementCount == 0) {\n      var tagList = tagContainer.innerHTML.trim().split(\" \");\n      var kbdList = [];\n      var newTagContent = document.createElement(\"div\");\n\n      for (var i = 0; i < tagList.length; i++) {\n        var newTag = document.createElement(\"kbd\");\n        var tag = tagList[i];\n        // numTagLevelsToShow == 0 means the whole tag should be shown\n        if (numTagLevelsToShow != 0) {\n          tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n        }\n\n        // Zankiphil / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n        if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) continue;\n        if (tag.split(\"::\")[1] == \"!NEW_CARDS\") continue;\n        if (tag.split(\"::\")[1] == \"§Projekt_Anki\") continue;\n        if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") continue;\n\n        // improve legibility of tags\n        tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n        tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\");\n        tag = tag.replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n        newTag.innerHTML = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"_\", \" \");\n        newTagContent.append(newTag)\n      }\n\n      tagContainer.innerHTML = newTagContent.innerHTML;\n      tagContainer.style.cursor = \"default\";\n    }\n\n    if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n      tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n    }\n\n    function showtags() {\n      var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n      if (tagContainerShortcut.style.display === \"none\") {\n        tagContainerShortcut.style.display = \"inline\";\n      } else {\n        tagContainerShortcut.style.display = \"none\";\n      }\n    }\n\n    var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n    ankingAddEventListener('keyup', function (e) {\n      if (isShortcut(e)) {\n        toggleHintBtn('hint-tags');\n        showtags();\n      }\n    });\n  </script>\n  <script>\n    for (const tag of document.getElementsByTagName('kbd')) {\n      tag.innerHTML = tag.innerHTML.replace(/::/g, '::<wbr>')\n    }\n  </script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (el.style.display === 'none') {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n    try {\n        for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n            href = link.href\n            text = link.innerText\n\n            const el = document.createElement('a');\n            el.setAttribute('href', link.href);\n\n            const btn = document.createElement('button');\n            btn.classList.add('button-general');\n            btn.classList.add('expanded-button');\n\n            domain = href.replace(/.+\\/\\/|(www|flexikon|de|next|com).|\\..+/g, '');\n            domainDict = {\n                \"amboss\": \"__amboss.svg\",\n                \"wikipedia\": \"__wikipedia.svg\",\n                \"doccheck\": \"__doccheck.png\",\n                \"notfallguru\": \"__notfallguru.svg\",\n            }\n            if (domain in domainDict) {\n                icon = domainDict[domain]\n            } else {\n                icon = \"__internet.svg\"\n            }\n\n            const img = document.createElement('img');\n            img.setAttribute('src', icon);\n            img.setAttribute('style', 'height: 10px;');\n\n            btn.appendChild(img);\n            btn.innerHTML = btn.innerHTML + \" \" + text;\n\n            el.appendChild(btn);\n\n            document.getElementById(\"linkcontainer\").appendChild(el)\n        }\n    }\n    catch (err) {\n        console.log(err)\n    }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\nfunction getTextWidth(text, font) {\n // re-use canvas object for better performance\n const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n const context = canvas.getContext(\"2d\");\n context.font = font;\n const metrics = context.measureText(text);\n return metrics.width;\n}\n\nfunction getCSSStyle(element, prop) {\n return window.getComputedStyle(element, null).getPropertyValue(prop);\n}\n\nfunction getCanvasFont(el = document.body) {\n const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n const fontSize = getCSSStyle(el, 'font-size') || '16px';\n const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n return `${fontWeight} ${fontSize} ${fontFamily}`;\n}\n\n/**\n* Iterates over a list of divs containing text to be indented\n*\n* @param {HTMLCollection} divs: The divs to be iterated over.\n*/\nfunction indentText(divs) {\n // setup the indentation markers\n var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n var bulletP = \"•\"\n var minus = \"– \"\n var enter = \"↳(?!( ↳|↳))\"\n var arrow = \"→\"\n\n // heuristic indentation hierarchy\n hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n // set up RegEx to analyze the provided divs\n // negative lookbehinds unfortunately do not work yet on iPad / Android\n var beginning = '(?<=<br>)(?<!cloze=\")('\n var middle = \".*?)((?:<br>)(?=(\"\n var end = \"))|(?=(<\\/indent>|<\\/div>|<br><br>)))\"\n\n const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n // iterate over divs\n for (const div of divs) {\n   // calculate indentation depths\n   var canvasFont = getCanvasFont(div)\n   var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n   var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n   var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n   var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n   var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n   var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n   var indentEnd = ';\">$1</indent>'\n\n   // do the indentation\n   divHTML = div.outerHTML\n   divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n   divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n   div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\")\n }\n}\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits( n ) {\n      return (n <= 9 ? \"0\" + n : n); \n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n      \n      if ( msLeft < 1000 ) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date( msLeft );\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout( updateTimer, time.getUTCMilliseconds() + 500 );\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60*minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds ); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function(key, dictionary){\n        return dictionary[key];\n      }\n    }\n    \n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n      \n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n      \n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n/**\n * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n * Full credit to the original authors, except where modified or otherwise indicated.\n */\n\n/**\n *\n * We try to respect that people use various note types\n * which may do 'weird' stuff.\n * Elements may have event listeners that can be removed if we just innerHTML stuff\n * <i> may be styled 'i { display: block }', etc.\n *\n * Another problem that complicate the design of this script is that\n * a word may not be cleanly separated by html tags.\n * e.g. \"A<i>long</i>word\"\n *\n */\n\n(function () {\n  /**\n   * @param {String} text\n   * @returns {number}\n   */\n  function getBoldLength(text) {\n    return Math.floor(text.length / 2);\n  }\n\n  // Ignore node if any of the filters return true\n  const excludeFilters = [\n    (elem) => elem.tagName === \"SCRIPT\",\n    (elem) => elem.tagName === \"STYLE\",\n    (elem) => elem.classList.contains(\"cloze\"),\n  ];\n\n  function newBoldElement(text) {\n    const elem = document.createElement(\"strong\");\n    elem.innerText = text;\n    return elem;\n  }\n\n  function indexOfWhitespace(text, startPos) {\n    const whitespaces = [\n      \" \",\n      \"\\n\",\n      \"\\t\",\n      \" \",\n      \"&nbsp;\",\n      \"‑\",\n      \"-\",\n      \"/\",\n      \"(\",\n      \")\",\n    ];\n    let nextPos = text.length;\n    for (const whitespace of whitespaces) {\n      const next = text.indexOf(whitespace, startPos);\n      if (next !== -1 && next < nextPos) {\n        nextPos = next;\n      }\n    }\n    if (nextPos === text.length) {\n      nextPos = -1;\n    }\n    return nextPos;\n  }\n\n  // Bolds a line of words\n  class BionicReaderBolder {\n    constructor(nodes) {\n      this.nodes = nodes;\n      this.startNodeIndex = 0;\n      this.startPos = 0;\n      this.replaceNodes = [];\n      while (!this.isFinished()) {\n        this.runWithinNode();\n        this.runInterNode();\n      }\n    }\n\n    static run(nodes) {\n      new BionicReaderBolder(nodes);\n    }\n\n    isFinished() {\n      return this.startNodeIndex === this.nodes.length;\n    }\n\n    replaceNode() {\n      const node = this.nodes[this.startNodeIndex];\n      const parent = node.parentNode;\n      for (let add of this.replaceNodes) {\n        parent.insertBefore(add, node);\n      }\n      parent.removeChild(node);\n      this.replaceNodes = [];\n    }\n\n    runWithinNode() {\n      const textContent = this.nodes[this.startNodeIndex].textContent;\n      let nextPos = indexOfWhitespace(textContent, this.startPos);\n      while (nextPos !== -1) {\n        const word = textContent.substring(this.startPos, nextPos);\n        const boldLength = getBoldLength(word);\n        this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n        this.replaceNodes.push(\n          document.createTextNode(\n            word.substring(boldLength, nextPos) + textContent[nextPos]\n          )\n        );\n        this.startPos = nextPos + 1;\n        nextPos = indexOfWhitespace(textContent, this.startPos);\n      }\n    }\n\n    // after this, startPos is likely to be at whitespace char\n    runInterNode() {\n      let word = \"\";\n      let endNodeIndex = this.startNodeIndex;\n      let endPos = this.startPos; // last word char pos + 1\n\n      // Find word boundary\n      while (endNodeIndex < this.nodes.length) {\n        const textContent = this.nodes[endNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, endPos);\n        if (nextPos === -1) {\n          word += textContent.substring(endPos);\n          endNodeIndex += 1;\n          endPos = 0;\n        } else {\n          word += textContent.substring(endPos, nextPos);\n          endPos = nextPos;\n          break;\n        }\n      }\n      // Calculate bold length\n      let remainingBoldLength = getBoldLength(word);\n\n      // Bold part of word\n      while (remainingBoldLength > 0) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        if (remainingBoldLength > textContent.length - this.startPos) {\n          const wordPart = textContent.substring(this.startPos);\n          remainingBoldLength -= wordPart.length;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        } else {\n          const wordPart = textContent.substring(\n            this.startPos,\n            this.startPos + remainingBoldLength\n          );\n          this.startPos += remainingBoldLength;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          remainingBoldLength -= wordPart.length;\n        }\n      }\n\n      // Add non-bolded part of words\n      while (this.startNodeIndex < endNodeIndex) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.replaceNode();\n        this.startNodeIndex += 1;\n        this.startPos = 0;\n      }\n\n      if (this.startPos < endPos) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos, endPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.startPos = endPos;\n      }\n    }\n  }\n\n  /**\n   * Builds a list of (list of nodes that makes up one non-line-broken line)\n   * @param {Node} elem\n   * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n   * @returns {void}\n   */\n  function forTextNodesInTree(elem, nodes, exclude = false) {\n    const children = elem.childNodes;\n    for (const filter of excludeFilters) {\n      if (filter(elem)) {\n        exclude = true;\n        break;\n      }\n    }\n    for (const child of children) {\n      if (child.nodeType === Node.ELEMENT_NODE) {\n        const style = window.getComputedStyle(child);\n        if (\n          child.tagName !== \"BR\" &&\n          (style === \"inline\" || style === \"inline-block\")\n        ) {\n          forTextNodesInTree(child, nodes, exclude);\n        } else {\n          if (nodes[nodes.length - 1].length > 0) {\n            nodes.push([]);\n          }\n          forTextNodesInTree(child, nodes, exclude);\n        }\n      } else if (\n        !exclude &&\n        child.nodeType === Node.TEXT_NODE &&\n        child.textContent.length > 0\n      ) {\n        nodes[nodes.length - 1].push(child);\n      }\n    }\n  }\n\n  function makeBionic() {\n    const cardContainer = document.getElementById(\"container\");\n    cardContainer.normalize();\n\n    let nodesLines = [[]];\n    forTextNodesInTree(cardContainer, nodesLines);\n    for (const nodes of nodesLines) {\n      BionicReaderBolder.run(nodes);\n    }\n\n    cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n      \"<strong></strong>\",\n      \"\"\n    );\n    cardContainer.normalize();\n  }\n\n  let start = performance.now();\n  if (bionicReading) {\n    makeBionic();\n  }\n  let end = performance.now();\n  console.log(`Initialized bionic reading: ${end - start}ms`);\n})();\n</script>\n\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\nvar userJs1 = undefined\nvar userJs2 = undefined\nvar userJs3 = undefined\nvar userJs4 = undefined\nvar userJs5 = undefined\nvar userJs6 = undefined\nvar userJs7 = undefined\nvar userJs8 = undefined\n</script>\n",
      "bqfmt": "{{Titel}}",
      "bafmt": "{{Markierung 5}}",
      "did": null,
      "bfont": "Helvetica",
      "bsize": 12
    },
    {
      "name": "Markierung 6",
      "ord": 5,
      "qfmt": "<!-- version 0fd8612 -->\n{{#Markierung 6}}\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TIMER CONFIG  ##############\n// Timer config (timer length, timer finished message)\nvar minutes =  0\nvar seconds = 15\nvar timeOverMsg = \"<span style='color:#CC5B5B'>!!!</span>\"\n\n  // ##############  TAG SHORTCUT  ##############\nvar toggleTagsShortcut = \"C\";\n\n// ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\nvar tagID = \"XXXYYYZZZ\"\n\n// WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\nvar numTagLevelsToShow = 0;\n\n// ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\nvar tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n// Enable experimental heuristic indentation feature\nvar indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n// Enable experimental DIVI medication formatting feature\nvar formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n// Enable experimental confounder formatting feature\nvar formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n// Enable bionic reading feature (based on AnKing add-on)\nvar bionicReading = false;\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button\n        id=\"button-tags\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n      >\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button\n        id=\"button-src\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n      >\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button\n        id=\"button-nid\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n      >\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button\n          id=\"button-ankihub\"\n          class=\"button-general\"\n          title=\"Karte in AnkiHub\"\n        >\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) {}\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button\n      id=\"button-tags\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button\n      id=\"button-src\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">Quelle: {{Quelle}}</div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button\n      id=\"button-nid\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    <i>Was</i> wird hier bei <b>⑥</b> gezeigt?\n\n    <br>\n    <br>\n\n    {{#Hint / Hinweis}}\n      <span style=\"color:IndianRed; font-weight: bold;\">Hinweis:</span> {{hint:Hint / Hinweis}}\n\n      <br>\n      <br>\n    {{/Hint / Hinweis}}\n    \n    {{Bild}}\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\"></div>\n\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n<script>\n  //DONT FADE BETWEEN CARDS\n  qFade = 0;\n  if (typeof anki !== 'undefined') anki.qFade = qFade;\n</script>\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\nfunction getTextWidth(text, font) {\n // re-use canvas object for better performance\n const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n const context = canvas.getContext(\"2d\");\n context.font = font;\n const metrics = context.measureText(text);\n return metrics.width;\n}\n\nfunction getCSSStyle(element, prop) {\n return window.getComputedStyle(element, null).getPropertyValue(prop);\n}\n\nfunction getCanvasFont(el = document.body) {\n const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n const fontSize = getCSSStyle(el, 'font-size') || '16px';\n const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n return `${fontWeight} ${fontSize} ${fontFamily}`;\n}\n\n/**\n* Iterates over a list of divs containing text to be indented\n*\n* @param {HTMLCollection} divs: The divs to be iterated over.\n*/\nfunction indentText(divs) {\n // setup the indentation markers\n var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n var bulletP = \"•\"\n var minus = \"– \"\n var enter = \"↳(?!( ↳|↳))\"\n var arrow = \"→\"\n\n // heuristic indentation hierarchy\n hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n // set up RegEx to analyze the provided divs\n // negative lookbehinds unfortunately do not work yet on iPad / Android\n var beginning = '(?<=<br>)(?<!cloze=\")('\n var middle = \".*?)((?:<br>)(?=(\"\n var end = \"))|(?=(<\\/indent>|<\\/div>|<br><br>)))\"\n\n const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n // iterate over divs\n for (const div of divs) {\n   // calculate indentation depths\n   var canvasFont = getCanvasFont(div)\n   var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n   var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n   var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n   var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n   var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n   var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n   var indentEnd = ';\">$1</indent>'\n\n   // do the indentation\n   divHTML = div.outerHTML\n   divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n   divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n   div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\")\n }\n}\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function(type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function(ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n  <script>\n    var tagContainer = document.getElementById(\"tags-container\")\n\n    if (tagContainer.childElementCount == 0) {\n      var tagList = tagContainer.innerHTML.trim().split(\" \");\n      var kbdList = [];\n      var newTagContent = document.createElement(\"div\");\n\n      for (var i = 0; i < tagList.length; i++) {\n        var newTag = document.createElement(\"kbd\");\n        var tag = tagList[i];\n        // numTagLevelsToShow == 0 means the whole tag should be shown\n        if (numTagLevelsToShow != 0) {\n          tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n        }\n\n        // Zankiphil / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n        if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) continue;\n        if (tag.split(\"::\")[1] == \"!NEW_CARDS\") continue;\n        if (tag.split(\"::\")[1] == \"§Projekt_Anki\") continue;\n        if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") continue;\n\n        // improve legibility of tags\n        tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n        tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\");\n        tag = tag.replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n        newTag.innerHTML = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"_\", \" \");\n        newTagContent.append(newTag)\n      }\n\n      tagContainer.innerHTML = newTagContent.innerHTML;\n      tagContainer.style.cursor = \"default\";\n    }\n\n    if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n      tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n    }\n\n    function showtags() {\n      var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n      if (tagContainerShortcut.style.display === \"none\") {\n        tagContainerShortcut.style.display = \"inline\";\n      } else {\n        tagContainerShortcut.style.display = \"none\";\n      }\n    }\n\n    var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n    ankingAddEventListener('keyup', function (e) {\n      if (isShortcut(e)) {\n        toggleHintBtn('hint-tags');\n        showtags();\n      }\n    });\n  </script>\n  <script>\n    for (const tag of document.getElementsByTagName('kbd')) {\n      tag.innerHTML = tag.innerHTML.replace(/::/g, '::<wbr>')\n    }\n  </script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (el.style.display === 'none') {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits( n ) {\n      return (n <= 9 ? \"0\" + n : n); \n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n      \n      if ( msLeft < 1000 ) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date( msLeft );\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout( updateTimer, time.getUTCMilliseconds() + 500 );\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60*minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds ); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function(key, dictionary){\n        return dictionary[key];\n      }\n    }\n    \n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n      \n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n      \n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n/**\n * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n * Full credit to the original authors, except where modified or otherwise indicated.\n */\n\n/**\n *\n * We try to respect that people use various note types\n * which may do 'weird' stuff.\n * Elements may have event listeners that can be removed if we just innerHTML stuff\n * <i> may be styled 'i { display: block }', etc.\n *\n * Another problem that complicate the design of this script is that\n * a word may not be cleanly separated by html tags.\n * e.g. \"A<i>long</i>word\"\n *\n */\n\n(function () {\n  /**\n   * @param {String} text\n   * @returns {number}\n   */\n  function getBoldLength(text) {\n    return Math.floor(text.length / 2);\n  }\n\n  // Ignore node if any of the filters return true\n  const excludeFilters = [\n    (elem) => elem.tagName === \"SCRIPT\",\n    (elem) => elem.tagName === \"STYLE\",\n    (elem) => elem.classList.contains(\"cloze\"),\n  ];\n\n  function newBoldElement(text) {\n    const elem = document.createElement(\"strong\");\n    elem.innerText = text;\n    return elem;\n  }\n\n  function indexOfWhitespace(text, startPos) {\n    const whitespaces = [\n      \" \",\n      \"\\n\",\n      \"\\t\",\n      \" \",\n      \"&nbsp;\",\n      \"‑\",\n      \"-\",\n      \"/\",\n      \"(\",\n      \")\",\n    ];\n    let nextPos = text.length;\n    for (const whitespace of whitespaces) {\n      const next = text.indexOf(whitespace, startPos);\n      if (next !== -1 && next < nextPos) {\n        nextPos = next;\n      }\n    }\n    if (nextPos === text.length) {\n      nextPos = -1;\n    }\n    return nextPos;\n  }\n\n  // Bolds a line of words\n  class BionicReaderBolder {\n    constructor(nodes) {\n      this.nodes = nodes;\n      this.startNodeIndex = 0;\n      this.startPos = 0;\n      this.replaceNodes = [];\n      while (!this.isFinished()) {\n        this.runWithinNode();\n        this.runInterNode();\n      }\n    }\n\n    static run(nodes) {\n      new BionicReaderBolder(nodes);\n    }\n\n    isFinished() {\n      return this.startNodeIndex === this.nodes.length;\n    }\n\n    replaceNode() {\n      const node = this.nodes[this.startNodeIndex];\n      const parent = node.parentNode;\n      for (let add of this.replaceNodes) {\n        parent.insertBefore(add, node);\n      }\n      parent.removeChild(node);\n      this.replaceNodes = [];\n    }\n\n    runWithinNode() {\n      const textContent = this.nodes[this.startNodeIndex].textContent;\n      let nextPos = indexOfWhitespace(textContent, this.startPos);\n      while (nextPos !== -1) {\n        const word = textContent.substring(this.startPos, nextPos);\n        const boldLength = getBoldLength(word);\n        this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n        this.replaceNodes.push(\n          document.createTextNode(\n            word.substring(boldLength, nextPos) + textContent[nextPos]\n          )\n        );\n        this.startPos = nextPos + 1;\n        nextPos = indexOfWhitespace(textContent, this.startPos);\n      }\n    }\n\n    // after this, startPos is likely to be at whitespace char\n    runInterNode() {\n      let word = \"\";\n      let endNodeIndex = this.startNodeIndex;\n      let endPos = this.startPos; // last word char pos + 1\n\n      // Find word boundary\n      while (endNodeIndex < this.nodes.length) {\n        const textContent = this.nodes[endNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, endPos);\n        if (nextPos === -1) {\n          word += textContent.substring(endPos);\n          endNodeIndex += 1;\n          endPos = 0;\n        } else {\n          word += textContent.substring(endPos, nextPos);\n          endPos = nextPos;\n          break;\n        }\n      }\n      // Calculate bold length\n      let remainingBoldLength = getBoldLength(word);\n\n      // Bold part of word\n      while (remainingBoldLength > 0) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        if (remainingBoldLength > textContent.length - this.startPos) {\n          const wordPart = textContent.substring(this.startPos);\n          remainingBoldLength -= wordPart.length;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        } else {\n          const wordPart = textContent.substring(\n            this.startPos,\n            this.startPos + remainingBoldLength\n          );\n          this.startPos += remainingBoldLength;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          remainingBoldLength -= wordPart.length;\n        }\n      }\n\n      // Add non-bolded part of words\n      while (this.startNodeIndex < endNodeIndex) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.replaceNode();\n        this.startNodeIndex += 1;\n        this.startPos = 0;\n      }\n\n      if (this.startPos < endPos) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos, endPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.startPos = endPos;\n      }\n    }\n  }\n\n  /**\n   * Builds a list of (list of nodes that makes up one non-line-broken line)\n   * @param {Node} elem\n   * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n   * @returns {void}\n   */\n  function forTextNodesInTree(elem, nodes, exclude = false) {\n    const children = elem.childNodes;\n    for (const filter of excludeFilters) {\n      if (filter(elem)) {\n        exclude = true;\n        break;\n      }\n    }\n    for (const child of children) {\n      if (child.nodeType === Node.ELEMENT_NODE) {\n        const style = window.getComputedStyle(child);\n        if (\n          child.tagName !== \"BR\" &&\n          (style === \"inline\" || style === \"inline-block\")\n        ) {\n          forTextNodesInTree(child, nodes, exclude);\n        } else {\n          if (nodes[nodes.length - 1].length > 0) {\n            nodes.push([]);\n          }\n          forTextNodesInTree(child, nodes, exclude);\n        }\n      } else if (\n        !exclude &&\n        child.nodeType === Node.TEXT_NODE &&\n        child.textContent.length > 0\n      ) {\n        nodes[nodes.length - 1].push(child);\n      }\n    }\n  }\n\n  function makeBionic() {\n    const cardContainer = document.getElementById(\"container\");\n    cardContainer.normalize();\n\n    let nodesLines = [[]];\n    forTextNodesInTree(cardContainer, nodesLines);\n    for (const nodes of nodesLines) {\n      BionicReaderBolder.run(nodes);\n    }\n\n    cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n      \"<strong></strong>\",\n      \"\"\n    );\n    cardContainer.normalize();\n  }\n\n  let start = performance.now();\n  if (bionicReading) {\n    makeBionic();\n  }\n  let end = performance.now();\n  console.log(`Initialized bionic reading: ${end - start}ms`);\n})();\n</script>\n\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\nvar userJs1 = undefined\nvar userJs2 = undefined\nvar userJs3 = undefined\nvar userJs4 = undefined\nvar userJs5 = undefined\nvar userJs6 = undefined\nvar userJs7 = undefined\nvar userJs8 = undefined\n</script>\n\n\n{{/Markierung 6}}",
      "afmt": "<!-- version 0fd8612 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Eigene Notizen & Bilder\": \"Alt + 1\",\n    \"Eigene Prüfungsfragen\": \"Alt + 2\",\n    \"Definitionen\": \"Alt + 3\",\n    \"Merksprüche\": \"Alt + 4\",\n    \"Klinik\": \"Alt + 5\",\n    \"Präparat\": \"Alt + 6\",\n    \"Memes\": \"Alt + 7\",\n    \"linkContainer\": \"Alt + L\",\n    \"Meditricks\": \"Alt + M\",\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Eigene Notizen & Bilder\": false,\n    \"Eigene Prüfungsfragen\": false,\n    \"Definitionen\": false,\n    \"Merksprüche\": false,\n    \"Klinik\": false,\n    \"Präparat\": false,\n    \"Memes\": false,\n    \"linkContainer\": true,\n    \"Meditricks\": false,\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\":false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\nvar toggleTagsShortcut = \"C\";\n\n// ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\nvar tagID = \"XXXYYYZZZ\"\n\n// WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\nvar numTagLevelsToShow = 0;\n\n// ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\nvar tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n// Enable experimental heuristic indentation feature\nvar indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n// Enable experimental DIVI medication formatting feature\nvar formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n// Enable experimental confounder formatting feature\nvar formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n// Enable bionic reading feature (based on AnKing add-on)\nvar bionicReading = false;\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button\n        id=\"button-tags\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n      >\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button\n        id=\"button-src\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n      >\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button\n        id=\"button-nid\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n      >\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button\n          id=\"button-ankihub\"\n          class=\"button-general\"\n          title=\"Karte in AnkiHub\"\n        >\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) {}\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button\n      id=\"button-tags\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button\n      id=\"button-src\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">Quelle: {{Quelle}}</div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button\n      id=\"button-nid\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    <i>Was</i> wird hier bei <b>⑥</b> gezeigt?\n\n    <br>\n    <br>\n\n    {{#Hint / Hinweis}}\n      <span style=\"color:IndianRed; font-weight: bold;\">Hinweis:</span> {{hint:Hint / Hinweis}}\n\n      <br>\n      <br>\n    {{/Hint / Hinweis}}\n    \n    {{Bild}}\n\n    <br>\n    <br>\n\n    <span class=\"cloze\">{{Markierung 6}}</span>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- BUTTON FIELDS -->\n    {{#Eigene Notizen & Bilder}}\n  <span id=\"hint-zusatz\" class=\"hintBtn\" data-name=\"Eigene Notizen & Bilder\" style=\"display: none;\">\n    <button id=\"button-zusatz\" class=\"button-general\" onclick=\"toggleHintBtn('hint-zusatz'); event.stopPropagation()\">\n      <img src=\"__zusatz.svg\" style=\"height: 10px;\"> Eigene Notizen & Bilder\n    </button>\n    <div id=\"zusatz\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Notizen & Bilder}}</div>\n  </span>\n{{/Eigene Notizen & Bilder}}\n\n    {{#Eigene Prüfungsfragen}}\n  <span id=\"hint-hammer\" class=\"hintBtn\" data-name=\"Eigene Prüfungsfragen\" style=\"display: none;\">\n    <button id=\"button-hammer\" class=\"button-general\" onclick=\"toggleHintBtn('hint-hammer'); event.stopPropagation()\">\n      <img src=\"__hammer.svg\" style=\"height: 10px;\"> Eigene Prüfungsfragen\n    </button>\n    <div id=\"hammer\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Prüfungsfragen}}</div>\n  </span>\n{{/Eigene Prüfungsfragen}}\n\n    {{#Definitionen}}\n  <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Definitionen\" style=\"display: none;\">\n    <button id=\"button-definition\" class=\"button-general\" onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n      <img src=\"__explanation.svg\" style=\"height: 10px;\"> Definitionen\n    </button>\n    <div id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Definitionen}}</div>\n  </span>\n{{/Definitionen}}\n\n    {{#Merksprüche}}\n  <span id=\"hint-merksprueche\" class=\"hintBtn\" data-name=\"Merksprüche\" style=\"display: none;\">\n    <button id=\"button-merksprueche\" class=\"button-general\" onclick=\"toggleHintBtn('hint-merksprueche'); event.stopPropagation()\">\n      <img src=\"__merkhilfe.svg\" style=\"height: 10px;\"> Merksprüche\n    </button>\n    <div id=\"merksprueche\" class=\"hints\" style=\"display: none;\">{{edit:Merksprüche}}</div>\n  </span>\n{{/Merksprüche}}\n\n    {{#Klinik}}\n  <span id=\"hint-klinik\" class=\"hintBtn\" data-name=\"Klinik\" style=\"display: none;\">\n    <button id=\"button-klinik\" class=\"button-general\" onclick=\"toggleHintBtn('hint-klinik'); event.stopPropagation()\">\n      <img src=\"__stethoscope.svg\" style=\"height: 10px;\"> Klinik\n    </button>\n    <div id=\"klinik\" class=\"hints\" style=\"display: none;\">{{edit:Klinik}}</div>\n  </span>\n{{/Klinik}}\n\n    {{#Präparat}}\n      <span id=\"hint-praeparat-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Präparat}}\">\n          <button id=\"button-praeparat\" class=\"button-general\">\n            <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n          </button>\n        </a>\n      </span>\n    {{/Präparat}}\n\n    {{#Virtuelle Mikroskopie}}\n      <span id=\"hint-microscope-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Virtuelle Mikroskopie}}\">\n          <button id=\"button-microscope\" class=\"button-general\">\n            <img src=\"__microscope.svg\" style=\"height: 10px;\"> Virtuelle Mikroskopie\n          </button>\n        </a>\n      </span>\n    {{/Virtuelle Mikroskopie}}\n\n    {{#Smart Zoom}}\n      <span id=\"hint-smartzoom-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Präparat}}\">\n          <button id=\"button-smartzoom\" class=\"button-general\">\n            <img src=\"__microscope.svg\" style=\"height: 10px;\"> Smart Zoom\n          </button>\n        </a>\n      </span>\n    {{/Smart Zoom}}\n\n    {{#HistoTrainer}}\n  <span id=\"hint-praeparat\" class=\"hintBtn\" data-name=\"HistoTrainer\" style=\"display: none;\">\n    <button id=\"button-praeparat\" class=\"button-general\" onclick=\"toggleHintBtn('hint-praeparat'); event.stopPropagation()\">\n      <img src=\"__microscope.svg\" style=\"height: 10px;\"> HistoTrainer\n    </button>\n    <div id=\"praeparat\" class=\"hints\" style=\"display: none;\">{{edit:HistoTrainer}}</div>\n  </span>\n{{/HistoTrainer}}\n\n    {{#Memes}}\n  <span id=\"hint-memes\" class=\"hintBtn\" data-name=\"Memes\" style=\"display: none;\">\n    <button id=\"button-memes\" class=\"button-general\" onclick=\"toggleHintBtn('hint-memes'); event.stopPropagation()\">\n      <img src=\"__sonstiges.svg\" style=\"height: 10px;\"> Memes\n    </button>\n    <div id=\"memes\" class=\"hints\" style=\"display: none;\">{{edit:Memes}}</div>\n  </span>\n{{/Memes}}\n\n    <!-- Extra field -->\n    {{#Extra}}\n      <div id=\"extra\" style=\"display: none;\">\n        <br><br>{{edit:Extra}}</div>\n    {{/Extra}}\n\n    {{#AMBOSS-Link}}\n      <span id=\"hint-amboss\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:AMBOSS-Link}}\">\n          <button id=\"button-amboss\" class=\"button-general\">\n            <img src=\"__amboss.svg\" style=\"height: 10px;\"> AMBOSS&#8203;\n          </button>\n        </a>\n      </span>\n    {{/AMBOSS-Link}}\n    \n    {{#Thieme via medici-Link}}\n      <span id=\"hint-thieme\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Thieme via medici-Link}}\">\n          <button id=\"button-thieme\" class=\"button-general\">\n            <img id=\"button-thieme-img\" src=\"__thieme-heart.svg\" style=\"height: 10px;\"> Thieme via medici\n          </button>\n        </a>\n      </span>\n    {{/Thieme via medici-Link}}\n\n    {{#Meditricks}}\n  <span id=\"hint-meditricks\" class=\"hintBtn\" data-name=\"Meditricks\" style=\"display: none;\">\n    <button id=\"button-meditricks\" class=\"button-general\" onclick=\"toggleHintBtn('hint-meditricks'); event.stopPropagation()\">\n      <img src=\"__meditricks.svg\" style=\"height: 10px;\"> Meditricks\n    </button>\n    <div id=\"meditricks\" class=\"hints\" style=\"display: none;\">{{edit:Meditricks}}</div>\n  </span>\n{{/Meditricks}}\n\n    {{#weitere Links}}\n    <span id=\"hint-linkcontainer\" class=\"hintBtn\" data-name=\"linkContainer\" style=\"display: none;\">\n      <button id=\"button-linkcontainer\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-linkcontainer'); event.stopPropagation()\">\n        <img src=\"__internet.svg\" style=\"height: 10px;\"> weitere Links\n      </button>\n      <div id=\"linkcontainer\" class=\"hints\" style=\"display: none;\"></div>\n      <span id=\"linkContainerLinks\" style=\"display: none;\">{{edit:weitere Links}}</span>\n    </span>\n  {{/weitere Links}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function(type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function(ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n  <script>\n    var tagContainer = document.getElementById(\"tags-container\")\n\n    if (tagContainer.childElementCount == 0) {\n      var tagList = tagContainer.innerHTML.trim().split(\" \");\n      var kbdList = [];\n      var newTagContent = document.createElement(\"div\");\n\n      for (var i = 0; i < tagList.length; i++) {\n        var newTag = document.createElement(\"kbd\");\n        var tag = tagList[i];\n        // numTagLevelsToShow == 0 means the whole tag should be shown\n        if (numTagLevelsToShow != 0) {\n          tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n        }\n\n        // Zankiphil / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n        if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) continue;\n        if (tag.split(\"::\")[1] == \"!NEW_CARDS\") continue;\n        if (tag.split(\"::\")[1] == \"§Projekt_Anki\") continue;\n        if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") continue;\n\n        // improve legibility of tags\n        tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n        tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\");\n        tag = tag.replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n        newTag.innerHTML = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"_\", \" \");\n        newTagContent.append(newTag)\n      }\n\n      tagContainer.innerHTML = newTagContent.innerHTML;\n      tagContainer.style.cursor = \"default\";\n    }\n\n    if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n      tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n    }\n\n    function showtags() {\n      var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n      if (tagContainerShortcut.style.display === \"none\") {\n        tagContainerShortcut.style.display = \"inline\";\n      } else {\n        tagContainerShortcut.style.display = \"none\";\n      }\n    }\n\n    var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n    ankingAddEventListener('keyup', function (e) {\n      if (isShortcut(e)) {\n        toggleHintBtn('hint-tags');\n        showtags();\n      }\n    });\n  </script>\n  <script>\n    for (const tag of document.getElementsByTagName('kbd')) {\n      tag.innerHTML = tag.innerHTML.replace(/::/g, '::<wbr>')\n    }\n  </script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (el.style.display === 'none') {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n    try {\n        for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n            href = link.href\n            text = link.innerText\n\n            const el = document.createElement('a');\n            el.setAttribute('href', link.href);\n\n            const btn = document.createElement('button');\n            btn.classList.add('button-general');\n            btn.classList.add('expanded-button');\n\n            domain = href.replace(/.+\\/\\/|(www|flexikon|de|next|com).|\\..+/g, '');\n            domainDict = {\n                \"amboss\": \"__amboss.svg\",\n                \"wikipedia\": \"__wikipedia.svg\",\n                \"doccheck\": \"__doccheck.png\",\n                \"notfallguru\": \"__notfallguru.svg\",\n            }\n            if (domain in domainDict) {\n                icon = domainDict[domain]\n            } else {\n                icon = \"__internet.svg\"\n            }\n\n            const img = document.createElement('img');\n            img.setAttribute('src', icon);\n            img.setAttribute('style', 'height: 10px;');\n\n            btn.appendChild(img);\n            btn.innerHTML = btn.innerHTML + \" \" + text;\n\n            el.appendChild(btn);\n\n            document.getElementById(\"linkcontainer\").appendChild(el)\n        }\n    }\n    catch (err) {\n        console.log(err)\n    }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\nfunction getTextWidth(text, font) {\n // re-use canvas object for better performance\n const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n const context = canvas.getContext(\"2d\");\n context.font = font;\n const metrics = context.measureText(text);\n return metrics.width;\n}\n\nfunction getCSSStyle(element, prop) {\n return window.getComputedStyle(element, null).getPropertyValue(prop);\n}\n\nfunction getCanvasFont(el = document.body) {\n const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n const fontSize = getCSSStyle(el, 'font-size') || '16px';\n const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n return `${fontWeight} ${fontSize} ${fontFamily}`;\n}\n\n/**\n* Iterates over a list of divs containing text to be indented\n*\n* @param {HTMLCollection} divs: The divs to be iterated over.\n*/\nfunction indentText(divs) {\n // setup the indentation markers\n var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n var bulletP = \"•\"\n var minus = \"– \"\n var enter = \"↳(?!( ↳|↳))\"\n var arrow = \"→\"\n\n // heuristic indentation hierarchy\n hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n // set up RegEx to analyze the provided divs\n // negative lookbehinds unfortunately do not work yet on iPad / Android\n var beginning = '(?<=<br>)(?<!cloze=\")('\n var middle = \".*?)((?:<br>)(?=(\"\n var end = \"))|(?=(<\\/indent>|<\\/div>|<br><br>)))\"\n\n const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n // iterate over divs\n for (const div of divs) {\n   // calculate indentation depths\n   var canvasFont = getCanvasFont(div)\n   var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n   var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n   var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n   var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n   var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n   var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n   var indentEnd = ';\">$1</indent>'\n\n   // do the indentation\n   divHTML = div.outerHTML\n   divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n   divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n   div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\")\n }\n}\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits( n ) {\n      return (n <= 9 ? \"0\" + n : n); \n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n      \n      if ( msLeft < 1000 ) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date( msLeft );\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout( updateTimer, time.getUTCMilliseconds() + 500 );\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60*minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds ); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function(key, dictionary){\n        return dictionary[key];\n      }\n    }\n    \n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n      \n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n      \n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n/**\n * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n * Full credit to the original authors, except where modified or otherwise indicated.\n */\n\n/**\n *\n * We try to respect that people use various note types\n * which may do 'weird' stuff.\n * Elements may have event listeners that can be removed if we just innerHTML stuff\n * <i> may be styled 'i { display: block }', etc.\n *\n * Another problem that complicate the design of this script is that\n * a word may not be cleanly separated by html tags.\n * e.g. \"A<i>long</i>word\"\n *\n */\n\n(function () {\n  /**\n   * @param {String} text\n   * @returns {number}\n   */\n  function getBoldLength(text) {\n    return Math.floor(text.length / 2);\n  }\n\n  // Ignore node if any of the filters return true\n  const excludeFilters = [\n    (elem) => elem.tagName === \"SCRIPT\",\n    (elem) => elem.tagName === \"STYLE\",\n    (elem) => elem.classList.contains(\"cloze\"),\n  ];\n\n  function newBoldElement(text) {\n    const elem = document.createElement(\"strong\");\n    elem.innerText = text;\n    return elem;\n  }\n\n  function indexOfWhitespace(text, startPos) {\n    const whitespaces = [\n      \" \",\n      \"\\n\",\n      \"\\t\",\n      \" \",\n      \"&nbsp;\",\n      \"‑\",\n      \"-\",\n      \"/\",\n      \"(\",\n      \")\",\n    ];\n    let nextPos = text.length;\n    for (const whitespace of whitespaces) {\n      const next = text.indexOf(whitespace, startPos);\n      if (next !== -1 && next < nextPos) {\n        nextPos = next;\n      }\n    }\n    if (nextPos === text.length) {\n      nextPos = -1;\n    }\n    return nextPos;\n  }\n\n  // Bolds a line of words\n  class BionicReaderBolder {\n    constructor(nodes) {\n      this.nodes = nodes;\n      this.startNodeIndex = 0;\n      this.startPos = 0;\n      this.replaceNodes = [];\n      while (!this.isFinished()) {\n        this.runWithinNode();\n        this.runInterNode();\n      }\n    }\n\n    static run(nodes) {\n      new BionicReaderBolder(nodes);\n    }\n\n    isFinished() {\n      return this.startNodeIndex === this.nodes.length;\n    }\n\n    replaceNode() {\n      const node = this.nodes[this.startNodeIndex];\n      const parent = node.parentNode;\n      for (let add of this.replaceNodes) {\n        parent.insertBefore(add, node);\n      }\n      parent.removeChild(node);\n      this.replaceNodes = [];\n    }\n\n    runWithinNode() {\n      const textContent = this.nodes[this.startNodeIndex].textContent;\n      let nextPos = indexOfWhitespace(textContent, this.startPos);\n      while (nextPos !== -1) {\n        const word = textContent.substring(this.startPos, nextPos);\n        const boldLength = getBoldLength(word);\n        this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n        this.replaceNodes.push(\n          document.createTextNode(\n            word.substring(boldLength, nextPos) + textContent[nextPos]\n          )\n        );\n        this.startPos = nextPos + 1;\n        nextPos = indexOfWhitespace(textContent, this.startPos);\n      }\n    }\n\n    // after this, startPos is likely to be at whitespace char\n    runInterNode() {\n      let word = \"\";\n      let endNodeIndex = this.startNodeIndex;\n      let endPos = this.startPos; // last word char pos + 1\n\n      // Find word boundary\n      while (endNodeIndex < this.nodes.length) {\n        const textContent = this.nodes[endNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, endPos);\n        if (nextPos === -1) {\n          word += textContent.substring(endPos);\n          endNodeIndex += 1;\n          endPos = 0;\n        } else {\n          word += textContent.substring(endPos, nextPos);\n          endPos = nextPos;\n          break;\n        }\n      }\n      // Calculate bold length\n      let remainingBoldLength = getBoldLength(word);\n\n      // Bold part of word\n      while (remainingBoldLength > 0) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        if (remainingBoldLength > textContent.length - this.startPos) {\n          const wordPart = textContent.substring(this.startPos);\n          remainingBoldLength -= wordPart.length;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        } else {\n          const wordPart = textContent.substring(\n            this.startPos,\n            this.startPos + remainingBoldLength\n          );\n          this.startPos += remainingBoldLength;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          remainingBoldLength -= wordPart.length;\n        }\n      }\n\n      // Add non-bolded part of words\n      while (this.startNodeIndex < endNodeIndex) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.replaceNode();\n        this.startNodeIndex += 1;\n        this.startPos = 0;\n      }\n\n      if (this.startPos < endPos) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos, endPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.startPos = endPos;\n      }\n    }\n  }\n\n  /**\n   * Builds a list of (list of nodes that makes up one non-line-broken line)\n   * @param {Node} elem\n   * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n   * @returns {void}\n   */\n  function forTextNodesInTree(elem, nodes, exclude = false) {\n    const children = elem.childNodes;\n    for (const filter of excludeFilters) {\n      if (filter(elem)) {\n        exclude = true;\n        break;\n      }\n    }\n    for (const child of children) {\n      if (child.nodeType === Node.ELEMENT_NODE) {\n        const style = window.getComputedStyle(child);\n        if (\n          child.tagName !== \"BR\" &&\n          (style === \"inline\" || style === \"inline-block\")\n        ) {\n          forTextNodesInTree(child, nodes, exclude);\n        } else {\n          if (nodes[nodes.length - 1].length > 0) {\n            nodes.push([]);\n          }\n          forTextNodesInTree(child, nodes, exclude);\n        }\n      } else if (\n        !exclude &&\n        child.nodeType === Node.TEXT_NODE &&\n        child.textContent.length > 0\n      ) {\n        nodes[nodes.length - 1].push(child);\n      }\n    }\n  }\n\n  function makeBionic() {\n    const cardContainer = document.getElementById(\"container\");\n    cardContainer.normalize();\n\n    let nodesLines = [[]];\n    forTextNodesInTree(cardContainer, nodesLines);\n    for (const nodes of nodesLines) {\n      BionicReaderBolder.run(nodes);\n    }\n\n    cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n      \"<strong></strong>\",\n      \"\"\n    );\n    cardContainer.normalize();\n  }\n\n  let start = performance.now();\n  if (bionicReading) {\n    makeBionic();\n  }\n  let end = performance.now();\n  console.log(`Initialized bionic reading: ${end - start}ms`);\n})();\n</script>\n\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\nvar userJs1 = undefined\nvar userJs2 = undefined\nvar userJs3 = undefined\nvar userJs4 = undefined\nvar userJs5 = undefined\nvar userJs6 = undefined\nvar userJs7 = undefined\nvar userJs8 = undefined\n</script>\n",
      "bqfmt": "{{Titel}}",
      "bafmt": "{{Markierung 6}}",
      "did": null,
      "bfont": "Helvetica",
      "bsize": 12
    },
    {
      "name": "Markierung 7",
      "ord": 6,
      "qfmt": "<!-- version 0fd8612 -->\n{{#Markierung 7}}\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TIMER CONFIG  ##############\n// Timer config (timer length, timer finished message)\nvar minutes =  0\nvar seconds = 15\nvar timeOverMsg = \"<span style='color:#CC5B5B'>!!!</span>\"\n\n  // ##############  TAG SHORTCUT  ##############\nvar toggleTagsShortcut = \"C\";\n\n// ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\nvar tagID = \"XXXYYYZZZ\"\n\n// WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\nvar numTagLevelsToShow = 0;\n\n// ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\nvar tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n// Enable experimental heuristic indentation feature\nvar indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n// Enable experimental DIVI medication formatting feature\nvar formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n// Enable experimental confounder formatting feature\nvar formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n// Enable bionic reading feature (based on AnKing add-on)\nvar bionicReading = false;\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button\n        id=\"button-tags\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n      >\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button\n        id=\"button-src\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n      >\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button\n        id=\"button-nid\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n      >\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button\n          id=\"button-ankihub\"\n          class=\"button-general\"\n          title=\"Karte in AnkiHub\"\n        >\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) {}\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button\n      id=\"button-tags\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button\n      id=\"button-src\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">Quelle: {{Quelle}}</div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button\n      id=\"button-nid\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    <i>Was</i> wird hier bei <b>⑦</b> gezeigt?\n\n    <br>\n    <br>\n\n    {{#Hint / Hinweis}}\n      <span style=\"color:IndianRed; font-weight: bold;\">Hinweis:</span> {{hint:Hint / Hinweis}}\n\n      <br>\n      <br>\n    {{/Hint / Hinweis}}\n    \n    {{Bild}}\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\"></div>\n\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n<script>\n  //DONT FADE BETWEEN CARDS\n  qFade = 0;\n  if (typeof anki !== 'undefined') anki.qFade = qFade;\n</script>\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\nfunction getTextWidth(text, font) {\n // re-use canvas object for better performance\n const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n const context = canvas.getContext(\"2d\");\n context.font = font;\n const metrics = context.measureText(text);\n return metrics.width;\n}\n\nfunction getCSSStyle(element, prop) {\n return window.getComputedStyle(element, null).getPropertyValue(prop);\n}\n\nfunction getCanvasFont(el = document.body) {\n const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n const fontSize = getCSSStyle(el, 'font-size') || '16px';\n const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n return `${fontWeight} ${fontSize} ${fontFamily}`;\n}\n\n/**\n* Iterates over a list of divs containing text to be indented\n*\n* @param {HTMLCollection} divs: The divs to be iterated over.\n*/\nfunction indentText(divs) {\n // setup the indentation markers\n var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n var bulletP = \"•\"\n var minus = \"– \"\n var enter = \"↳(?!( ↳|↳))\"\n var arrow = \"→\"\n\n // heuristic indentation hierarchy\n hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n // set up RegEx to analyze the provided divs\n // negative lookbehinds unfortunately do not work yet on iPad / Android\n var beginning = '(?<=<br>)(?<!cloze=\")('\n var middle = \".*?)((?:<br>)(?=(\"\n var end = \"))|(?=(<\\/indent>|<\\/div>|<br><br>)))\"\n\n const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n // iterate over divs\n for (const div of divs) {\n   // calculate indentation depths\n   var canvasFont = getCanvasFont(div)\n   var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n   var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n   var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n   var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n   var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n   var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n   var indentEnd = ';\">$1</indent>'\n\n   // do the indentation\n   divHTML = div.outerHTML\n   divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n   divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n   div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\")\n }\n}\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function(type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function(ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n  <script>\n    var tagContainer = document.getElementById(\"tags-container\")\n\n    if (tagContainer.childElementCount == 0) {\n      var tagList = tagContainer.innerHTML.trim().split(\" \");\n      var kbdList = [];\n      var newTagContent = document.createElement(\"div\");\n\n      for (var i = 0; i < tagList.length; i++) {\n        var newTag = document.createElement(\"kbd\");\n        var tag = tagList[i];\n        // numTagLevelsToShow == 0 means the whole tag should be shown\n        if (numTagLevelsToShow != 0) {\n          tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n        }\n\n        // Zankiphil / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n        if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) continue;\n        if (tag.split(\"::\")[1] == \"!NEW_CARDS\") continue;\n        if (tag.split(\"::\")[1] == \"§Projekt_Anki\") continue;\n        if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") continue;\n\n        // improve legibility of tags\n        tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n        tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\");\n        tag = tag.replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n        newTag.innerHTML = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"_\", \" \");\n        newTagContent.append(newTag)\n      }\n\n      tagContainer.innerHTML = newTagContent.innerHTML;\n      tagContainer.style.cursor = \"default\";\n    }\n\n    if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n      tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n    }\n\n    function showtags() {\n      var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n      if (tagContainerShortcut.style.display === \"none\") {\n        tagContainerShortcut.style.display = \"inline\";\n      } else {\n        tagContainerShortcut.style.display = \"none\";\n      }\n    }\n\n    var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n    ankingAddEventListener('keyup', function (e) {\n      if (isShortcut(e)) {\n        toggleHintBtn('hint-tags');\n        showtags();\n      }\n    });\n  </script>\n  <script>\n    for (const tag of document.getElementsByTagName('kbd')) {\n      tag.innerHTML = tag.innerHTML.replace(/::/g, '::<wbr>')\n    }\n  </script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (el.style.display === 'none') {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits( n ) {\n      return (n <= 9 ? \"0\" + n : n); \n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n      \n      if ( msLeft < 1000 ) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date( msLeft );\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout( updateTimer, time.getUTCMilliseconds() + 500 );\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60*minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds ); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function(key, dictionary){\n        return dictionary[key];\n      }\n    }\n    \n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n      \n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n      \n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n/**\n * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n * Full credit to the original authors, except where modified or otherwise indicated.\n */\n\n/**\n *\n * We try to respect that people use various note types\n * which may do 'weird' stuff.\n * Elements may have event listeners that can be removed if we just innerHTML stuff\n * <i> may be styled 'i { display: block }', etc.\n *\n * Another problem that complicate the design of this script is that\n * a word may not be cleanly separated by html tags.\n * e.g. \"A<i>long</i>word\"\n *\n */\n\n(function () {\n  /**\n   * @param {String} text\n   * @returns {number}\n   */\n  function getBoldLength(text) {\n    return Math.floor(text.length / 2);\n  }\n\n  // Ignore node if any of the filters return true\n  const excludeFilters = [\n    (elem) => elem.tagName === \"SCRIPT\",\n    (elem) => elem.tagName === \"STYLE\",\n    (elem) => elem.classList.contains(\"cloze\"),\n  ];\n\n  function newBoldElement(text) {\n    const elem = document.createElement(\"strong\");\n    elem.innerText = text;\n    return elem;\n  }\n\n  function indexOfWhitespace(text, startPos) {\n    const whitespaces = [\n      \" \",\n      \"\\n\",\n      \"\\t\",\n      \" \",\n      \"&nbsp;\",\n      \"‑\",\n      \"-\",\n      \"/\",\n      \"(\",\n      \")\",\n    ];\n    let nextPos = text.length;\n    for (const whitespace of whitespaces) {\n      const next = text.indexOf(whitespace, startPos);\n      if (next !== -1 && next < nextPos) {\n        nextPos = next;\n      }\n    }\n    if (nextPos === text.length) {\n      nextPos = -1;\n    }\n    return nextPos;\n  }\n\n  // Bolds a line of words\n  class BionicReaderBolder {\n    constructor(nodes) {\n      this.nodes = nodes;\n      this.startNodeIndex = 0;\n      this.startPos = 0;\n      this.replaceNodes = [];\n      while (!this.isFinished()) {\n        this.runWithinNode();\n        this.runInterNode();\n      }\n    }\n\n    static run(nodes) {\n      new BionicReaderBolder(nodes);\n    }\n\n    isFinished() {\n      return this.startNodeIndex === this.nodes.length;\n    }\n\n    replaceNode() {\n      const node = this.nodes[this.startNodeIndex];\n      const parent = node.parentNode;\n      for (let add of this.replaceNodes) {\n        parent.insertBefore(add, node);\n      }\n      parent.removeChild(node);\n      this.replaceNodes = [];\n    }\n\n    runWithinNode() {\n      const textContent = this.nodes[this.startNodeIndex].textContent;\n      let nextPos = indexOfWhitespace(textContent, this.startPos);\n      while (nextPos !== -1) {\n        const word = textContent.substring(this.startPos, nextPos);\n        const boldLength = getBoldLength(word);\n        this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n        this.replaceNodes.push(\n          document.createTextNode(\n            word.substring(boldLength, nextPos) + textContent[nextPos]\n          )\n        );\n        this.startPos = nextPos + 1;\n        nextPos = indexOfWhitespace(textContent, this.startPos);\n      }\n    }\n\n    // after this, startPos is likely to be at whitespace char\n    runInterNode() {\n      let word = \"\";\n      let endNodeIndex = this.startNodeIndex;\n      let endPos = this.startPos; // last word char pos + 1\n\n      // Find word boundary\n      while (endNodeIndex < this.nodes.length) {\n        const textContent = this.nodes[endNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, endPos);\n        if (nextPos === -1) {\n          word += textContent.substring(endPos);\n          endNodeIndex += 1;\n          endPos = 0;\n        } else {\n          word += textContent.substring(endPos, nextPos);\n          endPos = nextPos;\n          break;\n        }\n      }\n      // Calculate bold length\n      let remainingBoldLength = getBoldLength(word);\n\n      // Bold part of word\n      while (remainingBoldLength > 0) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        if (remainingBoldLength > textContent.length - this.startPos) {\n          const wordPart = textContent.substring(this.startPos);\n          remainingBoldLength -= wordPart.length;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        } else {\n          const wordPart = textContent.substring(\n            this.startPos,\n            this.startPos + remainingBoldLength\n          );\n          this.startPos += remainingBoldLength;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          remainingBoldLength -= wordPart.length;\n        }\n      }\n\n      // Add non-bolded part of words\n      while (this.startNodeIndex < endNodeIndex) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.replaceNode();\n        this.startNodeIndex += 1;\n        this.startPos = 0;\n      }\n\n      if (this.startPos < endPos) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos, endPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.startPos = endPos;\n      }\n    }\n  }\n\n  /**\n   * Builds a list of (list of nodes that makes up one non-line-broken line)\n   * @param {Node} elem\n   * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n   * @returns {void}\n   */\n  function forTextNodesInTree(elem, nodes, exclude = false) {\n    const children = elem.childNodes;\n    for (const filter of excludeFilters) {\n      if (filter(elem)) {\n        exclude = true;\n        break;\n      }\n    }\n    for (const child of children) {\n      if (child.nodeType === Node.ELEMENT_NODE) {\n        const style = window.getComputedStyle(child);\n        if (\n          child.tagName !== \"BR\" &&\n          (style === \"inline\" || style === \"inline-block\")\n        ) {\n          forTextNodesInTree(child, nodes, exclude);\n        } else {\n          if (nodes[nodes.length - 1].length > 0) {\n            nodes.push([]);\n          }\n          forTextNodesInTree(child, nodes, exclude);\n        }\n      } else if (\n        !exclude &&\n        child.nodeType === Node.TEXT_NODE &&\n        child.textContent.length > 0\n      ) {\n        nodes[nodes.length - 1].push(child);\n      }\n    }\n  }\n\n  function makeBionic() {\n    const cardContainer = document.getElementById(\"container\");\n    cardContainer.normalize();\n\n    let nodesLines = [[]];\n    forTextNodesInTree(cardContainer, nodesLines);\n    for (const nodes of nodesLines) {\n      BionicReaderBolder.run(nodes);\n    }\n\n    cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n      \"<strong></strong>\",\n      \"\"\n    );\n    cardContainer.normalize();\n  }\n\n  let start = performance.now();\n  if (bionicReading) {\n    makeBionic();\n  }\n  let end = performance.now();\n  console.log(`Initialized bionic reading: ${end - start}ms`);\n})();\n</script>\n\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\nvar userJs1 = undefined\nvar userJs2 = undefined\nvar userJs3 = undefined\nvar userJs4 = undefined\nvar userJs5 = undefined\nvar userJs6 = undefined\nvar userJs7 = undefined\nvar userJs8 = undefined\n</script>\n\n\n{{/Markierung 7}}",
      "afmt": "<!-- version 0fd8612 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Eigene Notizen & Bilder\": \"Alt + 1\",\n    \"Eigene Prüfungsfragen\": \"Alt + 2\",\n    \"Definitionen\": \"Alt + 3\",\n    \"Merksprüche\": \"Alt + 4\",\n    \"Klinik\": \"Alt + 5\",\n    \"Präparat\": \"Alt + 6\",\n    \"Memes\": \"Alt + 7\",\n    \"linkContainer\": \"Alt + L\",\n    \"Meditricks\": \"Alt + M\",\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Eigene Notizen & Bilder\": false,\n    \"Eigene Prüfungsfragen\": false,\n    \"Definitionen\": false,\n    \"Merksprüche\": false,\n    \"Klinik\": false,\n    \"Präparat\": false,\n    \"Memes\": false,\n    \"linkContainer\": true,\n    \"Meditricks\": false,\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\":false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\nvar toggleTagsShortcut = \"C\";\n\n// ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\nvar tagID = \"XXXYYYZZZ\"\n\n// WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\nvar numTagLevelsToShow = 0;\n\n// ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\nvar tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n// Enable experimental heuristic indentation feature\nvar indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n// Enable experimental DIVI medication formatting feature\nvar formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n// Enable experimental confounder formatting feature\nvar formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n// Enable bionic reading feature (based on AnKing add-on)\nvar bionicReading = false;\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button\n        id=\"button-tags\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n      >\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button\n        id=\"button-src\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n      >\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button\n        id=\"button-nid\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n      >\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button\n          id=\"button-ankihub\"\n          class=\"button-general\"\n          title=\"Karte in AnkiHub\"\n        >\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) {}\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button\n      id=\"button-tags\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button\n      id=\"button-src\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">Quelle: {{Quelle}}</div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button\n      id=\"button-nid\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    <i>Was</i> wird hier bei <b>⑦</b> gezeigt?\n\n    <br>\n    <br>\n\n    {{#Hint / Hinweis}}\n      <span style=\"color:IndianRed; font-weight: bold;\">Hinweis:</span> {{hint:Hint / Hinweis}}\n\n      <br>\n      <br>\n    {{/Hint / Hinweis}}\n    \n    {{Bild}}\n\n    <br>\n    <br>\n\n    <span class=\"cloze\">{{Markierung 7}}</span>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- BUTTON FIELDS -->\n    {{#Eigene Notizen & Bilder}}\n  <span id=\"hint-zusatz\" class=\"hintBtn\" data-name=\"Eigene Notizen & Bilder\" style=\"display: none;\">\n    <button id=\"button-zusatz\" class=\"button-general\" onclick=\"toggleHintBtn('hint-zusatz'); event.stopPropagation()\">\n      <img src=\"__zusatz.svg\" style=\"height: 10px;\"> Eigene Notizen & Bilder\n    </button>\n    <div id=\"zusatz\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Notizen & Bilder}}</div>\n  </span>\n{{/Eigene Notizen & Bilder}}\n\n    {{#Eigene Prüfungsfragen}}\n  <span id=\"hint-hammer\" class=\"hintBtn\" data-name=\"Eigene Prüfungsfragen\" style=\"display: none;\">\n    <button id=\"button-hammer\" class=\"button-general\" onclick=\"toggleHintBtn('hint-hammer'); event.stopPropagation()\">\n      <img src=\"__hammer.svg\" style=\"height: 10px;\"> Eigene Prüfungsfragen\n    </button>\n    <div id=\"hammer\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Prüfungsfragen}}</div>\n  </span>\n{{/Eigene Prüfungsfragen}}\n\n    {{#Definitionen}}\n  <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Definitionen\" style=\"display: none;\">\n    <button id=\"button-definition\" class=\"button-general\" onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n      <img src=\"__explanation.svg\" style=\"height: 10px;\"> Definitionen\n    </button>\n    <div id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Definitionen}}</div>\n  </span>\n{{/Definitionen}}\n\n    {{#Merksprüche}}\n  <span id=\"hint-merksprueche\" class=\"hintBtn\" data-name=\"Merksprüche\" style=\"display: none;\">\n    <button id=\"button-merksprueche\" class=\"button-general\" onclick=\"toggleHintBtn('hint-merksprueche'); event.stopPropagation()\">\n      <img src=\"__merkhilfe.svg\" style=\"height: 10px;\"> Merksprüche\n    </button>\n    <div id=\"merksprueche\" class=\"hints\" style=\"display: none;\">{{edit:Merksprüche}}</div>\n  </span>\n{{/Merksprüche}}\n\n    {{#Klinik}}\n  <span id=\"hint-klinik\" class=\"hintBtn\" data-name=\"Klinik\" style=\"display: none;\">\n    <button id=\"button-klinik\" class=\"button-general\" onclick=\"toggleHintBtn('hint-klinik'); event.stopPropagation()\">\n      <img src=\"__stethoscope.svg\" style=\"height: 10px;\"> Klinik\n    </button>\n    <div id=\"klinik\" class=\"hints\" style=\"display: none;\">{{edit:Klinik}}</div>\n  </span>\n{{/Klinik}}\n\n    {{#Präparat}}\n      <span id=\"hint-praeparat-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Präparat}}\">\n          <button id=\"button-praeparat\" class=\"button-general\">\n            <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n          </button>\n        </a>\n      </span>\n    {{/Präparat}}\n\n    {{#Virtuelle Mikroskopie}}\n      <span id=\"hint-microscope-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Virtuelle Mikroskopie}}\">\n          <button id=\"button-microscope\" class=\"button-general\">\n            <img src=\"__microscope.svg\" style=\"height: 10px;\"> Virtuelle Mikroskopie\n          </button>\n        </a>\n      </span>\n    {{/Virtuelle Mikroskopie}}\n\n    {{#Smart Zoom}}\n      <span id=\"hint-smartzoom-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Präparat}}\">\n          <button id=\"button-smartzoom\" class=\"button-general\">\n            <img src=\"__microscope.svg\" style=\"height: 10px;\"> Smart Zoom\n          </button>\n        </a>\n      </span>\n    {{/Smart Zoom}}\n\n    {{#HistoTrainer}}\n  <span id=\"hint-praeparat\" class=\"hintBtn\" data-name=\"HistoTrainer\" style=\"display: none;\">\n    <button id=\"button-praeparat\" class=\"button-general\" onclick=\"toggleHintBtn('hint-praeparat'); event.stopPropagation()\">\n      <img src=\"__microscope.svg\" style=\"height: 10px;\"> HistoTrainer\n    </button>\n    <div id=\"praeparat\" class=\"hints\" style=\"display: none;\">{{edit:HistoTrainer}}</div>\n  </span>\n{{/HistoTrainer}}\n\n    {{#Memes}}\n  <span id=\"hint-memes\" class=\"hintBtn\" data-name=\"Memes\" style=\"display: none;\">\n    <button id=\"button-memes\" class=\"button-general\" onclick=\"toggleHintBtn('hint-memes'); event.stopPropagation()\">\n      <img src=\"__sonstiges.svg\" style=\"height: 10px;\"> Memes\n    </button>\n    <div id=\"memes\" class=\"hints\" style=\"display: none;\">{{edit:Memes}}</div>\n  </span>\n{{/Memes}}\n\n    <!-- Extra field -->\n    {{#Extra}}\n      <div id=\"extra\" style=\"display: none;\">\n        <br><br>{{edit:Extra}}</div>\n    {{/Extra}}\n\n    {{#AMBOSS-Link}}\n      <span id=\"hint-amboss\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:AMBOSS-Link}}\">\n          <button id=\"button-amboss\" class=\"button-general\">\n            <img src=\"__amboss.svg\" style=\"height: 10px;\"> AMBOSS&#8203;\n          </button>\n        </a>\n      </span>\n    {{/AMBOSS-Link}}\n    \n    {{#Thieme via medici-Link}}\n      <span id=\"hint-thieme\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Thieme via medici-Link}}\">\n          <button id=\"button-thieme\" class=\"button-general\">\n            <img id=\"button-thieme-img\" src=\"__thieme-heart.svg\" style=\"height: 10px;\"> Thieme via medici\n          </button>\n        </a>\n      </span>\n    {{/Thieme via medici-Link}}\n\n    {{#Meditricks}}\n  <span id=\"hint-meditricks\" class=\"hintBtn\" data-name=\"Meditricks\" style=\"display: none;\">\n    <button id=\"button-meditricks\" class=\"button-general\" onclick=\"toggleHintBtn('hint-meditricks'); event.stopPropagation()\">\n      <img src=\"__meditricks.svg\" style=\"height: 10px;\"> Meditricks\n    </button>\n    <div id=\"meditricks\" class=\"hints\" style=\"display: none;\">{{edit:Meditricks}}</div>\n  </span>\n{{/Meditricks}}\n\n    {{#weitere Links}}\n    <span id=\"hint-linkcontainer\" class=\"hintBtn\" data-name=\"linkContainer\" style=\"display: none;\">\n      <button id=\"button-linkcontainer\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-linkcontainer'); event.stopPropagation()\">\n        <img src=\"__internet.svg\" style=\"height: 10px;\"> weitere Links\n      </button>\n      <div id=\"linkcontainer\" class=\"hints\" style=\"display: none;\"></div>\n      <span id=\"linkContainerLinks\" style=\"display: none;\">{{edit:weitere Links}}</span>\n    </span>\n  {{/weitere Links}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function(type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function(ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n  <script>\n    var tagContainer = document.getElementById(\"tags-container\")\n\n    if (tagContainer.childElementCount == 0) {\n      var tagList = tagContainer.innerHTML.trim().split(\" \");\n      var kbdList = [];\n      var newTagContent = document.createElement(\"div\");\n\n      for (var i = 0; i < tagList.length; i++) {\n        var newTag = document.createElement(\"kbd\");\n        var tag = tagList[i];\n        // numTagLevelsToShow == 0 means the whole tag should be shown\n        if (numTagLevelsToShow != 0) {\n          tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n        }\n\n        // Zankiphil / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n        if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) continue;\n        if (tag.split(\"::\")[1] == \"!NEW_CARDS\") continue;\n        if (tag.split(\"::\")[1] == \"§Projekt_Anki\") continue;\n        if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") continue;\n\n        // improve legibility of tags\n        tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n        tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\");\n        tag = tag.replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n        newTag.innerHTML = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"_\", \" \");\n        newTagContent.append(newTag)\n      }\n\n      tagContainer.innerHTML = newTagContent.innerHTML;\n      tagContainer.style.cursor = \"default\";\n    }\n\n    if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n      tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n    }\n\n    function showtags() {\n      var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n      if (tagContainerShortcut.style.display === \"none\") {\n        tagContainerShortcut.style.display = \"inline\";\n      } else {\n        tagContainerShortcut.style.display = \"none\";\n      }\n    }\n\n    var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n    ankingAddEventListener('keyup', function (e) {\n      if (isShortcut(e)) {\n        toggleHintBtn('hint-tags');\n        showtags();\n      }\n    });\n  </script>\n  <script>\n    for (const tag of document.getElementsByTagName('kbd')) {\n      tag.innerHTML = tag.innerHTML.replace(/::/g, '::<wbr>')\n    }\n  </script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (el.style.display === 'none') {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n    try {\n        for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n            href = link.href\n            text = link.innerText\n\n            const el = document.createElement('a');\n            el.setAttribute('href', link.href);\n\n            const btn = document.createElement('button');\n            btn.classList.add('button-general');\n            btn.classList.add('expanded-button');\n\n            domain = href.replace(/.+\\/\\/|(www|flexikon|de|next|com).|\\..+/g, '');\n            domainDict = {\n                \"amboss\": \"__amboss.svg\",\n                \"wikipedia\": \"__wikipedia.svg\",\n                \"doccheck\": \"__doccheck.png\",\n                \"notfallguru\": \"__notfallguru.svg\",\n            }\n            if (domain in domainDict) {\n                icon = domainDict[domain]\n            } else {\n                icon = \"__internet.svg\"\n            }\n\n            const img = document.createElement('img');\n            img.setAttribute('src', icon);\n            img.setAttribute('style', 'height: 10px;');\n\n            btn.appendChild(img);\n            btn.innerHTML = btn.innerHTML + \" \" + text;\n\n            el.appendChild(btn);\n\n            document.getElementById(\"linkcontainer\").appendChild(el)\n        }\n    }\n    catch (err) {\n        console.log(err)\n    }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\nfunction getTextWidth(text, font) {\n // re-use canvas object for better performance\n const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n const context = canvas.getContext(\"2d\");\n context.font = font;\n const metrics = context.measureText(text);\n return metrics.width;\n}\n\nfunction getCSSStyle(element, prop) {\n return window.getComputedStyle(element, null).getPropertyValue(prop);\n}\n\nfunction getCanvasFont(el = document.body) {\n const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n const fontSize = getCSSStyle(el, 'font-size') || '16px';\n const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n return `${fontWeight} ${fontSize} ${fontFamily}`;\n}\n\n/**\n* Iterates over a list of divs containing text to be indented\n*\n* @param {HTMLCollection} divs: The divs to be iterated over.\n*/\nfunction indentText(divs) {\n // setup the indentation markers\n var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n var bulletP = \"•\"\n var minus = \"– \"\n var enter = \"↳(?!( ↳|↳))\"\n var arrow = \"→\"\n\n // heuristic indentation hierarchy\n hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n // set up RegEx to analyze the provided divs\n // negative lookbehinds unfortunately do not work yet on iPad / Android\n var beginning = '(?<=<br>)(?<!cloze=\")('\n var middle = \".*?)((?:<br>)(?=(\"\n var end = \"))|(?=(<\\/indent>|<\\/div>|<br><br>)))\"\n\n const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n // iterate over divs\n for (const div of divs) {\n   // calculate indentation depths\n   var canvasFont = getCanvasFont(div)\n   var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n   var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n   var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n   var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n   var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n   var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n   var indentEnd = ';\">$1</indent>'\n\n   // do the indentation\n   divHTML = div.outerHTML\n   divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n   divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n   div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\")\n }\n}\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits( n ) {\n      return (n <= 9 ? \"0\" + n : n); \n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n      \n      if ( msLeft < 1000 ) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date( msLeft );\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout( updateTimer, time.getUTCMilliseconds() + 500 );\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60*minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds ); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function(key, dictionary){\n        return dictionary[key];\n      }\n    }\n    \n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n      \n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n      \n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n/**\n * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n * Full credit to the original authors, except where modified or otherwise indicated.\n */\n\n/**\n *\n * We try to respect that people use various note types\n * which may do 'weird' stuff.\n * Elements may have event listeners that can be removed if we just innerHTML stuff\n * <i> may be styled 'i { display: block }', etc.\n *\n * Another problem that complicate the design of this script is that\n * a word may not be cleanly separated by html tags.\n * e.g. \"A<i>long</i>word\"\n *\n */\n\n(function () {\n  /**\n   * @param {String} text\n   * @returns {number}\n   */\n  function getBoldLength(text) {\n    return Math.floor(text.length / 2);\n  }\n\n  // Ignore node if any of the filters return true\n  const excludeFilters = [\n    (elem) => elem.tagName === \"SCRIPT\",\n    (elem) => elem.tagName === \"STYLE\",\n    (elem) => elem.classList.contains(\"cloze\"),\n  ];\n\n  function newBoldElement(text) {\n    const elem = document.createElement(\"strong\");\n    elem.innerText = text;\n    return elem;\n  }\n\n  function indexOfWhitespace(text, startPos) {\n    const whitespaces = [\n      \" \",\n      \"\\n\",\n      \"\\t\",\n      \" \",\n      \"&nbsp;\",\n      \"‑\",\n      \"-\",\n      \"/\",\n      \"(\",\n      \")\",\n    ];\n    let nextPos = text.length;\n    for (const whitespace of whitespaces) {\n      const next = text.indexOf(whitespace, startPos);\n      if (next !== -1 && next < nextPos) {\n        nextPos = next;\n      }\n    }\n    if (nextPos === text.length) {\n      nextPos = -1;\n    }\n    return nextPos;\n  }\n\n  // Bolds a line of words\n  class BionicReaderBolder {\n    constructor(nodes) {\n      this.nodes = nodes;\n      this.startNodeIndex = 0;\n      this.startPos = 0;\n      this.replaceNodes = [];\n      while (!this.isFinished()) {\n        this.runWithinNode();\n        this.runInterNode();\n      }\n    }\n\n    static run(nodes) {\n      new BionicReaderBolder(nodes);\n    }\n\n    isFinished() {\n      return this.startNodeIndex === this.nodes.length;\n    }\n\n    replaceNode() {\n      const node = this.nodes[this.startNodeIndex];\n      const parent = node.parentNode;\n      for (let add of this.replaceNodes) {\n        parent.insertBefore(add, node);\n      }\n      parent.removeChild(node);\n      this.replaceNodes = [];\n    }\n\n    runWithinNode() {\n      const textContent = this.nodes[this.startNodeIndex].textContent;\n      let nextPos = indexOfWhitespace(textContent, this.startPos);\n      while (nextPos !== -1) {\n        const word = textContent.substring(this.startPos, nextPos);\n        const boldLength = getBoldLength(word);\n        this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n        this.replaceNodes.push(\n          document.createTextNode(\n            word.substring(boldLength, nextPos) + textContent[nextPos]\n          )\n        );\n        this.startPos = nextPos + 1;\n        nextPos = indexOfWhitespace(textContent, this.startPos);\n      }\n    }\n\n    // after this, startPos is likely to be at whitespace char\n    runInterNode() {\n      let word = \"\";\n      let endNodeIndex = this.startNodeIndex;\n      let endPos = this.startPos; // last word char pos + 1\n\n      // Find word boundary\n      while (endNodeIndex < this.nodes.length) {\n        const textContent = this.nodes[endNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, endPos);\n        if (nextPos === -1) {\n          word += textContent.substring(endPos);\n          endNodeIndex += 1;\n          endPos = 0;\n        } else {\n          word += textContent.substring(endPos, nextPos);\n          endPos = nextPos;\n          break;\n        }\n      }\n      // Calculate bold length\n      let remainingBoldLength = getBoldLength(word);\n\n      // Bold part of word\n      while (remainingBoldLength > 0) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        if (remainingBoldLength > textContent.length - this.startPos) {\n          const wordPart = textContent.substring(this.startPos);\n          remainingBoldLength -= wordPart.length;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        } else {\n          const wordPart = textContent.substring(\n            this.startPos,\n            this.startPos + remainingBoldLength\n          );\n          this.startPos += remainingBoldLength;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          remainingBoldLength -= wordPart.length;\n        }\n      }\n\n      // Add non-bolded part of words\n      while (this.startNodeIndex < endNodeIndex) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.replaceNode();\n        this.startNodeIndex += 1;\n        this.startPos = 0;\n      }\n\n      if (this.startPos < endPos) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos, endPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.startPos = endPos;\n      }\n    }\n  }\n\n  /**\n   * Builds a list of (list of nodes that makes up one non-line-broken line)\n   * @param {Node} elem\n   * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n   * @returns {void}\n   */\n  function forTextNodesInTree(elem, nodes, exclude = false) {\n    const children = elem.childNodes;\n    for (const filter of excludeFilters) {\n      if (filter(elem)) {\n        exclude = true;\n        break;\n      }\n    }\n    for (const child of children) {\n      if (child.nodeType === Node.ELEMENT_NODE) {\n        const style = window.getComputedStyle(child);\n        if (\n          child.tagName !== \"BR\" &&\n          (style === \"inline\" || style === \"inline-block\")\n        ) {\n          forTextNodesInTree(child, nodes, exclude);\n        } else {\n          if (nodes[nodes.length - 1].length > 0) {\n            nodes.push([]);\n          }\n          forTextNodesInTree(child, nodes, exclude);\n        }\n      } else if (\n        !exclude &&\n        child.nodeType === Node.TEXT_NODE &&\n        child.textContent.length > 0\n      ) {\n        nodes[nodes.length - 1].push(child);\n      }\n    }\n  }\n\n  function makeBionic() {\n    const cardContainer = document.getElementById(\"container\");\n    cardContainer.normalize();\n\n    let nodesLines = [[]];\n    forTextNodesInTree(cardContainer, nodesLines);\n    for (const nodes of nodesLines) {\n      BionicReaderBolder.run(nodes);\n    }\n\n    cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n      \"<strong></strong>\",\n      \"\"\n    );\n    cardContainer.normalize();\n  }\n\n  let start = performance.now();\n  if (bionicReading) {\n    makeBionic();\n  }\n  let end = performance.now();\n  console.log(`Initialized bionic reading: ${end - start}ms`);\n})();\n</script>\n\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\nvar userJs1 = undefined\nvar userJs2 = undefined\nvar userJs3 = undefined\nvar userJs4 = undefined\nvar userJs5 = undefined\nvar userJs6 = undefined\nvar userJs7 = undefined\nvar userJs8 = undefined\n</script>\n",
      "bqfmt": "{{Titel}}",
      "bafmt": "{{Markierung 7}}",
      "did": null,
      "bfont": "Helvetica",
      "bsize": 12
    },
    {
      "name": "Markierung 8",
      "ord": 7,
      "qfmt": "<!-- version 0fd8612 -->\n{{#Markierung 8}}\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TIMER CONFIG  ##############\n// Timer config (timer length, timer finished message)\nvar minutes =  0\nvar seconds = 15\nvar timeOverMsg = \"<span style='color:#CC5B5B'>!!!</span>\"\n\n  // ##############  TAG SHORTCUT  ##############\nvar toggleTagsShortcut = \"C\";\n\n// ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\nvar tagID = \"XXXYYYZZZ\"\n\n// WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\nvar numTagLevelsToShow = 0;\n\n// ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\nvar tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n// Enable experimental heuristic indentation feature\nvar indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n// Enable experimental DIVI medication formatting feature\nvar formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n// Enable experimental confounder formatting feature\nvar formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n// Enable bionic reading feature (based on AnKing add-on)\nvar bionicReading = false;\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button\n        id=\"button-tags\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n      >\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button\n        id=\"button-src\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n      >\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button\n        id=\"button-nid\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n      >\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button\n          id=\"button-ankihub\"\n          class=\"button-general\"\n          title=\"Karte in AnkiHub\"\n        >\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) {}\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button\n      id=\"button-tags\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button\n      id=\"button-src\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">Quelle: {{Quelle}}</div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button\n      id=\"button-nid\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    <i>Was</i> wird hier bei <b>⑧</b> gezeigt?\n\n    <br>\n    <br>\n\n    {{#Hint / Hinweis}}\n      <span style=\"color:IndianRed; font-weight: bold;\">Hinweis:</span> {{hint:Hint / Hinweis}}\n\n      <br>\n      <br>\n    {{/Hint / Hinweis}}\n    \n    {{Bild}}\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\"></div>\n\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n<script>\n  //DONT FADE BETWEEN CARDS\n  qFade = 0;\n  if (typeof anki !== 'undefined') anki.qFade = qFade;\n</script>\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\nfunction getTextWidth(text, font) {\n // re-use canvas object for better performance\n const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n const context = canvas.getContext(\"2d\");\n context.font = font;\n const metrics = context.measureText(text);\n return metrics.width;\n}\n\nfunction getCSSStyle(element, prop) {\n return window.getComputedStyle(element, null).getPropertyValue(prop);\n}\n\nfunction getCanvasFont(el = document.body) {\n const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n const fontSize = getCSSStyle(el, 'font-size') || '16px';\n const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n return `${fontWeight} ${fontSize} ${fontFamily}`;\n}\n\n/**\n* Iterates over a list of divs containing text to be indented\n*\n* @param {HTMLCollection} divs: The divs to be iterated over.\n*/\nfunction indentText(divs) {\n // setup the indentation markers\n var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n var bulletP = \"•\"\n var minus = \"– \"\n var enter = \"↳(?!( ↳|↳))\"\n var arrow = \"→\"\n\n // heuristic indentation hierarchy\n hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n // set up RegEx to analyze the provided divs\n // negative lookbehinds unfortunately do not work yet on iPad / Android\n var beginning = '(?<=<br>)(?<!cloze=\")('\n var middle = \".*?)((?:<br>)(?=(\"\n var end = \"))|(?=(<\\/indent>|<\\/div>|<br><br>)))\"\n\n const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n // iterate over divs\n for (const div of divs) {\n   // calculate indentation depths\n   var canvasFont = getCanvasFont(div)\n   var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n   var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n   var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n   var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n   var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n   var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n   var indentEnd = ';\">$1</indent>'\n\n   // do the indentation\n   divHTML = div.outerHTML\n   divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n   divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n   div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\")\n }\n}\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function(type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function(ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n  <script>\n    var tagContainer = document.getElementById(\"tags-container\")\n\n    if (tagContainer.childElementCount == 0) {\n      var tagList = tagContainer.innerHTML.trim().split(\" \");\n      var kbdList = [];\n      var newTagContent = document.createElement(\"div\");\n\n      for (var i = 0; i < tagList.length; i++) {\n        var newTag = document.createElement(\"kbd\");\n        var tag = tagList[i];\n        // numTagLevelsToShow == 0 means the whole tag should be shown\n        if (numTagLevelsToShow != 0) {\n          tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n        }\n\n        // Zankiphil / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n        if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) continue;\n        if (tag.split(\"::\")[1] == \"!NEW_CARDS\") continue;\n        if (tag.split(\"::\")[1] == \"§Projekt_Anki\") continue;\n        if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") continue;\n\n        // improve legibility of tags\n        tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n        tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\");\n        tag = tag.replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n        newTag.innerHTML = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"_\", \" \");\n        newTagContent.append(newTag)\n      }\n\n      tagContainer.innerHTML = newTagContent.innerHTML;\n      tagContainer.style.cursor = \"default\";\n    }\n\n    if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n      tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n    }\n\n    function showtags() {\n      var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n      if (tagContainerShortcut.style.display === \"none\") {\n        tagContainerShortcut.style.display = \"inline\";\n      } else {\n        tagContainerShortcut.style.display = \"none\";\n      }\n    }\n\n    var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n    ankingAddEventListener('keyup', function (e) {\n      if (isShortcut(e)) {\n        toggleHintBtn('hint-tags');\n        showtags();\n      }\n    });\n  </script>\n  <script>\n    for (const tag of document.getElementsByTagName('kbd')) {\n      tag.innerHTML = tag.innerHTML.replace(/::/g, '::<wbr>')\n    }\n  </script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (el.style.display === 'none') {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits( n ) {\n      return (n <= 9 ? \"0\" + n : n); \n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n      \n      if ( msLeft < 1000 ) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date( msLeft );\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout( updateTimer, time.getUTCMilliseconds() + 500 );\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60*minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds ); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function(key, dictionary){\n        return dictionary[key];\n      }\n    }\n    \n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n      \n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n      \n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n/**\n * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n * Full credit to the original authors, except where modified or otherwise indicated.\n */\n\n/**\n *\n * We try to respect that people use various note types\n * which may do 'weird' stuff.\n * Elements may have event listeners that can be removed if we just innerHTML stuff\n * <i> may be styled 'i { display: block }', etc.\n *\n * Another problem that complicate the design of this script is that\n * a word may not be cleanly separated by html tags.\n * e.g. \"A<i>long</i>word\"\n *\n */\n\n(function () {\n  /**\n   * @param {String} text\n   * @returns {number}\n   */\n  function getBoldLength(text) {\n    return Math.floor(text.length / 2);\n  }\n\n  // Ignore node if any of the filters return true\n  const excludeFilters = [\n    (elem) => elem.tagName === \"SCRIPT\",\n    (elem) => elem.tagName === \"STYLE\",\n    (elem) => elem.classList.contains(\"cloze\"),\n  ];\n\n  function newBoldElement(text) {\n    const elem = document.createElement(\"strong\");\n    elem.innerText = text;\n    return elem;\n  }\n\n  function indexOfWhitespace(text, startPos) {\n    const whitespaces = [\n      \" \",\n      \"\\n\",\n      \"\\t\",\n      \" \",\n      \"&nbsp;\",\n      \"‑\",\n      \"-\",\n      \"/\",\n      \"(\",\n      \")\",\n    ];\n    let nextPos = text.length;\n    for (const whitespace of whitespaces) {\n      const next = text.indexOf(whitespace, startPos);\n      if (next !== -1 && next < nextPos) {\n        nextPos = next;\n      }\n    }\n    if (nextPos === text.length) {\n      nextPos = -1;\n    }\n    return nextPos;\n  }\n\n  // Bolds a line of words\n  class BionicReaderBolder {\n    constructor(nodes) {\n      this.nodes = nodes;\n      this.startNodeIndex = 0;\n      this.startPos = 0;\n      this.replaceNodes = [];\n      while (!this.isFinished()) {\n        this.runWithinNode();\n        this.runInterNode();\n      }\n    }\n\n    static run(nodes) {\n      new BionicReaderBolder(nodes);\n    }\n\n    isFinished() {\n      return this.startNodeIndex === this.nodes.length;\n    }\n\n    replaceNode() {\n      const node = this.nodes[this.startNodeIndex];\n      const parent = node.parentNode;\n      for (let add of this.replaceNodes) {\n        parent.insertBefore(add, node);\n      }\n      parent.removeChild(node);\n      this.replaceNodes = [];\n    }\n\n    runWithinNode() {\n      const textContent = this.nodes[this.startNodeIndex].textContent;\n      let nextPos = indexOfWhitespace(textContent, this.startPos);\n      while (nextPos !== -1) {\n        const word = textContent.substring(this.startPos, nextPos);\n        const boldLength = getBoldLength(word);\n        this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n        this.replaceNodes.push(\n          document.createTextNode(\n            word.substring(boldLength, nextPos) + textContent[nextPos]\n          )\n        );\n        this.startPos = nextPos + 1;\n        nextPos = indexOfWhitespace(textContent, this.startPos);\n      }\n    }\n\n    // after this, startPos is likely to be at whitespace char\n    runInterNode() {\n      let word = \"\";\n      let endNodeIndex = this.startNodeIndex;\n      let endPos = this.startPos; // last word char pos + 1\n\n      // Find word boundary\n      while (endNodeIndex < this.nodes.length) {\n        const textContent = this.nodes[endNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, endPos);\n        if (nextPos === -1) {\n          word += textContent.substring(endPos);\n          endNodeIndex += 1;\n          endPos = 0;\n        } else {\n          word += textContent.substring(endPos, nextPos);\n          endPos = nextPos;\n          break;\n        }\n      }\n      // Calculate bold length\n      let remainingBoldLength = getBoldLength(word);\n\n      // Bold part of word\n      while (remainingBoldLength > 0) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        if (remainingBoldLength > textContent.length - this.startPos) {\n          const wordPart = textContent.substring(this.startPos);\n          remainingBoldLength -= wordPart.length;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        } else {\n          const wordPart = textContent.substring(\n            this.startPos,\n            this.startPos + remainingBoldLength\n          );\n          this.startPos += remainingBoldLength;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          remainingBoldLength -= wordPart.length;\n        }\n      }\n\n      // Add non-bolded part of words\n      while (this.startNodeIndex < endNodeIndex) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.replaceNode();\n        this.startNodeIndex += 1;\n        this.startPos = 0;\n      }\n\n      if (this.startPos < endPos) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos, endPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.startPos = endPos;\n      }\n    }\n  }\n\n  /**\n   * Builds a list of (list of nodes that makes up one non-line-broken line)\n   * @param {Node} elem\n   * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n   * @returns {void}\n   */\n  function forTextNodesInTree(elem, nodes, exclude = false) {\n    const children = elem.childNodes;\n    for (const filter of excludeFilters) {\n      if (filter(elem)) {\n        exclude = true;\n        break;\n      }\n    }\n    for (const child of children) {\n      if (child.nodeType === Node.ELEMENT_NODE) {\n        const style = window.getComputedStyle(child);\n        if (\n          child.tagName !== \"BR\" &&\n          (style === \"inline\" || style === \"inline-block\")\n        ) {\n          forTextNodesInTree(child, nodes, exclude);\n        } else {\n          if (nodes[nodes.length - 1].length > 0) {\n            nodes.push([]);\n          }\n          forTextNodesInTree(child, nodes, exclude);\n        }\n      } else if (\n        !exclude &&\n        child.nodeType === Node.TEXT_NODE &&\n        child.textContent.length > 0\n      ) {\n        nodes[nodes.length - 1].push(child);\n      }\n    }\n  }\n\n  function makeBionic() {\n    const cardContainer = document.getElementById(\"container\");\n    cardContainer.normalize();\n\n    let nodesLines = [[]];\n    forTextNodesInTree(cardContainer, nodesLines);\n    for (const nodes of nodesLines) {\n      BionicReaderBolder.run(nodes);\n    }\n\n    cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n      \"<strong></strong>\",\n      \"\"\n    );\n    cardContainer.normalize();\n  }\n\n  let start = performance.now();\n  if (bionicReading) {\n    makeBionic();\n  }\n  let end = performance.now();\n  console.log(`Initialized bionic reading: ${end - start}ms`);\n})();\n</script>\n\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\nvar userJs1 = undefined\nvar userJs2 = undefined\nvar userJs3 = undefined\nvar userJs4 = undefined\nvar userJs5 = undefined\nvar userJs6 = undefined\nvar userJs7 = undefined\nvar userJs8 = undefined\n</script>\n\n\n{{/Markierung 8}}",
      "afmt": "<!-- version 0fd8612 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Eigene Notizen & Bilder\": \"Alt + 1\",\n    \"Eigene Prüfungsfragen\": \"Alt + 2\",\n    \"Definitionen\": \"Alt + 3\",\n    \"Merksprüche\": \"Alt + 4\",\n    \"Klinik\": \"Alt + 5\",\n    \"Präparat\": \"Alt + 6\",\n    \"Memes\": \"Alt + 7\",\n    \"linkContainer\": \"Alt + L\",\n    \"Meditricks\": \"Alt + M\",\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Eigene Notizen & Bilder\": false,\n    \"Eigene Prüfungsfragen\": false,\n    \"Definitionen\": false,\n    \"Merksprüche\": false,\n    \"Klinik\": false,\n    \"Präparat\": false,\n    \"Memes\": false,\n    \"linkContainer\": true,\n    \"Meditricks\": false,\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\":false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\nvar toggleTagsShortcut = \"C\";\n\n// ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\nvar tagID = \"XXXYYYZZZ\"\n\n// WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\nvar numTagLevelsToShow = 0;\n\n// ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\nvar tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n// Enable experimental heuristic indentation feature\nvar indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n// Enable experimental DIVI medication formatting feature\nvar formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n// Enable experimental confounder formatting feature\nvar formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n// Enable bionic reading feature (based on AnKing add-on)\nvar bionicReading = false;\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button\n        id=\"button-tags\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n      >\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button\n        id=\"button-src\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n      >\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button\n        id=\"button-nid\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n      >\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button\n          id=\"button-ankihub\"\n          class=\"button-general\"\n          title=\"Karte in AnkiHub\"\n        >\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) {}\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button\n      id=\"button-tags\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button\n      id=\"button-src\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">Quelle: {{Quelle}}</div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button\n      id=\"button-nid\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    <i>Was</i> wird hier bei <b>⑧</b> gezeigt?\n\n    <br>\n    <br>\n\n    {{#Hint / Hinweis}}\n      <span style=\"color:IndianRed; font-weight: bold;\">Hinweis:</span> {{hint:Hint / Hinweis}}\n\n      <br>\n      <br>\n    {{/Hint / Hinweis}}\n    \n    {{Bild}}\n\n    <br>\n    <br>\n\n    <span class=\"cloze\">{{Markierung 8}}</span>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- BUTTON FIELDS -->\n    {{#Eigene Notizen & Bilder}}\n  <span id=\"hint-zusatz\" class=\"hintBtn\" data-name=\"Eigene Notizen & Bilder\" style=\"display: none;\">\n    <button id=\"button-zusatz\" class=\"button-general\" onclick=\"toggleHintBtn('hint-zusatz'); event.stopPropagation()\">\n      <img src=\"__zusatz.svg\" style=\"height: 10px;\"> Eigene Notizen & Bilder\n    </button>\n    <div id=\"zusatz\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Notizen & Bilder}}</div>\n  </span>\n{{/Eigene Notizen & Bilder}}\n\n    {{#Eigene Prüfungsfragen}}\n  <span id=\"hint-hammer\" class=\"hintBtn\" data-name=\"Eigene Prüfungsfragen\" style=\"display: none;\">\n    <button id=\"button-hammer\" class=\"button-general\" onclick=\"toggleHintBtn('hint-hammer'); event.stopPropagation()\">\n      <img src=\"__hammer.svg\" style=\"height: 10px;\"> Eigene Prüfungsfragen\n    </button>\n    <div id=\"hammer\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Prüfungsfragen}}</div>\n  </span>\n{{/Eigene Prüfungsfragen}}\n\n    {{#Definitionen}}\n  <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Definitionen\" style=\"display: none;\">\n    <button id=\"button-definition\" class=\"button-general\" onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n      <img src=\"__explanation.svg\" style=\"height: 10px;\"> Definitionen\n    </button>\n    <div id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Definitionen}}</div>\n  </span>\n{{/Definitionen}}\n\n    {{#Merksprüche}}\n  <span id=\"hint-merksprueche\" class=\"hintBtn\" data-name=\"Merksprüche\" style=\"display: none;\">\n    <button id=\"button-merksprueche\" class=\"button-general\" onclick=\"toggleHintBtn('hint-merksprueche'); event.stopPropagation()\">\n      <img src=\"__merkhilfe.svg\" style=\"height: 10px;\"> Merksprüche\n    </button>\n    <div id=\"merksprueche\" class=\"hints\" style=\"display: none;\">{{edit:Merksprüche}}</div>\n  </span>\n{{/Merksprüche}}\n\n    {{#Klinik}}\n  <span id=\"hint-klinik\" class=\"hintBtn\" data-name=\"Klinik\" style=\"display: none;\">\n    <button id=\"button-klinik\" class=\"button-general\" onclick=\"toggleHintBtn('hint-klinik'); event.stopPropagation()\">\n      <img src=\"__stethoscope.svg\" style=\"height: 10px;\"> Klinik\n    </button>\n    <div id=\"klinik\" class=\"hints\" style=\"display: none;\">{{edit:Klinik}}</div>\n  </span>\n{{/Klinik}}\n\n    {{#Präparat}}\n      <span id=\"hint-praeparat-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Präparat}}\">\n          <button id=\"button-praeparat\" class=\"button-general\">\n            <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n          </button>\n        </a>\n      </span>\n    {{/Präparat}}\n\n    {{#Virtuelle Mikroskopie}}\n      <span id=\"hint-microscope-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Virtuelle Mikroskopie}}\">\n          <button id=\"button-microscope\" class=\"button-general\">\n            <img src=\"__microscope.svg\" style=\"height: 10px;\"> Virtuelle Mikroskopie\n          </button>\n        </a>\n      </span>\n    {{/Virtuelle Mikroskopie}}\n\n    {{#Smart Zoom}}\n      <span id=\"hint-smartzoom-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Präparat}}\">\n          <button id=\"button-smartzoom\" class=\"button-general\">\n            <img src=\"__microscope.svg\" style=\"height: 10px;\"> Smart Zoom\n          </button>\n        </a>\n      </span>\n    {{/Smart Zoom}}\n\n    {{#HistoTrainer}}\n  <span id=\"hint-praeparat\" class=\"hintBtn\" data-name=\"HistoTrainer\" style=\"display: none;\">\n    <button id=\"button-praeparat\" class=\"button-general\" onclick=\"toggleHintBtn('hint-praeparat'); event.stopPropagation()\">\n      <img src=\"__microscope.svg\" style=\"height: 10px;\"> HistoTrainer\n    </button>\n    <div id=\"praeparat\" class=\"hints\" style=\"display: none;\">{{edit:HistoTrainer}}</div>\n  </span>\n{{/HistoTrainer}}\n\n    {{#Memes}}\n  <span id=\"hint-memes\" class=\"hintBtn\" data-name=\"Memes\" style=\"display: none;\">\n    <button id=\"button-memes\" class=\"button-general\" onclick=\"toggleHintBtn('hint-memes'); event.stopPropagation()\">\n      <img src=\"__sonstiges.svg\" style=\"height: 10px;\"> Memes\n    </button>\n    <div id=\"memes\" class=\"hints\" style=\"display: none;\">{{edit:Memes}}</div>\n  </span>\n{{/Memes}}\n\n    <!-- Extra field -->\n    {{#Extra}}\n      <div id=\"extra\" style=\"display: none;\">\n        <br><br>{{edit:Extra}}</div>\n    {{/Extra}}\n\n    {{#AMBOSS-Link}}\n      <span id=\"hint-amboss\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:AMBOSS-Link}}\">\n          <button id=\"button-amboss\" class=\"button-general\">\n            <img src=\"__amboss.svg\" style=\"height: 10px;\"> AMBOSS&#8203;\n          </button>\n        </a>\n      </span>\n    {{/AMBOSS-Link}}\n    \n    {{#Thieme via medici-Link}}\n      <span id=\"hint-thieme\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Thieme via medici-Link}}\">\n          <button id=\"button-thieme\" class=\"button-general\">\n            <img id=\"button-thieme-img\" src=\"__thieme-heart.svg\" style=\"height: 10px;\"> Thieme via medici\n          </button>\n        </a>\n      </span>\n    {{/Thieme via medici-Link}}\n\n    {{#Meditricks}}\n  <span id=\"hint-meditricks\" class=\"hintBtn\" data-name=\"Meditricks\" style=\"display: none;\">\n    <button id=\"button-meditricks\" class=\"button-general\" onclick=\"toggleHintBtn('hint-meditricks'); event.stopPropagation()\">\n      <img src=\"__meditricks.svg\" style=\"height: 10px;\"> Meditricks\n    </button>\n    <div id=\"meditricks\" class=\"hints\" style=\"display: none;\">{{edit:Meditricks}}</div>\n  </span>\n{{/Meditricks}}\n\n    {{#weitere Links}}\n    <span id=\"hint-linkcontainer\" class=\"hintBtn\" data-name=\"linkContainer\" style=\"display: none;\">\n      <button id=\"button-linkcontainer\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-linkcontainer'); event.stopPropagation()\">\n        <img src=\"__internet.svg\" style=\"height: 10px;\"> weitere Links\n      </button>\n      <div id=\"linkcontainer\" class=\"hints\" style=\"display: none;\"></div>\n      <span id=\"linkContainerLinks\" style=\"display: none;\">{{edit:weitere Links}}</span>\n    </span>\n  {{/weitere Links}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function(type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function(ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n  <script>\n    var tagContainer = document.getElementById(\"tags-container\")\n\n    if (tagContainer.childElementCount == 0) {\n      var tagList = tagContainer.innerHTML.trim().split(\" \");\n      var kbdList = [];\n      var newTagContent = document.createElement(\"div\");\n\n      for (var i = 0; i < tagList.length; i++) {\n        var newTag = document.createElement(\"kbd\");\n        var tag = tagList[i];\n        // numTagLevelsToShow == 0 means the whole tag should be shown\n        if (numTagLevelsToShow != 0) {\n          tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n        }\n\n        // Zankiphil / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n        if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) continue;\n        if (tag.split(\"::\")[1] == \"!NEW_CARDS\") continue;\n        if (tag.split(\"::\")[1] == \"§Projekt_Anki\") continue;\n        if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") continue;\n\n        // improve legibility of tags\n        tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n        tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\");\n        tag = tag.replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n        newTag.innerHTML = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"_\", \" \");\n        newTagContent.append(newTag)\n      }\n\n      tagContainer.innerHTML = newTagContent.innerHTML;\n      tagContainer.style.cursor = \"default\";\n    }\n\n    if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n      tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n    }\n\n    function showtags() {\n      var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n      if (tagContainerShortcut.style.display === \"none\") {\n        tagContainerShortcut.style.display = \"inline\";\n      } else {\n        tagContainerShortcut.style.display = \"none\";\n      }\n    }\n\n    var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n    ankingAddEventListener('keyup', function (e) {\n      if (isShortcut(e)) {\n        toggleHintBtn('hint-tags');\n        showtags();\n      }\n    });\n  </script>\n  <script>\n    for (const tag of document.getElementsByTagName('kbd')) {\n      tag.innerHTML = tag.innerHTML.replace(/::/g, '::<wbr>')\n    }\n  </script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (el.style.display === 'none') {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n    try {\n        for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n            href = link.href\n            text = link.innerText\n\n            const el = document.createElement('a');\n            el.setAttribute('href', link.href);\n\n            const btn = document.createElement('button');\n            btn.classList.add('button-general');\n            btn.classList.add('expanded-button');\n\n            domain = href.replace(/.+\\/\\/|(www|flexikon|de|next|com).|\\..+/g, '');\n            domainDict = {\n                \"amboss\": \"__amboss.svg\",\n                \"wikipedia\": \"__wikipedia.svg\",\n                \"doccheck\": \"__doccheck.png\",\n                \"notfallguru\": \"__notfallguru.svg\",\n            }\n            if (domain in domainDict) {\n                icon = domainDict[domain]\n            } else {\n                icon = \"__internet.svg\"\n            }\n\n            const img = document.createElement('img');\n            img.setAttribute('src', icon);\n            img.setAttribute('style', 'height: 10px;');\n\n            btn.appendChild(img);\n            btn.innerHTML = btn.innerHTML + \" \" + text;\n\n            el.appendChild(btn);\n\n            document.getElementById(\"linkcontainer\").appendChild(el)\n        }\n    }\n    catch (err) {\n        console.log(err)\n    }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\nfunction getTextWidth(text, font) {\n // re-use canvas object for better performance\n const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n const context = canvas.getContext(\"2d\");\n context.font = font;\n const metrics = context.measureText(text);\n return metrics.width;\n}\n\nfunction getCSSStyle(element, prop) {\n return window.getComputedStyle(element, null).getPropertyValue(prop);\n}\n\nfunction getCanvasFont(el = document.body) {\n const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n const fontSize = getCSSStyle(el, 'font-size') || '16px';\n const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n return `${fontWeight} ${fontSize} ${fontFamily}`;\n}\n\n/**\n* Iterates over a list of divs containing text to be indented\n*\n* @param {HTMLCollection} divs: The divs to be iterated over.\n*/\nfunction indentText(divs) {\n // setup the indentation markers\n var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n var bulletP = \"•\"\n var minus = \"– \"\n var enter = \"↳(?!( ↳|↳))\"\n var arrow = \"→\"\n\n // heuristic indentation hierarchy\n hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n // set up RegEx to analyze the provided divs\n // negative lookbehinds unfortunately do not work yet on iPad / Android\n var beginning = '(?<=<br>)(?<!cloze=\")('\n var middle = \".*?)((?:<br>)(?=(\"\n var end = \"))|(?=(<\\/indent>|<\\/div>|<br><br>)))\"\n\n const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n // iterate over divs\n for (const div of divs) {\n   // calculate indentation depths\n   var canvasFont = getCanvasFont(div)\n   var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n   var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n   var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n   var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n   var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n   var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n   var indentEnd = ';\">$1</indent>'\n\n   // do the indentation\n   divHTML = div.outerHTML\n   divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n   divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n   div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\")\n }\n}\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits( n ) {\n      return (n <= 9 ? \"0\" + n : n); \n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n      \n      if ( msLeft < 1000 ) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date( msLeft );\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout( updateTimer, time.getUTCMilliseconds() + 500 );\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60*minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds ); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function(key, dictionary){\n        return dictionary[key];\n      }\n    }\n    \n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n      \n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n      \n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n/**\n * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n * Full credit to the original authors, except where modified or otherwise indicated.\n */\n\n/**\n *\n * We try to respect that people use various note types\n * which may do 'weird' stuff.\n * Elements may have event listeners that can be removed if we just innerHTML stuff\n * <i> may be styled 'i { display: block }', etc.\n *\n * Another problem that complicate the design of this script is that\n * a word may not be cleanly separated by html tags.\n * e.g. \"A<i>long</i>word\"\n *\n */\n\n(function () {\n  /**\n   * @param {String} text\n   * @returns {number}\n   */\n  function getBoldLength(text) {\n    return Math.floor(text.length / 2);\n  }\n\n  // Ignore node if any of the filters return true\n  const excludeFilters = [\n    (elem) => elem.tagName === \"SCRIPT\",\n    (elem) => elem.tagName === \"STYLE\",\n    (elem) => elem.classList.contains(\"cloze\"),\n  ];\n\n  function newBoldElement(text) {\n    const elem = document.createElement(\"strong\");\n    elem.innerText = text;\n    return elem;\n  }\n\n  function indexOfWhitespace(text, startPos) {\n    const whitespaces = [\n      \" \",\n      \"\\n\",\n      \"\\t\",\n      \" \",\n      \"&nbsp;\",\n      \"‑\",\n      \"-\",\n      \"/\",\n      \"(\",\n      \")\",\n    ];\n    let nextPos = text.length;\n    for (const whitespace of whitespaces) {\n      const next = text.indexOf(whitespace, startPos);\n      if (next !== -1 && next < nextPos) {\n        nextPos = next;\n      }\n    }\n    if (nextPos === text.length) {\n      nextPos = -1;\n    }\n    return nextPos;\n  }\n\n  // Bolds a line of words\n  class BionicReaderBolder {\n    constructor(nodes) {\n      this.nodes = nodes;\n      this.startNodeIndex = 0;\n      this.startPos = 0;\n      this.replaceNodes = [];\n      while (!this.isFinished()) {\n        this.runWithinNode();\n        this.runInterNode();\n      }\n    }\n\n    static run(nodes) {\n      new BionicReaderBolder(nodes);\n    }\n\n    isFinished() {\n      return this.startNodeIndex === this.nodes.length;\n    }\n\n    replaceNode() {\n      const node = this.nodes[this.startNodeIndex];\n      const parent = node.parentNode;\n      for (let add of this.replaceNodes) {\n        parent.insertBefore(add, node);\n      }\n      parent.removeChild(node);\n      this.replaceNodes = [];\n    }\n\n    runWithinNode() {\n      const textContent = this.nodes[this.startNodeIndex].textContent;\n      let nextPos = indexOfWhitespace(textContent, this.startPos);\n      while (nextPos !== -1) {\n        const word = textContent.substring(this.startPos, nextPos);\n        const boldLength = getBoldLength(word);\n        this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n        this.replaceNodes.push(\n          document.createTextNode(\n            word.substring(boldLength, nextPos) + textContent[nextPos]\n          )\n        );\n        this.startPos = nextPos + 1;\n        nextPos = indexOfWhitespace(textContent, this.startPos);\n      }\n    }\n\n    // after this, startPos is likely to be at whitespace char\n    runInterNode() {\n      let word = \"\";\n      let endNodeIndex = this.startNodeIndex;\n      let endPos = this.startPos; // last word char pos + 1\n\n      // Find word boundary\n      while (endNodeIndex < this.nodes.length) {\n        const textContent = this.nodes[endNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, endPos);\n        if (nextPos === -1) {\n          word += textContent.substring(endPos);\n          endNodeIndex += 1;\n          endPos = 0;\n        } else {\n          word += textContent.substring(endPos, nextPos);\n          endPos = nextPos;\n          break;\n        }\n      }\n      // Calculate bold length\n      let remainingBoldLength = getBoldLength(word);\n\n      // Bold part of word\n      while (remainingBoldLength > 0) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        if (remainingBoldLength > textContent.length - this.startPos) {\n          const wordPart = textContent.substring(this.startPos);\n          remainingBoldLength -= wordPart.length;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        } else {\n          const wordPart = textContent.substring(\n            this.startPos,\n            this.startPos + remainingBoldLength\n          );\n          this.startPos += remainingBoldLength;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          remainingBoldLength -= wordPart.length;\n        }\n      }\n\n      // Add non-bolded part of words\n      while (this.startNodeIndex < endNodeIndex) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.replaceNode();\n        this.startNodeIndex += 1;\n        this.startPos = 0;\n      }\n\n      if (this.startPos < endPos) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos, endPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.startPos = endPos;\n      }\n    }\n  }\n\n  /**\n   * Builds a list of (list of nodes that makes up one non-line-broken line)\n   * @param {Node} elem\n   * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n   * @returns {void}\n   */\n  function forTextNodesInTree(elem, nodes, exclude = false) {\n    const children = elem.childNodes;\n    for (const filter of excludeFilters) {\n      if (filter(elem)) {\n        exclude = true;\n        break;\n      }\n    }\n    for (const child of children) {\n      if (child.nodeType === Node.ELEMENT_NODE) {\n        const style = window.getComputedStyle(child);\n        if (\n          child.tagName !== \"BR\" &&\n          (style === \"inline\" || style === \"inline-block\")\n        ) {\n          forTextNodesInTree(child, nodes, exclude);\n        } else {\n          if (nodes[nodes.length - 1].length > 0) {\n            nodes.push([]);\n          }\n          forTextNodesInTree(child, nodes, exclude);\n        }\n      } else if (\n        !exclude &&\n        child.nodeType === Node.TEXT_NODE &&\n        child.textContent.length > 0\n      ) {\n        nodes[nodes.length - 1].push(child);\n      }\n    }\n  }\n\n  function makeBionic() {\n    const cardContainer = document.getElementById(\"container\");\n    cardContainer.normalize();\n\n    let nodesLines = [[]];\n    forTextNodesInTree(cardContainer, nodesLines);\n    for (const nodes of nodesLines) {\n      BionicReaderBolder.run(nodes);\n    }\n\n    cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n      \"<strong></strong>\",\n      \"\"\n    );\n    cardContainer.normalize();\n  }\n\n  let start = performance.now();\n  if (bionicReading) {\n    makeBionic();\n  }\n  let end = performance.now();\n  console.log(`Initialized bionic reading: ${end - start}ms`);\n})();\n</script>\n\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\nvar userJs1 = undefined\nvar userJs2 = undefined\nvar userJs3 = undefined\nvar userJs4 = undefined\nvar userJs5 = undefined\nvar userJs6 = undefined\nvar userJs7 = undefined\nvar userJs8 = undefined\n</script>\n",
      "bqfmt": "{{Titel}}",
      "bafmt": "{{Markierung 8}}",
      "did": null,
      "bfont": "Helvetica",
      "bsize": 12
    },
    {
      "name": "Markierung 9",
      "ord": 8,
      "qfmt": "<!-- version 0fd8612 -->\n{{#Markierung 9}}\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TIMER CONFIG  ##############\n// Timer config (timer length, timer finished message)\nvar minutes =  0\nvar seconds = 15\nvar timeOverMsg = \"<span style='color:#CC5B5B'>!!!</span>\"\n\n  // ##############  TAG SHORTCUT  ##############\nvar toggleTagsShortcut = \"C\";\n\n// ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\nvar tagID = \"XXXYYYZZZ\"\n\n// WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\nvar numTagLevelsToShow = 0;\n\n// ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\nvar tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n// Enable experimental heuristic indentation feature\nvar indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n// Enable experimental DIVI medication formatting feature\nvar formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n// Enable experimental confounder formatting feature\nvar formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n// Enable bionic reading feature (based on AnKing add-on)\nvar bionicReading = false;\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button\n        id=\"button-tags\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n      >\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button\n        id=\"button-src\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n      >\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button\n        id=\"button-nid\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n      >\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button\n          id=\"button-ankihub\"\n          class=\"button-general\"\n          title=\"Karte in AnkiHub\"\n        >\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) {}\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button\n      id=\"button-tags\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button\n      id=\"button-src\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">Quelle: {{Quelle}}</div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button\n      id=\"button-nid\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    <i>Was</i> wird hier bei <b>⑨</b> gezeigt?\n\n    <br>\n    <br>\n\n    {{#Hint / Hinweis}}\n      <span style=\"color:IndianRed; font-weight: bold;\">Hinweis:</span> {{hint:Hint / Hinweis}}\n\n      <br>\n      <br>\n    {{/Hint / Hinweis}}\n    \n    {{Bild}}\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\"></div>\n\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n<script>\n  //DONT FADE BETWEEN CARDS\n  qFade = 0;\n  if (typeof anki !== 'undefined') anki.qFade = qFade;\n</script>\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\nfunction getTextWidth(text, font) {\n // re-use canvas object for better performance\n const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n const context = canvas.getContext(\"2d\");\n context.font = font;\n const metrics = context.measureText(text);\n return metrics.width;\n}\n\nfunction getCSSStyle(element, prop) {\n return window.getComputedStyle(element, null).getPropertyValue(prop);\n}\n\nfunction getCanvasFont(el = document.body) {\n const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n const fontSize = getCSSStyle(el, 'font-size') || '16px';\n const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n return `${fontWeight} ${fontSize} ${fontFamily}`;\n}\n\n/**\n* Iterates over a list of divs containing text to be indented\n*\n* @param {HTMLCollection} divs: The divs to be iterated over.\n*/\nfunction indentText(divs) {\n // setup the indentation markers\n var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n var bulletP = \"•\"\n var minus = \"– \"\n var enter = \"↳(?!( ↳|↳))\"\n var arrow = \"→\"\n\n // heuristic indentation hierarchy\n hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n // set up RegEx to analyze the provided divs\n // negative lookbehinds unfortunately do not work yet on iPad / Android\n var beginning = '(?<=<br>)(?<!cloze=\")('\n var middle = \".*?)((?:<br>)(?=(\"\n var end = \"))|(?=(<\\/indent>|<\\/div>|<br><br>)))\"\n\n const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n // iterate over divs\n for (const div of divs) {\n   // calculate indentation depths\n   var canvasFont = getCanvasFont(div)\n   var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n   var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n   var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n   var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n   var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n   var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n   var indentEnd = ';\">$1</indent>'\n\n   // do the indentation\n   divHTML = div.outerHTML\n   divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n   divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n   div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\")\n }\n}\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function(type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function(ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n  <script>\n    var tagContainer = document.getElementById(\"tags-container\")\n\n    if (tagContainer.childElementCount == 0) {\n      var tagList = tagContainer.innerHTML.trim().split(\" \");\n      var kbdList = [];\n      var newTagContent = document.createElement(\"div\");\n\n      for (var i = 0; i < tagList.length; i++) {\n        var newTag = document.createElement(\"kbd\");\n        var tag = tagList[i];\n        // numTagLevelsToShow == 0 means the whole tag should be shown\n        if (numTagLevelsToShow != 0) {\n          tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n        }\n\n        // Zankiphil / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n        if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) continue;\n        if (tag.split(\"::\")[1] == \"!NEW_CARDS\") continue;\n        if (tag.split(\"::\")[1] == \"§Projekt_Anki\") continue;\n        if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") continue;\n\n        // improve legibility of tags\n        tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n        tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\");\n        tag = tag.replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n        newTag.innerHTML = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"_\", \" \");\n        newTagContent.append(newTag)\n      }\n\n      tagContainer.innerHTML = newTagContent.innerHTML;\n      tagContainer.style.cursor = \"default\";\n    }\n\n    if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n      tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n    }\n\n    function showtags() {\n      var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n      if (tagContainerShortcut.style.display === \"none\") {\n        tagContainerShortcut.style.display = \"inline\";\n      } else {\n        tagContainerShortcut.style.display = \"none\";\n      }\n    }\n\n    var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n    ankingAddEventListener('keyup', function (e) {\n      if (isShortcut(e)) {\n        toggleHintBtn('hint-tags');\n        showtags();\n      }\n    });\n  </script>\n  <script>\n    for (const tag of document.getElementsByTagName('kbd')) {\n      tag.innerHTML = tag.innerHTML.replace(/::/g, '::<wbr>')\n    }\n  </script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (el.style.display === 'none') {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits( n ) {\n      return (n <= 9 ? \"0\" + n : n); \n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n      \n      if ( msLeft < 1000 ) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date( msLeft );\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout( updateTimer, time.getUTCMilliseconds() + 500 );\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60*minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds ); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function(key, dictionary){\n        return dictionary[key];\n      }\n    }\n    \n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n      \n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n      \n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n/**\n * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n * Full credit to the original authors, except where modified or otherwise indicated.\n */\n\n/**\n *\n * We try to respect that people use various note types\n * which may do 'weird' stuff.\n * Elements may have event listeners that can be removed if we just innerHTML stuff\n * <i> may be styled 'i { display: block }', etc.\n *\n * Another problem that complicate the design of this script is that\n * a word may not be cleanly separated by html tags.\n * e.g. \"A<i>long</i>word\"\n *\n */\n\n(function () {\n  /**\n   * @param {String} text\n   * @returns {number}\n   */\n  function getBoldLength(text) {\n    return Math.floor(text.length / 2);\n  }\n\n  // Ignore node if any of the filters return true\n  const excludeFilters = [\n    (elem) => elem.tagName === \"SCRIPT\",\n    (elem) => elem.tagName === \"STYLE\",\n    (elem) => elem.classList.contains(\"cloze\"),\n  ];\n\n  function newBoldElement(text) {\n    const elem = document.createElement(\"strong\");\n    elem.innerText = text;\n    return elem;\n  }\n\n  function indexOfWhitespace(text, startPos) {\n    const whitespaces = [\n      \" \",\n      \"\\n\",\n      \"\\t\",\n      \" \",\n      \"&nbsp;\",\n      \"‑\",\n      \"-\",\n      \"/\",\n      \"(\",\n      \")\",\n    ];\n    let nextPos = text.length;\n    for (const whitespace of whitespaces) {\n      const next = text.indexOf(whitespace, startPos);\n      if (next !== -1 && next < nextPos) {\n        nextPos = next;\n      }\n    }\n    if (nextPos === text.length) {\n      nextPos = -1;\n    }\n    return nextPos;\n  }\n\n  // Bolds a line of words\n  class BionicReaderBolder {\n    constructor(nodes) {\n      this.nodes = nodes;\n      this.startNodeIndex = 0;\n      this.startPos = 0;\n      this.replaceNodes = [];\n      while (!this.isFinished()) {\n        this.runWithinNode();\n        this.runInterNode();\n      }\n    }\n\n    static run(nodes) {\n      new BionicReaderBolder(nodes);\n    }\n\n    isFinished() {\n      return this.startNodeIndex === this.nodes.length;\n    }\n\n    replaceNode() {\n      const node = this.nodes[this.startNodeIndex];\n      const parent = node.parentNode;\n      for (let add of this.replaceNodes) {\n        parent.insertBefore(add, node);\n      }\n      parent.removeChild(node);\n      this.replaceNodes = [];\n    }\n\n    runWithinNode() {\n      const textContent = this.nodes[this.startNodeIndex].textContent;\n      let nextPos = indexOfWhitespace(textContent, this.startPos);\n      while (nextPos !== -1) {\n        const word = textContent.substring(this.startPos, nextPos);\n        const boldLength = getBoldLength(word);\n        this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n        this.replaceNodes.push(\n          document.createTextNode(\n            word.substring(boldLength, nextPos) + textContent[nextPos]\n          )\n        );\n        this.startPos = nextPos + 1;\n        nextPos = indexOfWhitespace(textContent, this.startPos);\n      }\n    }\n\n    // after this, startPos is likely to be at whitespace char\n    runInterNode() {\n      let word = \"\";\n      let endNodeIndex = this.startNodeIndex;\n      let endPos = this.startPos; // last word char pos + 1\n\n      // Find word boundary\n      while (endNodeIndex < this.nodes.length) {\n        const textContent = this.nodes[endNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, endPos);\n        if (nextPos === -1) {\n          word += textContent.substring(endPos);\n          endNodeIndex += 1;\n          endPos = 0;\n        } else {\n          word += textContent.substring(endPos, nextPos);\n          endPos = nextPos;\n          break;\n        }\n      }\n      // Calculate bold length\n      let remainingBoldLength = getBoldLength(word);\n\n      // Bold part of word\n      while (remainingBoldLength > 0) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        if (remainingBoldLength > textContent.length - this.startPos) {\n          const wordPart = textContent.substring(this.startPos);\n          remainingBoldLength -= wordPart.length;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        } else {\n          const wordPart = textContent.substring(\n            this.startPos,\n            this.startPos + remainingBoldLength\n          );\n          this.startPos += remainingBoldLength;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          remainingBoldLength -= wordPart.length;\n        }\n      }\n\n      // Add non-bolded part of words\n      while (this.startNodeIndex < endNodeIndex) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.replaceNode();\n        this.startNodeIndex += 1;\n        this.startPos = 0;\n      }\n\n      if (this.startPos < endPos) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos, endPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.startPos = endPos;\n      }\n    }\n  }\n\n  /**\n   * Builds a list of (list of nodes that makes up one non-line-broken line)\n   * @param {Node} elem\n   * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n   * @returns {void}\n   */\n  function forTextNodesInTree(elem, nodes, exclude = false) {\n    const children = elem.childNodes;\n    for (const filter of excludeFilters) {\n      if (filter(elem)) {\n        exclude = true;\n        break;\n      }\n    }\n    for (const child of children) {\n      if (child.nodeType === Node.ELEMENT_NODE) {\n        const style = window.getComputedStyle(child);\n        if (\n          child.tagName !== \"BR\" &&\n          (style === \"inline\" || style === \"inline-block\")\n        ) {\n          forTextNodesInTree(child, nodes, exclude);\n        } else {\n          if (nodes[nodes.length - 1].length > 0) {\n            nodes.push([]);\n          }\n          forTextNodesInTree(child, nodes, exclude);\n        }\n      } else if (\n        !exclude &&\n        child.nodeType === Node.TEXT_NODE &&\n        child.textContent.length > 0\n      ) {\n        nodes[nodes.length - 1].push(child);\n      }\n    }\n  }\n\n  function makeBionic() {\n    const cardContainer = document.getElementById(\"container\");\n    cardContainer.normalize();\n\n    let nodesLines = [[]];\n    forTextNodesInTree(cardContainer, nodesLines);\n    for (const nodes of nodesLines) {\n      BionicReaderBolder.run(nodes);\n    }\n\n    cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n      \"<strong></strong>\",\n      \"\"\n    );\n    cardContainer.normalize();\n  }\n\n  let start = performance.now();\n  if (bionicReading) {\n    makeBionic();\n  }\n  let end = performance.now();\n  console.log(`Initialized bionic reading: ${end - start}ms`);\n})();\n</script>\n\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\nvar userJs1 = undefined\nvar userJs2 = undefined\nvar userJs3 = undefined\nvar userJs4 = undefined\nvar userJs5 = undefined\nvar userJs6 = undefined\nvar userJs7 = undefined\nvar userJs8 = undefined\n</script>\n\n\n{{/Markierung 9}}",
      "afmt": "<!-- version 0fd8612 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Eigene Notizen & Bilder\": \"Alt + 1\",\n    \"Eigene Prüfungsfragen\": \"Alt + 2\",\n    \"Definitionen\": \"Alt + 3\",\n    \"Merksprüche\": \"Alt + 4\",\n    \"Klinik\": \"Alt + 5\",\n    \"Präparat\": \"Alt + 6\",\n    \"Memes\": \"Alt + 7\",\n    \"linkContainer\": \"Alt + L\",\n    \"Meditricks\": \"Alt + M\",\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Eigene Notizen & Bilder\": false,\n    \"Eigene Prüfungsfragen\": false,\n    \"Definitionen\": false,\n    \"Merksprüche\": false,\n    \"Klinik\": false,\n    \"Präparat\": false,\n    \"Memes\": false,\n    \"linkContainer\": true,\n    \"Meditricks\": false,\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\":false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\nvar toggleTagsShortcut = \"C\";\n\n// ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\nvar tagID = \"XXXYYYZZZ\"\n\n// WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\nvar numTagLevelsToShow = 0;\n\n// ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\nvar tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n// Enable experimental heuristic indentation feature\nvar indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n// Enable experimental DIVI medication formatting feature\nvar formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n// Enable experimental confounder formatting feature\nvar formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n// Enable bionic reading feature (based on AnKing add-on)\nvar bionicReading = false;\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button\n        id=\"button-tags\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n      >\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button\n        id=\"button-src\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n      >\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button\n        id=\"button-nid\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n      >\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button\n          id=\"button-ankihub\"\n          class=\"button-general\"\n          title=\"Karte in AnkiHub\"\n        >\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) {}\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button\n      id=\"button-tags\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button\n      id=\"button-src\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">Quelle: {{Quelle}}</div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button\n      id=\"button-nid\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    <i>Was</i> wird hier bei <b>⑨</b> gezeigt?\n\n    <br>\n    <br>\n\n    {{#Hint / Hinweis}}\n      <span style=\"color:IndianRed; font-weight: bold;\">Hinweis:</span> {{hint:Hint / Hinweis}}\n\n      <br>\n      <br>\n    {{/Hint / Hinweis}}\n    \n    {{Bild}}\n\n    <br>\n    <br>\n\n    <span class=\"cloze\">{{Markierung 9}}</span>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- BUTTON FIELDS -->\n    {{#Eigene Notizen & Bilder}}\n  <span id=\"hint-zusatz\" class=\"hintBtn\" data-name=\"Eigene Notizen & Bilder\" style=\"display: none;\">\n    <button id=\"button-zusatz\" class=\"button-general\" onclick=\"toggleHintBtn('hint-zusatz'); event.stopPropagation()\">\n      <img src=\"__zusatz.svg\" style=\"height: 10px;\"> Eigene Notizen & Bilder\n    </button>\n    <div id=\"zusatz\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Notizen & Bilder}}</div>\n  </span>\n{{/Eigene Notizen & Bilder}}\n\n    {{#Eigene Prüfungsfragen}}\n  <span id=\"hint-hammer\" class=\"hintBtn\" data-name=\"Eigene Prüfungsfragen\" style=\"display: none;\">\n    <button id=\"button-hammer\" class=\"button-general\" onclick=\"toggleHintBtn('hint-hammer'); event.stopPropagation()\">\n      <img src=\"__hammer.svg\" style=\"height: 10px;\"> Eigene Prüfungsfragen\n    </button>\n    <div id=\"hammer\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Prüfungsfragen}}</div>\n  </span>\n{{/Eigene Prüfungsfragen}}\n\n    {{#Definitionen}}\n  <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Definitionen\" style=\"display: none;\">\n    <button id=\"button-definition\" class=\"button-general\" onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n      <img src=\"__explanation.svg\" style=\"height: 10px;\"> Definitionen\n    </button>\n    <div id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Definitionen}}</div>\n  </span>\n{{/Definitionen}}\n\n    {{#Merksprüche}}\n  <span id=\"hint-merksprueche\" class=\"hintBtn\" data-name=\"Merksprüche\" style=\"display: none;\">\n    <button id=\"button-merksprueche\" class=\"button-general\" onclick=\"toggleHintBtn('hint-merksprueche'); event.stopPropagation()\">\n      <img src=\"__merkhilfe.svg\" style=\"height: 10px;\"> Merksprüche\n    </button>\n    <div id=\"merksprueche\" class=\"hints\" style=\"display: none;\">{{edit:Merksprüche}}</div>\n  </span>\n{{/Merksprüche}}\n\n    {{#Klinik}}\n  <span id=\"hint-klinik\" class=\"hintBtn\" data-name=\"Klinik\" style=\"display: none;\">\n    <button id=\"button-klinik\" class=\"button-general\" onclick=\"toggleHintBtn('hint-klinik'); event.stopPropagation()\">\n      <img src=\"__stethoscope.svg\" style=\"height: 10px;\"> Klinik\n    </button>\n    <div id=\"klinik\" class=\"hints\" style=\"display: none;\">{{edit:Klinik}}</div>\n  </span>\n{{/Klinik}}\n\n    {{#Präparat}}\n      <span id=\"hint-praeparat-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Präparat}}\">\n          <button id=\"button-praeparat\" class=\"button-general\">\n            <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n          </button>\n        </a>\n      </span>\n    {{/Präparat}}\n\n    {{#Virtuelle Mikroskopie}}\n      <span id=\"hint-microscope-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Virtuelle Mikroskopie}}\">\n          <button id=\"button-microscope\" class=\"button-general\">\n            <img src=\"__microscope.svg\" style=\"height: 10px;\"> Virtuelle Mikroskopie\n          </button>\n        </a>\n      </span>\n    {{/Virtuelle Mikroskopie}}\n\n    {{#Smart Zoom}}\n      <span id=\"hint-smartzoom-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Präparat}}\">\n          <button id=\"button-smartzoom\" class=\"button-general\">\n            <img src=\"__microscope.svg\" style=\"height: 10px;\"> Smart Zoom\n          </button>\n        </a>\n      </span>\n    {{/Smart Zoom}}\n\n    {{#HistoTrainer}}\n  <span id=\"hint-praeparat\" class=\"hintBtn\" data-name=\"HistoTrainer\" style=\"display: none;\">\n    <button id=\"button-praeparat\" class=\"button-general\" onclick=\"toggleHintBtn('hint-praeparat'); event.stopPropagation()\">\n      <img src=\"__microscope.svg\" style=\"height: 10px;\"> HistoTrainer\n    </button>\n    <div id=\"praeparat\" class=\"hints\" style=\"display: none;\">{{edit:HistoTrainer}}</div>\n  </span>\n{{/HistoTrainer}}\n\n    {{#Memes}}\n  <span id=\"hint-memes\" class=\"hintBtn\" data-name=\"Memes\" style=\"display: none;\">\n    <button id=\"button-memes\" class=\"button-general\" onclick=\"toggleHintBtn('hint-memes'); event.stopPropagation()\">\n      <img src=\"__sonstiges.svg\" style=\"height: 10px;\"> Memes\n    </button>\n    <div id=\"memes\" class=\"hints\" style=\"display: none;\">{{edit:Memes}}</div>\n  </span>\n{{/Memes}}\n\n    <!-- Extra field -->\n    {{#Extra}}\n      <div id=\"extra\" style=\"display: none;\">\n        <br><br>{{edit:Extra}}</div>\n    {{/Extra}}\n\n    {{#AMBOSS-Link}}\n      <span id=\"hint-amboss\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:AMBOSS-Link}}\">\n          <button id=\"button-amboss\" class=\"button-general\">\n            <img src=\"__amboss.svg\" style=\"height: 10px;\"> AMBOSS&#8203;\n          </button>\n        </a>\n      </span>\n    {{/AMBOSS-Link}}\n    \n    {{#Thieme via medici-Link}}\n      <span id=\"hint-thieme\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Thieme via medici-Link}}\">\n          <button id=\"button-thieme\" class=\"button-general\">\n            <img id=\"button-thieme-img\" src=\"__thieme-heart.svg\" style=\"height: 10px;\"> Thieme via medici\n          </button>\n        </a>\n      </span>\n    {{/Thieme via medici-Link}}\n\n    {{#Meditricks}}\n  <span id=\"hint-meditricks\" class=\"hintBtn\" data-name=\"Meditricks\" style=\"display: none;\">\n    <button id=\"button-meditricks\" class=\"button-general\" onclick=\"toggleHintBtn('hint-meditricks'); event.stopPropagation()\">\n      <img src=\"__meditricks.svg\" style=\"height: 10px;\"> Meditricks\n    </button>\n    <div id=\"meditricks\" class=\"hints\" style=\"display: none;\">{{edit:Meditricks}}</div>\n  </span>\n{{/Meditricks}}\n\n    {{#weitere Links}}\n    <span id=\"hint-linkcontainer\" class=\"hintBtn\" data-name=\"linkContainer\" style=\"display: none;\">\n      <button id=\"button-linkcontainer\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-linkcontainer'); event.stopPropagation()\">\n        <img src=\"__internet.svg\" style=\"height: 10px;\"> weitere Links\n      </button>\n      <div id=\"linkcontainer\" class=\"hints\" style=\"display: none;\"></div>\n      <span id=\"linkContainerLinks\" style=\"display: none;\">{{edit:weitere Links}}</span>\n    </span>\n  {{/weitere Links}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function(type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function(ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n  <script>\n    var tagContainer = document.getElementById(\"tags-container\")\n\n    if (tagContainer.childElementCount == 0) {\n      var tagList = tagContainer.innerHTML.trim().split(\" \");\n      var kbdList = [];\n      var newTagContent = document.createElement(\"div\");\n\n      for (var i = 0; i < tagList.length; i++) {\n        var newTag = document.createElement(\"kbd\");\n        var tag = tagList[i];\n        // numTagLevelsToShow == 0 means the whole tag should be shown\n        if (numTagLevelsToShow != 0) {\n          tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n        }\n\n        // Zankiphil / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n        if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) continue;\n        if (tag.split(\"::\")[1] == \"!NEW_CARDS\") continue;\n        if (tag.split(\"::\")[1] == \"§Projekt_Anki\") continue;\n        if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") continue;\n\n        // improve legibility of tags\n        tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n        tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\");\n        tag = tag.replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n        newTag.innerHTML = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"_\", \" \");\n        newTagContent.append(newTag)\n      }\n\n      tagContainer.innerHTML = newTagContent.innerHTML;\n      tagContainer.style.cursor = \"default\";\n    }\n\n    if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n      tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n    }\n\n    function showtags() {\n      var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n      if (tagContainerShortcut.style.display === \"none\") {\n        tagContainerShortcut.style.display = \"inline\";\n      } else {\n        tagContainerShortcut.style.display = \"none\";\n      }\n    }\n\n    var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n    ankingAddEventListener('keyup', function (e) {\n      if (isShortcut(e)) {\n        toggleHintBtn('hint-tags');\n        showtags();\n      }\n    });\n  </script>\n  <script>\n    for (const tag of document.getElementsByTagName('kbd')) {\n      tag.innerHTML = tag.innerHTML.replace(/::/g, '::<wbr>')\n    }\n  </script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (el.style.display === 'none') {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n    try {\n        for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n            href = link.href\n            text = link.innerText\n\n            const el = document.createElement('a');\n            el.setAttribute('href', link.href);\n\n            const btn = document.createElement('button');\n            btn.classList.add('button-general');\n            btn.classList.add('expanded-button');\n\n            domain = href.replace(/.+\\/\\/|(www|flexikon|de|next|com).|\\..+/g, '');\n            domainDict = {\n                \"amboss\": \"__amboss.svg\",\n                \"wikipedia\": \"__wikipedia.svg\",\n                \"doccheck\": \"__doccheck.png\",\n                \"notfallguru\": \"__notfallguru.svg\",\n            }\n            if (domain in domainDict) {\n                icon = domainDict[domain]\n            } else {\n                icon = \"__internet.svg\"\n            }\n\n            const img = document.createElement('img');\n            img.setAttribute('src', icon);\n            img.setAttribute('style', 'height: 10px;');\n\n            btn.appendChild(img);\n            btn.innerHTML = btn.innerHTML + \" \" + text;\n\n            el.appendChild(btn);\n\n            document.getElementById(\"linkcontainer\").appendChild(el)\n        }\n    }\n    catch (err) {\n        console.log(err)\n    }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\nfunction getTextWidth(text, font) {\n // re-use canvas object for better performance\n const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n const context = canvas.getContext(\"2d\");\n context.font = font;\n const metrics = context.measureText(text);\n return metrics.width;\n}\n\nfunction getCSSStyle(element, prop) {\n return window.getComputedStyle(element, null).getPropertyValue(prop);\n}\n\nfunction getCanvasFont(el = document.body) {\n const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n const fontSize = getCSSStyle(el, 'font-size') || '16px';\n const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n return `${fontWeight} ${fontSize} ${fontFamily}`;\n}\n\n/**\n* Iterates over a list of divs containing text to be indented\n*\n* @param {HTMLCollection} divs: The divs to be iterated over.\n*/\nfunction indentText(divs) {\n // setup the indentation markers\n var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n var bulletP = \"•\"\n var minus = \"– \"\n var enter = \"↳(?!( ↳|↳))\"\n var arrow = \"→\"\n\n // heuristic indentation hierarchy\n hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n // set up RegEx to analyze the provided divs\n // negative lookbehinds unfortunately do not work yet on iPad / Android\n var beginning = '(?<=<br>)(?<!cloze=\")('\n var middle = \".*?)((?:<br>)(?=(\"\n var end = \"))|(?=(<\\/indent>|<\\/div>|<br><br>)))\"\n\n const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n // iterate over divs\n for (const div of divs) {\n   // calculate indentation depths\n   var canvasFont = getCanvasFont(div)\n   var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n   var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n   var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n   var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n   var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n   var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n   var indentEnd = ';\">$1</indent>'\n\n   // do the indentation\n   divHTML = div.outerHTML\n   divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n   divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n   div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\")\n }\n}\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits( n ) {\n      return (n <= 9 ? \"0\" + n : n); \n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n      \n      if ( msLeft < 1000 ) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date( msLeft );\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout( updateTimer, time.getUTCMilliseconds() + 500 );\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60*minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds ); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function(key, dictionary){\n        return dictionary[key];\n      }\n    }\n    \n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n      \n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n      \n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n/**\n * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n * Full credit to the original authors, except where modified or otherwise indicated.\n */\n\n/**\n *\n * We try to respect that people use various note types\n * which may do 'weird' stuff.\n * Elements may have event listeners that can be removed if we just innerHTML stuff\n * <i> may be styled 'i { display: block }', etc.\n *\n * Another problem that complicate the design of this script is that\n * a word may not be cleanly separated by html tags.\n * e.g. \"A<i>long</i>word\"\n *\n */\n\n(function () {\n  /**\n   * @param {String} text\n   * @returns {number}\n   */\n  function getBoldLength(text) {\n    return Math.floor(text.length / 2);\n  }\n\n  // Ignore node if any of the filters return true\n  const excludeFilters = [\n    (elem) => elem.tagName === \"SCRIPT\",\n    (elem) => elem.tagName === \"STYLE\",\n    (elem) => elem.classList.contains(\"cloze\"),\n  ];\n\n  function newBoldElement(text) {\n    const elem = document.createElement(\"strong\");\n    elem.innerText = text;\n    return elem;\n  }\n\n  function indexOfWhitespace(text, startPos) {\n    const whitespaces = [\n      \" \",\n      \"\\n\",\n      \"\\t\",\n      \" \",\n      \"&nbsp;\",\n      \"‑\",\n      \"-\",\n      \"/\",\n      \"(\",\n      \")\",\n    ];\n    let nextPos = text.length;\n    for (const whitespace of whitespaces) {\n      const next = text.indexOf(whitespace, startPos);\n      if (next !== -1 && next < nextPos) {\n        nextPos = next;\n      }\n    }\n    if (nextPos === text.length) {\n      nextPos = -1;\n    }\n    return nextPos;\n  }\n\n  // Bolds a line of words\n  class BionicReaderBolder {\n    constructor(nodes) {\n      this.nodes = nodes;\n      this.startNodeIndex = 0;\n      this.startPos = 0;\n      this.replaceNodes = [];\n      while (!this.isFinished()) {\n        this.runWithinNode();\n        this.runInterNode();\n      }\n    }\n\n    static run(nodes) {\n      new BionicReaderBolder(nodes);\n    }\n\n    isFinished() {\n      return this.startNodeIndex === this.nodes.length;\n    }\n\n    replaceNode() {\n      const node = this.nodes[this.startNodeIndex];\n      const parent = node.parentNode;\n      for (let add of this.replaceNodes) {\n        parent.insertBefore(add, node);\n      }\n      parent.removeChild(node);\n      this.replaceNodes = [];\n    }\n\n    runWithinNode() {\n      const textContent = this.nodes[this.startNodeIndex].textContent;\n      let nextPos = indexOfWhitespace(textContent, this.startPos);\n      while (nextPos !== -1) {\n        const word = textContent.substring(this.startPos, nextPos);\n        const boldLength = getBoldLength(word);\n        this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n        this.replaceNodes.push(\n          document.createTextNode(\n            word.substring(boldLength, nextPos) + textContent[nextPos]\n          )\n        );\n        this.startPos = nextPos + 1;\n        nextPos = indexOfWhitespace(textContent, this.startPos);\n      }\n    }\n\n    // after this, startPos is likely to be at whitespace char\n    runInterNode() {\n      let word = \"\";\n      let endNodeIndex = this.startNodeIndex;\n      let endPos = this.startPos; // last word char pos + 1\n\n      // Find word boundary\n      while (endNodeIndex < this.nodes.length) {\n        const textContent = this.nodes[endNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, endPos);\n        if (nextPos === -1) {\n          word += textContent.substring(endPos);\n          endNodeIndex += 1;\n          endPos = 0;\n        } else {\n          word += textContent.substring(endPos, nextPos);\n          endPos = nextPos;\n          break;\n        }\n      }\n      // Calculate bold length\n      let remainingBoldLength = getBoldLength(word);\n\n      // Bold part of word\n      while (remainingBoldLength > 0) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        if (remainingBoldLength > textContent.length - this.startPos) {\n          const wordPart = textContent.substring(this.startPos);\n          remainingBoldLength -= wordPart.length;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        } else {\n          const wordPart = textContent.substring(\n            this.startPos,\n            this.startPos + remainingBoldLength\n          );\n          this.startPos += remainingBoldLength;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          remainingBoldLength -= wordPart.length;\n        }\n      }\n\n      // Add non-bolded part of words\n      while (this.startNodeIndex < endNodeIndex) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.replaceNode();\n        this.startNodeIndex += 1;\n        this.startPos = 0;\n      }\n\n      if (this.startPos < endPos) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos, endPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.startPos = endPos;\n      }\n    }\n  }\n\n  /**\n   * Builds a list of (list of nodes that makes up one non-line-broken line)\n   * @param {Node} elem\n   * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n   * @returns {void}\n   */\n  function forTextNodesInTree(elem, nodes, exclude = false) {\n    const children = elem.childNodes;\n    for (const filter of excludeFilters) {\n      if (filter(elem)) {\n        exclude = true;\n        break;\n      }\n    }\n    for (const child of children) {\n      if (child.nodeType === Node.ELEMENT_NODE) {\n        const style = window.getComputedStyle(child);\n        if (\n          child.tagName !== \"BR\" &&\n          (style === \"inline\" || style === \"inline-block\")\n        ) {\n          forTextNodesInTree(child, nodes, exclude);\n        } else {\n          if (nodes[nodes.length - 1].length > 0) {\n            nodes.push([]);\n          }\n          forTextNodesInTree(child, nodes, exclude);\n        }\n      } else if (\n        !exclude &&\n        child.nodeType === Node.TEXT_NODE &&\n        child.textContent.length > 0\n      ) {\n        nodes[nodes.length - 1].push(child);\n      }\n    }\n  }\n\n  function makeBionic() {\n    const cardContainer = document.getElementById(\"container\");\n    cardContainer.normalize();\n\n    let nodesLines = [[]];\n    forTextNodesInTree(cardContainer, nodesLines);\n    for (const nodes of nodesLines) {\n      BionicReaderBolder.run(nodes);\n    }\n\n    cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n      \"<strong></strong>\",\n      \"\"\n    );\n    cardContainer.normalize();\n  }\n\n  let start = performance.now();\n  if (bionicReading) {\n    makeBionic();\n  }\n  let end = performance.now();\n  console.log(`Initialized bionic reading: ${end - start}ms`);\n})();\n</script>\n\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\nvar userJs1 = undefined\nvar userJs2 = undefined\nvar userJs3 = undefined\nvar userJs4 = undefined\nvar userJs5 = undefined\nvar userJs6 = undefined\nvar userJs7 = undefined\nvar userJs8 = undefined\n</script>\n",
      "bqfmt": "{{Titel}}",
      "bafmt": "{{Markierung 9}}",
      "did": null,
      "bfont": "Helvetica",
      "bsize": 12
    },
    {
      "name": "Markierung 10",
      "ord": 9,
      "qfmt": "<!-- version 0fd8612 -->\n{{#Markierung 10}}\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TIMER CONFIG  ##############\n// Timer config (timer length, timer finished message)\nvar minutes =  0\nvar seconds = 15\nvar timeOverMsg = \"<span style='color:#CC5B5B'>!!!</span>\"\n\n  // ##############  TAG SHORTCUT  ##############\nvar toggleTagsShortcut = \"C\";\n\n// ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\nvar tagID = \"XXXYYYZZZ\"\n\n// WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\nvar numTagLevelsToShow = 0;\n\n// ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\nvar tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n// Enable experimental heuristic indentation feature\nvar indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n// Enable experimental DIVI medication formatting feature\nvar formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n// Enable experimental confounder formatting feature\nvar formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n// Enable bionic reading feature (based on AnKing add-on)\nvar bionicReading = false;\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button\n        id=\"button-tags\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n      >\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button\n        id=\"button-src\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n      >\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button\n        id=\"button-nid\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n      >\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button\n          id=\"button-ankihub\"\n          class=\"button-general\"\n          title=\"Karte in AnkiHub\"\n        >\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) {}\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button\n      id=\"button-tags\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button\n      id=\"button-src\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">Quelle: {{Quelle}}</div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button\n      id=\"button-nid\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    <i>Was</i> wird hier bei <b>⑩</b> gezeigt?\n\n    <br>\n    <br>\n\n    {{#Hint / Hinweis}}\n      <span style=\"color:IndianRed; font-weight: bold;\">Hinweis:</span> {{hint:Hint / Hinweis}}\n\n      <br>\n      <br>\n    {{/Hint / Hinweis}}\n    \n    {{Bild}}\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\"></div>\n\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n<script>\n  //DONT FADE BETWEEN CARDS\n  qFade = 0;\n  if (typeof anki !== 'undefined') anki.qFade = qFade;\n</script>\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\nfunction getTextWidth(text, font) {\n // re-use canvas object for better performance\n const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n const context = canvas.getContext(\"2d\");\n context.font = font;\n const metrics = context.measureText(text);\n return metrics.width;\n}\n\nfunction getCSSStyle(element, prop) {\n return window.getComputedStyle(element, null).getPropertyValue(prop);\n}\n\nfunction getCanvasFont(el = document.body) {\n const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n const fontSize = getCSSStyle(el, 'font-size') || '16px';\n const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n return `${fontWeight} ${fontSize} ${fontFamily}`;\n}\n\n/**\n* Iterates over a list of divs containing text to be indented\n*\n* @param {HTMLCollection} divs: The divs to be iterated over.\n*/\nfunction indentText(divs) {\n // setup the indentation markers\n var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n var bulletP = \"•\"\n var minus = \"– \"\n var enter = \"↳(?!( ↳|↳))\"\n var arrow = \"→\"\n\n // heuristic indentation hierarchy\n hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n // set up RegEx to analyze the provided divs\n // negative lookbehinds unfortunately do not work yet on iPad / Android\n var beginning = '(?<=<br>)(?<!cloze=\")('\n var middle = \".*?)((?:<br>)(?=(\"\n var end = \"))|(?=(<\\/indent>|<\\/div>|<br><br>)))\"\n\n const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n // iterate over divs\n for (const div of divs) {\n   // calculate indentation depths\n   var canvasFont = getCanvasFont(div)\n   var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n   var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n   var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n   var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n   var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n   var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n   var indentEnd = ';\">$1</indent>'\n\n   // do the indentation\n   divHTML = div.outerHTML\n   divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n   divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n   div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\")\n }\n}\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function(type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function(ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n  <script>\n    var tagContainer = document.getElementById(\"tags-container\")\n\n    if (tagContainer.childElementCount == 0) {\n      var tagList = tagContainer.innerHTML.trim().split(\" \");\n      var kbdList = [];\n      var newTagContent = document.createElement(\"div\");\n\n      for (var i = 0; i < tagList.length; i++) {\n        var newTag = document.createElement(\"kbd\");\n        var tag = tagList[i];\n        // numTagLevelsToShow == 0 means the whole tag should be shown\n        if (numTagLevelsToShow != 0) {\n          tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n        }\n\n        // Zankiphil / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n        if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) continue;\n        if (tag.split(\"::\")[1] == \"!NEW_CARDS\") continue;\n        if (tag.split(\"::\")[1] == \"§Projekt_Anki\") continue;\n        if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") continue;\n\n        // improve legibility of tags\n        tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n        tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\");\n        tag = tag.replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n        newTag.innerHTML = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"_\", \" \");\n        newTagContent.append(newTag)\n      }\n\n      tagContainer.innerHTML = newTagContent.innerHTML;\n      tagContainer.style.cursor = \"default\";\n    }\n\n    if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n      tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n    }\n\n    function showtags() {\n      var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n      if (tagContainerShortcut.style.display === \"none\") {\n        tagContainerShortcut.style.display = \"inline\";\n      } else {\n        tagContainerShortcut.style.display = \"none\";\n      }\n    }\n\n    var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n    ankingAddEventListener('keyup', function (e) {\n      if (isShortcut(e)) {\n        toggleHintBtn('hint-tags');\n        showtags();\n      }\n    });\n  </script>\n  <script>\n    for (const tag of document.getElementsByTagName('kbd')) {\n      tag.innerHTML = tag.innerHTML.replace(/::/g, '::<wbr>')\n    }\n  </script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (el.style.display === 'none') {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits( n ) {\n      return (n <= 9 ? \"0\" + n : n); \n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n      \n      if ( msLeft < 1000 ) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date( msLeft );\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout( updateTimer, time.getUTCMilliseconds() + 500 );\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60*minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds ); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function(key, dictionary){\n        return dictionary[key];\n      }\n    }\n    \n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n      \n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n      \n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n/**\n * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n * Full credit to the original authors, except where modified or otherwise indicated.\n */\n\n/**\n *\n * We try to respect that people use various note types\n * which may do 'weird' stuff.\n * Elements may have event listeners that can be removed if we just innerHTML stuff\n * <i> may be styled 'i { display: block }', etc.\n *\n * Another problem that complicate the design of this script is that\n * a word may not be cleanly separated by html tags.\n * e.g. \"A<i>long</i>word\"\n *\n */\n\n(function () {\n  /**\n   * @param {String} text\n   * @returns {number}\n   */\n  function getBoldLength(text) {\n    return Math.floor(text.length / 2);\n  }\n\n  // Ignore node if any of the filters return true\n  const excludeFilters = [\n    (elem) => elem.tagName === \"SCRIPT\",\n    (elem) => elem.tagName === \"STYLE\",\n    (elem) => elem.classList.contains(\"cloze\"),\n  ];\n\n  function newBoldElement(text) {\n    const elem = document.createElement(\"strong\");\n    elem.innerText = text;\n    return elem;\n  }\n\n  function indexOfWhitespace(text, startPos) {\n    const whitespaces = [\n      \" \",\n      \"\\n\",\n      \"\\t\",\n      \" \",\n      \"&nbsp;\",\n      \"‑\",\n      \"-\",\n      \"/\",\n      \"(\",\n      \")\",\n    ];\n    let nextPos = text.length;\n    for (const whitespace of whitespaces) {\n      const next = text.indexOf(whitespace, startPos);\n      if (next !== -1 && next < nextPos) {\n        nextPos = next;\n      }\n    }\n    if (nextPos === text.length) {\n      nextPos = -1;\n    }\n    return nextPos;\n  }\n\n  // Bolds a line of words\n  class BionicReaderBolder {\n    constructor(nodes) {\n      this.nodes = nodes;\n      this.startNodeIndex = 0;\n      this.startPos = 0;\n      this.replaceNodes = [];\n      while (!this.isFinished()) {\n        this.runWithinNode();\n        this.runInterNode();\n      }\n    }\n\n    static run(nodes) {\n      new BionicReaderBolder(nodes);\n    }\n\n    isFinished() {\n      return this.startNodeIndex === this.nodes.length;\n    }\n\n    replaceNode() {\n      const node = this.nodes[this.startNodeIndex];\n      const parent = node.parentNode;\n      for (let add of this.replaceNodes) {\n        parent.insertBefore(add, node);\n      }\n      parent.removeChild(node);\n      this.replaceNodes = [];\n    }\n\n    runWithinNode() {\n      const textContent = this.nodes[this.startNodeIndex].textContent;\n      let nextPos = indexOfWhitespace(textContent, this.startPos);\n      while (nextPos !== -1) {\n        const word = textContent.substring(this.startPos, nextPos);\n        const boldLength = getBoldLength(word);\n        this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n        this.replaceNodes.push(\n          document.createTextNode(\n            word.substring(boldLength, nextPos) + textContent[nextPos]\n          )\n        );\n        this.startPos = nextPos + 1;\n        nextPos = indexOfWhitespace(textContent, this.startPos);\n      }\n    }\n\n    // after this, startPos is likely to be at whitespace char\n    runInterNode() {\n      let word = \"\";\n      let endNodeIndex = this.startNodeIndex;\n      let endPos = this.startPos; // last word char pos + 1\n\n      // Find word boundary\n      while (endNodeIndex < this.nodes.length) {\n        const textContent = this.nodes[endNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, endPos);\n        if (nextPos === -1) {\n          word += textContent.substring(endPos);\n          endNodeIndex += 1;\n          endPos = 0;\n        } else {\n          word += textContent.substring(endPos, nextPos);\n          endPos = nextPos;\n          break;\n        }\n      }\n      // Calculate bold length\n      let remainingBoldLength = getBoldLength(word);\n\n      // Bold part of word\n      while (remainingBoldLength > 0) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        if (remainingBoldLength > textContent.length - this.startPos) {\n          const wordPart = textContent.substring(this.startPos);\n          remainingBoldLength -= wordPart.length;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        } else {\n          const wordPart = textContent.substring(\n            this.startPos,\n            this.startPos + remainingBoldLength\n          );\n          this.startPos += remainingBoldLength;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          remainingBoldLength -= wordPart.length;\n        }\n      }\n\n      // Add non-bolded part of words\n      while (this.startNodeIndex < endNodeIndex) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.replaceNode();\n        this.startNodeIndex += 1;\n        this.startPos = 0;\n      }\n\n      if (this.startPos < endPos) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos, endPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.startPos = endPos;\n      }\n    }\n  }\n\n  /**\n   * Builds a list of (list of nodes that makes up one non-line-broken line)\n   * @param {Node} elem\n   * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n   * @returns {void}\n   */\n  function forTextNodesInTree(elem, nodes, exclude = false) {\n    const children = elem.childNodes;\n    for (const filter of excludeFilters) {\n      if (filter(elem)) {\n        exclude = true;\n        break;\n      }\n    }\n    for (const child of children) {\n      if (child.nodeType === Node.ELEMENT_NODE) {\n        const style = window.getComputedStyle(child);\n        if (\n          child.tagName !== \"BR\" &&\n          (style === \"inline\" || style === \"inline-block\")\n        ) {\n          forTextNodesInTree(child, nodes, exclude);\n        } else {\n          if (nodes[nodes.length - 1].length > 0) {\n            nodes.push([]);\n          }\n          forTextNodesInTree(child, nodes, exclude);\n        }\n      } else if (\n        !exclude &&\n        child.nodeType === Node.TEXT_NODE &&\n        child.textContent.length > 0\n      ) {\n        nodes[nodes.length - 1].push(child);\n      }\n    }\n  }\n\n  function makeBionic() {\n    const cardContainer = document.getElementById(\"container\");\n    cardContainer.normalize();\n\n    let nodesLines = [[]];\n    forTextNodesInTree(cardContainer, nodesLines);\n    for (const nodes of nodesLines) {\n      BionicReaderBolder.run(nodes);\n    }\n\n    cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n      \"<strong></strong>\",\n      \"\"\n    );\n    cardContainer.normalize();\n  }\n\n  let start = performance.now();\n  if (bionicReading) {\n    makeBionic();\n  }\n  let end = performance.now();\n  console.log(`Initialized bionic reading: ${end - start}ms`);\n})();\n</script>\n\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\nvar userJs1 = undefined\nvar userJs2 = undefined\nvar userJs3 = undefined\nvar userJs4 = undefined\nvar userJs5 = undefined\nvar userJs6 = undefined\nvar userJs7 = undefined\nvar userJs8 = undefined\n</script>\n\n\n{{/Markierung 10}}",
      "afmt": "<!-- version 0fd8612 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Eigene Notizen & Bilder\": \"Alt + 1\",\n    \"Eigene Prüfungsfragen\": \"Alt + 2\",\n    \"Definitionen\": \"Alt + 3\",\n    \"Merksprüche\": \"Alt + 4\",\n    \"Klinik\": \"Alt + 5\",\n    \"Präparat\": \"Alt + 6\",\n    \"Memes\": \"Alt + 7\",\n    \"linkContainer\": \"Alt + L\",\n    \"Meditricks\": \"Alt + M\",\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Eigene Notizen & Bilder\": false,\n    \"Eigene Prüfungsfragen\": false,\n    \"Definitionen\": false,\n    \"Merksprüche\": false,\n    \"Klinik\": false,\n    \"Präparat\": false,\n    \"Memes\": false,\n    \"linkContainer\": true,\n    \"Meditricks\": false,\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\":false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\nvar toggleTagsShortcut = \"C\";\n\n// ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\nvar tagID = \"XXXYYYZZZ\"\n\n// WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\nvar numTagLevelsToShow = 0;\n\n// ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\nvar tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n// Enable experimental heuristic indentation feature\nvar indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n// Enable experimental DIVI medication formatting feature\nvar formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n// Enable experimental confounder formatting feature\nvar formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n// Enable bionic reading feature (based on AnKing add-on)\nvar bionicReading = false;\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button\n        id=\"button-tags\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n      >\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button\n        id=\"button-src\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n      >\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button\n        id=\"button-nid\"\n        class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n      >\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button\n          id=\"button-ankihub\"\n          class=\"button-general\"\n          title=\"Karte in AnkiHub\"\n        >\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) {}\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button\n      id=\"button-tags\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button\n      id=\"button-src\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">Quelle: {{Quelle}}</div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button\n      id=\"button-nid\"\n      style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"\n    ></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    <i>Was</i> wird hier bei <b>⑩</b> gezeigt?\n\n    <br>\n    <br>\n\n    {{#Hint / Hinweis}}\n      <span style=\"color:IndianRed; font-weight: bold;\">Hinweis:</span> {{hint:Hint / Hinweis}}\n\n      <br>\n      <br>\n    {{/Hint / Hinweis}}\n    \n    {{Bild}}\n\n    <br>\n    <br>\n\n    <span class=\"cloze\">{{Markierung 10}}</span>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- BUTTON FIELDS -->\n    {{#Eigene Notizen & Bilder}}\n  <span id=\"hint-zusatz\" class=\"hintBtn\" data-name=\"Eigene Notizen & Bilder\" style=\"display: none;\">\n    <button id=\"button-zusatz\" class=\"button-general\" onclick=\"toggleHintBtn('hint-zusatz'); event.stopPropagation()\">\n      <img src=\"__zusatz.svg\" style=\"height: 10px;\"> Eigene Notizen & Bilder\n    </button>\n    <div id=\"zusatz\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Notizen & Bilder}}</div>\n  </span>\n{{/Eigene Notizen & Bilder}}\n\n    {{#Eigene Prüfungsfragen}}\n  <span id=\"hint-hammer\" class=\"hintBtn\" data-name=\"Eigene Prüfungsfragen\" style=\"display: none;\">\n    <button id=\"button-hammer\" class=\"button-general\" onclick=\"toggleHintBtn('hint-hammer'); event.stopPropagation()\">\n      <img src=\"__hammer.svg\" style=\"height: 10px;\"> Eigene Prüfungsfragen\n    </button>\n    <div id=\"hammer\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Prüfungsfragen}}</div>\n  </span>\n{{/Eigene Prüfungsfragen}}\n\n    {{#Definitionen}}\n  <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Definitionen\" style=\"display: none;\">\n    <button id=\"button-definition\" class=\"button-general\" onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n      <img src=\"__explanation.svg\" style=\"height: 10px;\"> Definitionen\n    </button>\n    <div id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Definitionen}}</div>\n  </span>\n{{/Definitionen}}\n\n    {{#Merksprüche}}\n  <span id=\"hint-merksprueche\" class=\"hintBtn\" data-name=\"Merksprüche\" style=\"display: none;\">\n    <button id=\"button-merksprueche\" class=\"button-general\" onclick=\"toggleHintBtn('hint-merksprueche'); event.stopPropagation()\">\n      <img src=\"__merkhilfe.svg\" style=\"height: 10px;\"> Merksprüche\n    </button>\n    <div id=\"merksprueche\" class=\"hints\" style=\"display: none;\">{{edit:Merksprüche}}</div>\n  </span>\n{{/Merksprüche}}\n\n    {{#Klinik}}\n  <span id=\"hint-klinik\" class=\"hintBtn\" data-name=\"Klinik\" style=\"display: none;\">\n    <button id=\"button-klinik\" class=\"button-general\" onclick=\"toggleHintBtn('hint-klinik'); event.stopPropagation()\">\n      <img src=\"__stethoscope.svg\" style=\"height: 10px;\"> Klinik\n    </button>\n    <div id=\"klinik\" class=\"hints\" style=\"display: none;\">{{edit:Klinik}}</div>\n  </span>\n{{/Klinik}}\n\n    {{#Präparat}}\n      <span id=\"hint-praeparat-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Präparat}}\">\n          <button id=\"button-praeparat\" class=\"button-general\">\n            <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n          </button>\n        </a>\n      </span>\n    {{/Präparat}}\n\n    {{#Virtuelle Mikroskopie}}\n      <span id=\"hint-microscope-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Virtuelle Mikroskopie}}\">\n          <button id=\"button-microscope\" class=\"button-general\">\n            <img src=\"__microscope.svg\" style=\"height: 10px;\"> Virtuelle Mikroskopie\n          </button>\n        </a>\n      </span>\n    {{/Virtuelle Mikroskopie}}\n\n    {{#Smart Zoom}}\n      <span id=\"hint-smartzoom-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Präparat}}\">\n          <button id=\"button-smartzoom\" class=\"button-general\">\n            <img src=\"__microscope.svg\" style=\"height: 10px;\"> Smart Zoom\n          </button>\n        </a>\n      </span>\n    {{/Smart Zoom}}\n\n    {{#HistoTrainer}}\n  <span id=\"hint-praeparat\" class=\"hintBtn\" data-name=\"HistoTrainer\" style=\"display: none;\">\n    <button id=\"button-praeparat\" class=\"button-general\" onclick=\"toggleHintBtn('hint-praeparat'); event.stopPropagation()\">\n      <img src=\"__microscope.svg\" style=\"height: 10px;\"> HistoTrainer\n    </button>\n    <div id=\"praeparat\" class=\"hints\" style=\"display: none;\">{{edit:HistoTrainer}}</div>\n  </span>\n{{/HistoTrainer}}\n\n    {{#Memes}}\n  <span id=\"hint-memes\" class=\"hintBtn\" data-name=\"Memes\" style=\"display: none;\">\n    <button id=\"button-memes\" class=\"button-general\" onclick=\"toggleHintBtn('hint-memes'); event.stopPropagation()\">\n      <img src=\"__sonstiges.svg\" style=\"height: 10px;\"> Memes\n    </button>\n    <div id=\"memes\" class=\"hints\" style=\"display: none;\">{{edit:Memes}}</div>\n  </span>\n{{/Memes}}\n\n    <!-- Extra field -->\n    {{#Extra}}\n      <div id=\"extra\" style=\"display: none;\">\n        <br><br>{{edit:Extra}}</div>\n    {{/Extra}}\n\n    {{#AMBOSS-Link}}\n      <span id=\"hint-amboss\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:AMBOSS-Link}}\">\n          <button id=\"button-amboss\" class=\"button-general\">\n            <img src=\"__amboss.svg\" style=\"height: 10px;\"> AMBOSS&#8203;\n          </button>\n        </a>\n      </span>\n    {{/AMBOSS-Link}}\n    \n    {{#Thieme via medici-Link}}\n      <span id=\"hint-thieme\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n        <a href=\"{{text:Thieme via medici-Link}}\">\n          <button id=\"button-thieme\" class=\"button-general\">\n            <img id=\"button-thieme-img\" src=\"__thieme-heart.svg\" style=\"height: 10px;\"> Thieme via medici\n          </button>\n        </a>\n      </span>\n    {{/Thieme via medici-Link}}\n\n    {{#Meditricks}}\n  <span id=\"hint-meditricks\" class=\"hintBtn\" data-name=\"Meditricks\" style=\"display: none;\">\n    <button id=\"button-meditricks\" class=\"button-general\" onclick=\"toggleHintBtn('hint-meditricks'); event.stopPropagation()\">\n      <img src=\"__meditricks.svg\" style=\"height: 10px;\"> Meditricks\n    </button>\n    <div id=\"meditricks\" class=\"hints\" style=\"display: none;\">{{edit:Meditricks}}</div>\n  </span>\n{{/Meditricks}}\n\n    {{#weitere Links}}\n    <span id=\"hint-linkcontainer\" class=\"hintBtn\" data-name=\"linkContainer\" style=\"display: none;\">\n      <button id=\"button-linkcontainer\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-linkcontainer'); event.stopPropagation()\">\n        <img src=\"__internet.svg\" style=\"height: 10px;\"> weitere Links\n      </button>\n      <div id=\"linkcontainer\" class=\"hints\" style=\"display: none;\"></div>\n      <span id=\"linkContainerLinks\" style=\"display: none;\">{{edit:weitere Links}}</span>\n    </span>\n  {{/weitere Links}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function(type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function(ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n  <script>\n    var tagContainer = document.getElementById(\"tags-container\")\n\n    if (tagContainer.childElementCount == 0) {\n      var tagList = tagContainer.innerHTML.trim().split(\" \");\n      var kbdList = [];\n      var newTagContent = document.createElement(\"div\");\n\n      for (var i = 0; i < tagList.length; i++) {\n        var newTag = document.createElement(\"kbd\");\n        var tag = tagList[i];\n        // numTagLevelsToShow == 0 means the whole tag should be shown\n        if (numTagLevelsToShow != 0) {\n          tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n        }\n\n        // Zankiphil / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n        if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) continue;\n        if (tag.split(\"::\")[1] == \"!NEW_CARDS\") continue;\n        if (tag.split(\"::\")[1] == \"§Projekt_Anki\") continue;\n        if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") continue;\n\n        // improve legibility of tags\n        tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n        tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\");\n        tag = tag.replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n        newTag.innerHTML = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"_\", \" \");\n        newTagContent.append(newTag)\n      }\n\n      tagContainer.innerHTML = newTagContent.innerHTML;\n      tagContainer.style.cursor = \"default\";\n    }\n\n    if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n      tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n    }\n\n    function showtags() {\n      var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n      if (tagContainerShortcut.style.display === \"none\") {\n        tagContainerShortcut.style.display = \"inline\";\n      } else {\n        tagContainerShortcut.style.display = \"none\";\n      }\n    }\n\n    var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n    ankingAddEventListener('keyup', function (e) {\n      if (isShortcut(e)) {\n        toggleHintBtn('hint-tags');\n        showtags();\n      }\n    });\n  </script>\n  <script>\n    for (const tag of document.getElementsByTagName('kbd')) {\n      tag.innerHTML = tag.innerHTML.replace(/::/g, '::<wbr>')\n    }\n  </script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (el.style.display === 'none') {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n    try {\n        for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n            href = link.href\n            text = link.innerText\n\n            const el = document.createElement('a');\n            el.setAttribute('href', link.href);\n\n            const btn = document.createElement('button');\n            btn.classList.add('button-general');\n            btn.classList.add('expanded-button');\n\n            domain = href.replace(/.+\\/\\/|(www|flexikon|de|next|com).|\\..+/g, '');\n            domainDict = {\n                \"amboss\": \"__amboss.svg\",\n                \"wikipedia\": \"__wikipedia.svg\",\n                \"doccheck\": \"__doccheck.png\",\n                \"notfallguru\": \"__notfallguru.svg\",\n            }\n            if (domain in domainDict) {\n                icon = domainDict[domain]\n            } else {\n                icon = \"__internet.svg\"\n            }\n\n            const img = document.createElement('img');\n            img.setAttribute('src', icon);\n            img.setAttribute('style', 'height: 10px;');\n\n            btn.appendChild(img);\n            btn.innerHTML = btn.innerHTML + \" \" + text;\n\n            el.appendChild(btn);\n\n            document.getElementById(\"linkcontainer\").appendChild(el)\n        }\n    }\n    catch (err) {\n        console.log(err)\n    }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\nfunction getTextWidth(text, font) {\n // re-use canvas object for better performance\n const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n const context = canvas.getContext(\"2d\");\n context.font = font;\n const metrics = context.measureText(text);\n return metrics.width;\n}\n\nfunction getCSSStyle(element, prop) {\n return window.getComputedStyle(element, null).getPropertyValue(prop);\n}\n\nfunction getCanvasFont(el = document.body) {\n const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n const fontSize = getCSSStyle(el, 'font-size') || '16px';\n const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n return `${fontWeight} ${fontSize} ${fontFamily}`;\n}\n\n/**\n* Iterates over a list of divs containing text to be indented\n*\n* @param {HTMLCollection} divs: The divs to be iterated over.\n*/\nfunction indentText(divs) {\n // setup the indentation markers\n var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n var bulletP = \"•\"\n var minus = \"– \"\n var enter = \"↳(?!( ↳|↳))\"\n var arrow = \"→\"\n\n // heuristic indentation hierarchy\n hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n // set up RegEx to analyze the provided divs\n // negative lookbehinds unfortunately do not work yet on iPad / Android\n var beginning = '(?<=<br>)(?<!cloze=\")('\n var middle = \".*?)((?:<br>)(?=(\"\n var end = \"))|(?=(<\\/indent>|<\\/div>|<br><br>)))\"\n\n const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n // iterate over divs\n for (const div of divs) {\n   // calculate indentation depths\n   var canvasFont = getCanvasFont(div)\n   var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n   var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n   var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n   var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n   var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n   var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n   var indentEnd = ';\">$1</indent>'\n\n   // do the indentation\n   divHTML = div.outerHTML\n   divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n   divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n   divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n   divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n   //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n   div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\")\n }\n}\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits( n ) {\n      return (n <= 9 ? \"0\" + n : n); \n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n      \n      if ( msLeft < 1000 ) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date( msLeft );\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout( updateTimer, time.getUTCMilliseconds() + 500 );\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60*minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds ); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function(key, dictionary){\n        return dictionary[key];\n      }\n    }\n    \n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n      \n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n      \n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n/**\n * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n * Full credit to the original authors, except where modified or otherwise indicated.\n */\n\n/**\n *\n * We try to respect that people use various note types\n * which may do 'weird' stuff.\n * Elements may have event listeners that can be removed if we just innerHTML stuff\n * <i> may be styled 'i { display: block }', etc.\n *\n * Another problem that complicate the design of this script is that\n * a word may not be cleanly separated by html tags.\n * e.g. \"A<i>long</i>word\"\n *\n */\n\n(function () {\n  /**\n   * @param {String} text\n   * @returns {number}\n   */\n  function getBoldLength(text) {\n    return Math.floor(text.length / 2);\n  }\n\n  // Ignore node if any of the filters return true\n  const excludeFilters = [\n    (elem) => elem.tagName === \"SCRIPT\",\n    (elem) => elem.tagName === \"STYLE\",\n    (elem) => elem.classList.contains(\"cloze\"),\n  ];\n\n  function newBoldElement(text) {\n    const elem = document.createElement(\"strong\");\n    elem.innerText = text;\n    return elem;\n  }\n\n  function indexOfWhitespace(text, startPos) {\n    const whitespaces = [\n      \" \",\n      \"\\n\",\n      \"\\t\",\n      \" \",\n      \"&nbsp;\",\n      \"‑\",\n      \"-\",\n      \"/\",\n      \"(\",\n      \")\",\n    ];\n    let nextPos = text.length;\n    for (const whitespace of whitespaces) {\n      const next = text.indexOf(whitespace, startPos);\n      if (next !== -1 && next < nextPos) {\n        nextPos = next;\n      }\n    }\n    if (nextPos === text.length) {\n      nextPos = -1;\n    }\n    return nextPos;\n  }\n\n  // Bolds a line of words\n  class BionicReaderBolder {\n    constructor(nodes) {\n      this.nodes = nodes;\n      this.startNodeIndex = 0;\n      this.startPos = 0;\n      this.replaceNodes = [];\n      while (!this.isFinished()) {\n        this.runWithinNode();\n        this.runInterNode();\n      }\n    }\n\n    static run(nodes) {\n      new BionicReaderBolder(nodes);\n    }\n\n    isFinished() {\n      return this.startNodeIndex === this.nodes.length;\n    }\n\n    replaceNode() {\n      const node = this.nodes[this.startNodeIndex];\n      const parent = node.parentNode;\n      for (let add of this.replaceNodes) {\n        parent.insertBefore(add, node);\n      }\n      parent.removeChild(node);\n      this.replaceNodes = [];\n    }\n\n    runWithinNode() {\n      const textContent = this.nodes[this.startNodeIndex].textContent;\n      let nextPos = indexOfWhitespace(textContent, this.startPos);\n      while (nextPos !== -1) {\n        const word = textContent.substring(this.startPos, nextPos);\n        const boldLength = getBoldLength(word);\n        this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n        this.replaceNodes.push(\n          document.createTextNode(\n            word.substring(boldLength, nextPos) + textContent[nextPos]\n          )\n        );\n        this.startPos = nextPos + 1;\n        nextPos = indexOfWhitespace(textContent, this.startPos);\n      }\n    }\n\n    // after this, startPos is likely to be at whitespace char\n    runInterNode() {\n      let word = \"\";\n      let endNodeIndex = this.startNodeIndex;\n      let endPos = this.startPos; // last word char pos + 1\n\n      // Find word boundary\n      while (endNodeIndex < this.nodes.length) {\n        const textContent = this.nodes[endNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, endPos);\n        if (nextPos === -1) {\n          word += textContent.substring(endPos);\n          endNodeIndex += 1;\n          endPos = 0;\n        } else {\n          word += textContent.substring(endPos, nextPos);\n          endPos = nextPos;\n          break;\n        }\n      }\n      // Calculate bold length\n      let remainingBoldLength = getBoldLength(word);\n\n      // Bold part of word\n      while (remainingBoldLength > 0) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        if (remainingBoldLength > textContent.length - this.startPos) {\n          const wordPart = textContent.substring(this.startPos);\n          remainingBoldLength -= wordPart.length;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        } else {\n          const wordPart = textContent.substring(\n            this.startPos,\n            this.startPos + remainingBoldLength\n          );\n          this.startPos += remainingBoldLength;\n          this.replaceNodes.push(newBoldElement(wordPart));\n          remainingBoldLength -= wordPart.length;\n        }\n      }\n\n      // Add non-bolded part of words\n      while (this.startNodeIndex < endNodeIndex) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.replaceNode();\n        this.startNodeIndex += 1;\n        this.startPos = 0;\n      }\n\n      if (this.startPos < endPos) {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        const wordPart = textContent.substring(this.startPos, endPos);\n        if (wordPart.length > 0) {\n          this.replaceNodes.push(document.createTextNode(wordPart));\n        }\n        this.startPos = endPos;\n      }\n    }\n  }\n\n  /**\n   * Builds a list of (list of nodes that makes up one non-line-broken line)\n   * @param {Node} elem\n   * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n   * @returns {void}\n   */\n  function forTextNodesInTree(elem, nodes, exclude = false) {\n    const children = elem.childNodes;\n    for (const filter of excludeFilters) {\n      if (filter(elem)) {\n        exclude = true;\n        break;\n      }\n    }\n    for (const child of children) {\n      if (child.nodeType === Node.ELEMENT_NODE) {\n        const style = window.getComputedStyle(child);\n        if (\n          child.tagName !== \"BR\" &&\n          (style === \"inline\" || style === \"inline-block\")\n        ) {\n          forTextNodesInTree(child, nodes, exclude);\n        } else {\n          if (nodes[nodes.length - 1].length > 0) {\n            nodes.push([]);\n          }\n          forTextNodesInTree(child, nodes, exclude);\n        }\n      } else if (\n        !exclude &&\n        child.nodeType === Node.TEXT_NODE &&\n        child.textContent.length > 0\n      ) {\n        nodes[nodes.length - 1].push(child);\n      }\n    }\n  }\n\n  function makeBionic() {\n    const cardContainer = document.getElementById(\"container\");\n    cardContainer.normalize();\n\n    let nodesLines = [[]];\n    forTextNodesInTree(cardContainer, nodesLines);\n    for (const nodes of nodesLines) {\n      BionicReaderBolder.run(nodes);\n    }\n\n    cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n      \"<strong></strong>\",\n      \"\"\n    );\n    cardContainer.normalize();\n  }\n\n  let start = performance.now();\n  if (bionicReading) {\n    makeBionic();\n  }\n  let end = performance.now();\n  console.log(`Initialized bionic reading: ${end - start}ms`);\n})();\n</script>\n\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\nvar userJs1 = undefined\nvar userJs2 = undefined\nvar userJs3 = undefined\nvar userJs4 = undefined\nvar userJs5 = undefined\nvar userJs6 = undefined\nvar userJs7 = undefined\nvar userJs8 = undefined\n</script>\n",
      "bqfmt": "{{Titel}}",
      "bafmt": "{{Markierung 10}}",
      "did": null,
      "bfont": "Helvetica",
      "bsize": 12
    }
  ],
  "flds": [
    {
      "name": "Titel",
      "ord": 0,
      "sticky": false,
      "rtl": false,
      "size": 16,
      "font": "Helvetica",
      "media": []
    },
    {
      "name": "Hint / Hinweis",
      "ord": 1,
      "sticky": false,
      "rtl": false,
      "size": 16,
      "font": "Helvetica",
      "media": []
    },
    {
      "name": "Bild",
      "ord": 2,
      "sticky": false,
      "rtl": false,
      "size": 16,
      "font": "Helvetica",
      "media": []
    },
    {
      "name": "Markierung 1",
      "ord": 3,
      "sticky": false,
      "rtl": false,
      "size": 16,
      "font": "Helvetica",
      "media": []
    },
    {
      "name": "Markierung 2",
      "ord": 4,
      "sticky": false,
      "rtl": false,
      "size": 16,
      "font": "Helvetica",
      "media": []
    },
    {
      "name": "Markierung 3",
      "ord": 5,
      "sticky": false,
      "rtl": false,
      "size": 16,
      "font": "Helvetica",
      "media": []
    },
    {
      "name": "Markierung 4",
      "ord": 6,
      "sticky": false,
      "rtl": false,
      "size": 16,
      "font": "Helvetica",
      "media": []
    },
    {
      "name": "Markierung 5",
      "ord": 7,
      "sticky": false,
      "rtl": false,
      "size": 16,
      "font": "Helvetica",
      "media": []
    },
    {
      "name": "Markierung 6",
      "ord": 8,
      "sticky": false,
      "rtl": false,
      "size": 16,
      "font": "Helvetica",
      "media": []
    },
    {
      "name": "Markierung 7",
      "ord": 9,
      "sticky": false,
      "rtl": false,
      "size": 16,
      "font": "Helvetica",
      "media": []
    },
    {
      "name": "Markierung 8",
      "ord": 10,
      "sticky": false,
      "rtl": false,
      "size": 16,
      "font": "Helvetica",
      "media": []
    },
    {
      "name": "Markierung 9",
      "ord": 11,
      "sticky": false,
      "rtl": false,
      "size": 16,
      "font": "Helvetica",
      "media": []
    },
    {
      "name": "Markierung 10",
      "ord": 12,
      "sticky": false,
      "rtl": false,
      "size": 16,
      "font": "Helvetica",
      "media": []
    },
    {
      "name": "Extra",
      "ord": 13,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": []
    },
    {
      "name": "Eigene Notizen & Bilder",
      "ord": 14,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": []
    },
    {
      "name": "Eigene Prüfungsfragen",
      "ord": 15,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": []
    },
    {
      "name": "Definitionen",
      "ord": 16,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": []
    },
    {
      "name": "Merksprüche",
      "ord": 17,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": []
    },
    {
      "name": "Klinik",
      "ord": 18,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": []
    },
    {
      "name": "Präparat",
      "ord": 19,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": []
    },
    {
      "name": "Virtuelle Mikroskopie",
      "ord": 20,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": []
    },
    {
      "name": "Smart Zoom",
      "ord": 21,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": []
    },
    {
      "name": "HistoTrainer",
      "ord": 22,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": []
    },
    {
      "name": "Memes",
      "ord": 23,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": []
    },
    {
      "name": "Meditricks",
      "ord": 24,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": []
    },
    {
      "name": "AMBOSS-Link",
      "ord": 25,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": []
    },
    {
      "name": "Thieme via medici-Link",
      "ord": 26,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": []
    },
    {
      "name": "weitere Links",
      "ord": 27,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": []
    },
    {
      "name": "Quelle",
      "ord": 28,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": []
    },
    {
      "name": "Datum",
      "ord": 29,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": []
    },
    {
      "name": "Note ID",
      "ord": 30,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": [],
      "meta": "noteid"
    }
  ],
  "css": "",
  "latexPre": "\\documentclass[12pt]{article}\n\\special{papersize=3in,5in}\n\\usepackage{amssymb,amsmath}\n\\pagestyle{empty}\n\\setlength{\\parindent}{0in}\n\\begin{document}\n",
  "latexPost": "\\end{document}",
  "latexsvg": true,
  "req": [
    [
      0,
      "any",
      [
        0
      ]
    ]
  ],
  "tags": [],
  "vers": []
}