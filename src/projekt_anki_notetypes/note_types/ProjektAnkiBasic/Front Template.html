<!-- version cf33cbe -->
<script>
  // ############## USER CONFIGURATION START ##############
  // ##############  HINT REVEAL SHORTCUTS  ##############
  // All shortcuts will also open with "H" if using the Hint Hotkeys add-on 
  var ButtonShortcuts = {
    "Tags": "Alt + 8",
    "Subdeck": "Alt + 9",
    "Note ID": "Alt + 0"
  }
  var ToggleNextButtonShortcut = "H"
  var ToggleAllButtonsShortcut = "J"
  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)

  // ##############  SHOW HINTS AUTOMATICALLY  ##############
  var ButtonAutoReveal = {
    "Tags": false,
    "Subdeck": false,
    "Note ID": false
  }
  var ScrollToButton = false;

  // ##############  TAG SHORTCUT  ##############
var toggleTagsShortcut = "C";

// ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND
var tagID = "XXXYYYZZZ"

// WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN
var numTagLevelsToShow = 0;

// ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN
var tagUniversity = "XXXYYYZZZ"

  // ##############  INDENTATION  ##############
// Enable experimental heuristic indentation feature
var indentation = true;

  // ############### USER CONFIGURATION END ###############
</script>

<!-- ###################################### -->
<!-- ##############  HEADER  ############## -->
<!-- ###################################### -->
<div id="header-container">
  <div class="header">
    <div class="head-flex-mid">
      <!-- TAGS FIELD -->
      {{#Tags}}
        <button id="button-tags" class="button-general headhov" onclick="toggleHintBtn('hint-tags'); event.stopPropagation()">
          Tags
        </button> |
      {{/Tags}}

      <!-- SOURCE FIELD -->
      {{#Subdeck}}
        <button id="button-src" class="button-general headhov" onclick="toggleHintBtn('hint-src'); event.stopPropagation()">
          Subdeck
        </button> |
      {{/Subdeck}}

      <!-- NOTE ID FIELD -->
      {{#Note ID}}
        <button id="button-nid" class="button-general headhov" onclick="toggleHintBtn('hint-nid'); event.stopPropagation()">
          Note ID
        </button>
      {{/Note ID}}
    </div>
  </div>

  <!-- CLICKABLE COLORFUL TAGS -->
  {{#Tags}}
    <span id="hint-tags" class="hintBtn" data-name="Tags" style="display: flex;">
      <button id="button-tags" style="all: unset !important; display: none;" onclick="toggleHintBtn('hint-tags'); event.stopPropagation()"></button>
      <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->
      <div id="tags-container" class="hints" style="display: none;">{{clickable::Tags}}</div>
    </span>
  {{/Tags}}
  {{#Subdeck}}
    <span id="hint-src" class="hintBtn" data-name="Quelle" style="display: flex;">
      <button id="button-src" style="all: unset !important; display: none;" onclick="toggleHintBtn('hint-src'); event.stopPropagation()"></button>
      <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->
      <div id="src" class="hints" style="display: none;">Subdeck: {{Subdeck}}</div>
    </span>
  {{/Subdeck}}
  {{#Note ID}}
    <span id="hint-nid" class="hintBtn" data-name="Note ID" style="display: flex;">
      <button id="button-nid" style="all: unset !important; display: none;" onclick="toggleHintBtn('hint-nid'); event.stopPropagation()"></button>
      <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->
      <div id="nid" class="hints" style="display: none;">ID: {{Note ID}}</div>
    </span>
  {{/Note ID}}

  <hr>

</div>

<div id="container">
  <div class="col" id="content">

    <!-- ####################################### -->
    <!-- ##############  CONTENT  ############## -->
    <!-- ####################################### -->

    <div>{{Vorderseite}}</div>

  </div>
</div>

<!-- ##############  TEXT-TO-SPEECH ##############
replace the arrows/dashes from the statement below with double curly brackets-->
<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->

<!-- ####################################### -->
<!-- ##############  SCRIPTS  ############## -->
<!-- ####################################### -->
<!-- INDENTING -->
<script>
  /**
   * Uses canvas.measureText to compute and return the width of the given text of given font in pixels.
   * 
   * @param {String} text: The text to be rendered.
   * @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. "bold 14px verdana").
   * 
   * @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393
   */
  function getTextWidth(text, font) {
    // re-use canvas object for better performance
    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement("canvas"));
    const context = canvas.getContext("2d");
    context.font = font;
    const metrics = context.measureText(text);
    return metrics.width;
  }

  function getCSSStyle(element, prop) {
    return window.getComputedStyle(element, null).getPropertyValue(prop);
  }

  function getCanvasFont(el = document.body) {
    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';
    const fontSize = getCSSStyle(el, 'font-size') || '16px';
    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';

    return `${fontWeight} ${fontSize} ${fontFamily}`;
  }

  /**
   * Iterates over a list of divs containing text to be indented
   *
   * @param {HTMLCollection} divs: The divs to be iterated over.
   */
  function indentText(divs) {
    // if heuristic indentation is not wanted, don't indent
    if (!indentation) {
      return;
    }

    // setup the indentation markers
    var numbers = "(" + "⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳".split("").join("|") + ")"
    var letters = "(" + "ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ".split("").join("|") + ")"
    var bulletP = "•"
    var minus = "– "
    var enter = "↳"
    var arrow = "→"

    // heuristic indentation hierarchy
    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]

    // set up RegEx to analyze the provided divs
    // negative lookbehinds unfortunately do not work yet on iPad / Android
    var beginning = '(?<=<br>)(?<!cloze=")('
    var middle = ".*?)((?:<br>)(?=("
    var end = "))|(?=(<\/indent>|<\/div>|<br><br>)))"

    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + "))|(?=<\/div>|<br><br>))", "g")
    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, "g")
    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, "g")
    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, "g")
    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, "g")
    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, "g")

    // iterate over divs
    for (const div of divs) {
      // calculate indentation depths
      var canvasFont = getCanvasFont(div)
      var circledWidth = getTextWidth("① ", canvasFont).toString() + "px"
      var bulletPWidth = getTextWidth("• ", canvasFont).toString() + "px"
      var minusWidth = getTextWidth("– ", canvasFont).toString() + "px"
      var enterWidth = getTextWidth("↳ ", canvasFont).toString() + "px"
      var arrowWidth = getTextWidth("→ ", canvasFont).toString() + "px"

      var indentStart = '<indent style="margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;
      var indentEnd = ';">$1</indent>'

      // do the indentation
      divHTML = div.outerHTML
      divHTML = divHTML.replaceAll(/(\d|<sup>|<sub>)–(\d|<\/sup>|<\/sub>|&#8288;)/g, "$1‒$2").replaceAll("–&#8288;", "‒&#8288;")
      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)
      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)
      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)
      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)
      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)
      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)

      div.outerHTML = divHTML.replaceAll("<br></indent>", "</indent><br>").replaceAll("</indent><br><br>", "</indent><br>")
    }

    // remove uneeded EventListener -> see line 284
    window.removeEventListener('load', doIndentText)
  }

  // use a function for the EventListener in line 284
  function doIndentText() {
    indentText(document.getElementById("content").getElementsByTagName("div"));
    indentText(document.getElementById("buttons").getElementsByTagName("div"));
  }

  // do the indentation only after the text content of the card is loaded
  window.addEventListener('load', doIndentText, {
    once: true
  });
  dispatchEvent(new Event('load'));
</script>

<!-- NOT-PERSISTING EVENT LISTENER -->
<script>
  if (window.ankingEventListeners) {
    for (const listener of ankingEventListeners) {
      const type = listener[0]
      const handler = listener[1]
      document.removeEventListener(type, handler)
    }
  }
  window.ankingEventListeners = []

  window.ankingAddEventListener = function(type, handler) {
    document.addEventListener(type, handler)
    window.ankingEventListeners.push([type, handler])
  }
</script>

<!-- Shortcut Matcher Function -->
<script>
  var specialCharCodes = {
    "-": "minus",
    "=": "equal",
    "[": "bracketleft",
    "]": "bracketright",
    ";": "semicolon",
    "'": "quote",
    "`": "backquote",
    "\\": "backslash",
    ",": "comma",
    ".": "period",
    "/": "slash",
  };

  // Returns function that match keyboard event to see if it matches given shortcut.
  function shortcutMatcher(shortcut) {
    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())
    let mainKey = shortcutKeys[shortcutKeys.length - 1]
    if (mainKey.length === 1) {
      if (/\d/.test(mainKey)) {
        mainKey = "digit" + mainKey
      } else if (/[a-zA-Z]/.test(mainKey)) {
        mainKey = "key" + mainKey
      } else {
        let code = specialCharCodes[mainKey];
        if (code) {
          mainKey = code
        }
      }
    }
    let ctrl = shortcutKeys.includes("ctrl")
    let shift = shortcutKeys.includes("shift")
    let alt = shortcutKeys.includes("alt")

    let matchShortcut = function(ctrl, shift, alt, mainKey, event) {
      if (mainKey !== event.code.toLowerCase()) return false
      if (ctrl !== (event.ctrlKey || event.metaKey)) return false
      if (shift !== event.shiftKey) return false
      if (alt !== event.altKey) return false
      return true
    }.bind(window, ctrl, shift, alt, mainKey)

    return matchShortcut
  }
</script>

<!-- HINT BUTTONS SETUP -->
<script>
  (function() {
    window.toggleHintBtn = function(containerId, noScrolling = false) {
      const container = document.getElementById(containerId)
      const button = container.getElementsByTagName("button")[0]
      const hint = container.getElementsByTagName("div")[0]

      if (hint.style.display == "none") {
        button.classList.add("expanded-button")
        hint.style.display = button.classList.contains("headhov") ? "inline-block" : "block" // header hints have class headhov
        if (ScrollToButton && !noScrolling) {
          hint.scrollIntoView({
            behavior: "smooth", // "auto" for instant scrolling
            block: "start",
            inline: "nearest"
          });
        }
      } else {
        button.classList.remove("expanded-button")
        hint.style.display = "none"
      }
    }

    window.toggleNextButton = function() {
      // adapted from Hint Hotkey add-on
      var customEvent = document.createEvent('MouseEvents');
      customEvent.initEvent('click', false, true);
      var arr = document.querySelectorAll("span[data-name]");
      for (var i = 0; i < arr.length; i++) {
        var el = arr[i];

        if (el.getElementsByTagName("div")[0].style.display !== 'none') {
          continue;
        }

        el.getElementsByTagName("button")[0].dispatchEvent(customEvent);
        break;
      }
    }

    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)
    ankingAddEventListener("keydown", (evt) => {
      if (evt.repeat) return
      if (isToggleNextShortcut(evt)) {
        toggleNextButton()
      }
    })

    const setupHintBtn = function(elem) {
      const containerId = elem.id
      const fieldName = elem.dataset.name
      const button = elem.getElementsByClassName("button")[0]

      if (ButtonAutoReveal[fieldName]) {
        toggleHintBtn(containerId, noScrolling = true)
      }

      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])
      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)
      ankingAddEventListener("keydown", (evt) => {
        if (evt.repeat) return
        if (isShortcut(evt) || isToggleAllShortcut(evt)) {
          toggleHintBtn(containerId)
        }
      })
    }

    const hints = document.getElementsByClassName("hintBtn")
    for (let i = 0; i < hints.length; i++) {
      setupHintBtn(hints[i])
    }
  })()
</script>

<!-- CLICKABLE COLORFUL TAGS -->
{{#Tags}}
  <script>
    var tagContainer = document.getElementById("tags-container")

    if (tagContainer.childElementCount == 0) {
      var tagList = tagContainer.innerHTML.split(" ");
      var kbdList = [];
      var newTagContent = document.createElement("div");

      for (var i = 0; i < tagList.length; i++) {
        var newTag = document.createElement("kbd");
        var tag = tagList[i];
        // numTagLevelsToShow == 0 means the whole tag should be shown
        if (numTagLevelsToShow != 0) {
          tag = tag.split("::").slice(-numTagLevelsToShow).join("::");
        }

        // Zankiphil / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags
        if ((tag.split("::")[1] == "#UNIVERSITÄTEN") && (tag.split("::")[2] != tagUniversity)) continue;
        if (tag.split("::")[1] == "!NEW_CARDS") continue;
        if (tag.split("::")[1] == "§Projekt_Anki") continue;

        // improve legibility of tags
        tag = tag.replaceAll("#Zankiphil_v2.0_Pre-Release_vAnkihub::", "");
        tag = tag.replaceAll("#AMBOSS::", "");
        tag = tag.replaceAll("Bibliothek::", "").replaceAll("M2-100-Tage-Lernplan", "100_Tage");;
        newTag.innerHTML = tag.replaceAll("::", " →&nbsp;").replaceAll("_", " ");
        newTagContent.append(newTag)
      }

      tagContainer.innerHTML = newTagContent.innerHTML;
      tagContainer.style.cursor = "default";
    }

    if (tagContainer.innerHTML.indexOf(tagID) != -1) {
      tagContainer.style.backgroundColor = "rgba(251,11,11,.15)";
    }

    function showtags() {
      var tagContainerShortcut = document.getElementById("tags-container");

      if (tagContainerShortcut.style.display === "none") {
        tagContainerShortcut.style.display = "inline";
      } else {
        tagContainerShortcut.style.display = "none";
      }
    }

    var isShortcut = shortcutMatcher(toggleTagsShortcut)

    ankingAddEventListener('keyup', function(e) {
      if (isShortcut(e)) {
        toggleHintBtn('hint-tags');
        showtags();
      }
    });
  </script>
  <script>
    for (const tag of document.getElementsByTagName('kbd')) {
      tag.innerHTML = tag.innerHTML.replace(/::/g, '::<wbr>')
    }
  </script>
{{/Tags}}