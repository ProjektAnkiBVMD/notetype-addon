<!-- version 46f7de4 -->
<script>
  // ############## USER CONFIGURATION START ##############
  // ##############  HINT REVEAL SHORTCUTS  ##############
  // All shortcuts will also open with "H" if using the Hint Hotkeys add-on
  var ButtonShortcuts = {
    Tags: "Alt + 8",
    Subdeck: "Alt + 9",
    "Note ID": "Alt + 0",
  };
  var ToggleNextButtonShortcut = "H";
  var ToggleAllButtonsShortcut = "J";
  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)

  // ##############  SHOW HINTS AUTOMATICALLY  ##############
  var ButtonAutoReveal = {
    Tags: false,
    Subdeck: false,
    "Note ID": false,
  };
  var ScrollToButton = false;

  // ##############  TAG SHORTCUT  ##############
  var toggleTagsShortcut = "C";

  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND
  var tagID = "XXXYYYZZZ";

  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN
  var numTagLevelsToShow = 0;

  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN
  var tagUniversity = "XXXYYYZZZ";

  // ##############  INDENTATION  ##############
  // Enable experimental heuristic indentation feature
  var indentation = true;

  // ##############  DIVI FORMAT  ##############
  // Enable experimental DIVI medication formatting feature
  var diviformatting = true;

  // ############### USER CONFIGURATION END ###############
</script>

<!-- ###################################### -->
<!-- ##############  HEADER  ############## -->
<!-- ###################################### -->
<div id="header-container">
  <div class="header">
    <div class="head-flex-mid">
      <!-- TAGS FIELD -->
      {{#Tags}}
      <button
        id="button-tags"
        class="button-general headhov"
        onclick="toggleHintBtn('hint-tags'); event.stopPropagation()"
      >
        Tags
      </button>
      | {{/Tags}}

      <!-- SOURCE FIELD -->
      {{#Subdeck}}
      <button
        id="button-src"
        class="button-general headhov"
        onclick="toggleHintBtn('hint-src'); event.stopPropagation()"
      >
        Subdeck
      </button>
      | {{/Subdeck}}

      <!-- NOTE ID FIELD -->
      {{#Note ID}}
      <button
        id="button-nid"
        class="button-general headhov"
        onclick="toggleHintBtn('hint-nid'); event.stopPropagation()"
      >
        Note ID
      </button>
      {{/Note ID}}
    </div>
  </div>

  <!-- CLICKABLE COLORFUL TAGS -->
  {{#Tags}}
  <span id="hint-tags" class="hintBtn" data-name="Tags" style="display: flex">
    <button
      id="button-tags"
      style="all: unset !important; display: none"
      onclick="toggleHintBtn('hint-tags'); event.stopPropagation()"
    ></button>
    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->
    <div id="tags-container" class="hints" style="display: none">
      {{clickable::Tags}}
    </div>
  </span>
  {{/Tags}} {{#Subdeck}}
  <span id="hint-src" class="hintBtn" data-name="Quelle" style="display: flex">
    <button
      id="button-src"
      style="all: unset !important; display: none"
      onclick="toggleHintBtn('hint-src'); event.stopPropagation()"
    ></button>
    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->
    <div id="src" class="hints" style="display: none">Subdeck: {{Subdeck}}</div>
  </span>
  {{/Subdeck}} {{#Note ID}}
  <span id="hint-nid" class="hintBtn" data-name="Note ID" style="display: flex">
    <button
      id="button-nid"
      style="all: unset !important; display: none"
      onclick="toggleHintBtn('hint-nid'); event.stopPropagation()"
    ></button>
    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->
    <div id="nid" class="hints" style="display: none">ID: {{Note ID}}</div>
  </span>
  {{/Note ID}}

  <hr />
</div>

<div id="container">
  <div class="col" id="content">
    <!-- ####################################### -->
    <!-- ##############  CONTENT  ############## -->
    <!-- ####################################### -->

    <div>{{Vorderseite}}</div>
  </div>
</div>

<!-- ##############  TEXT-TO-SPEECH ##############
replace the arrows/dashes from the statement below with double curly brackets-->
<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->

<!-- ####################################### -->
<!-- ##############  SCRIPTS  ############## -->
<!-- ####################################### -->
<!-- INDENTING -->
<script>
  /**
   * Uses canvas.measureText to compute and return the width of the given text of given font in pixels.
   *
   * @param {String} text: The text to be rendered.
   * @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. "bold 14px verdana").
   *
   * @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393
   */
  function getTextWidth(text, font) {
    // re-use canvas object for better performance
    const canvas =
      getTextWidth.canvas ||
      (getTextWidth.canvas = document.createElement("canvas"));
    const context = canvas.getContext("2d");
    context.font = font;
    const metrics = context.measureText(text);
    return metrics.width;
  }

  function getCSSStyle(element, prop) {
    return window.getComputedStyle(element, null).getPropertyValue(prop);
  }

  function getCanvasFont(el = document.body) {
    const fontWeight = getCSSStyle(el, "font-weight") || "normal";
    const fontSize = getCSSStyle(el, "font-size") || "16px";
    const fontFamily = getCSSStyle(el, "font-family") || "Times New Roman";

    return `${fontWeight} ${fontSize} ${fontFamily}`;
  }

  /**
   * Iterates over a list of divs containing text to be indented
   *
   * @param {HTMLCollection} divs: The divs to be iterated over.
   */
  function indentText(divs) {
    // if heuristic indentation is not wanted, don't indent
    if (!indentation) {
      return;
    }

    // setup the indentation markers
    var numbers = "(" + "⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳".split("").join("|") + ")";
    var letters = "(" + "ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ".split("").join("|") + ")";
    var bulletP = "•";
    var minus = "– ";
    var enter = "↳(?! ↳)";
    var arrow = "→";

    // heuristic indentation hierarchy
    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP];

    // set up RegEx to analyze the provided divs
    // negative lookbehinds unfortunately do not work yet on iPad / Android
    var beginning = '(?<=<br>)(?<!cloze=")(';
    var middle = ".*?)((?:<br>)(?=(";
    var end = "))|(?=(<\/indent>|<\/div>|<br><br>)))";

    const reNumbers = new RegExp(
      beginning +
        hierarchy[0] +
        middle +
        hierarchy[0] +
        "))|(?=<\/div>|<br><br>))",
      "g"
    );
    const reLetters = new RegExp(
      beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join("|") + end,
      "g"
    );
    const reBulletP = new RegExp(
      beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join("|") + end,
      "g"
    );
    const reMinus = new RegExp(
      beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join("|") + end,
      "g"
    );
    const reEnter = new RegExp(
      beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join("|") + end,
      "g"
    );
    const reArrow = new RegExp(
      beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join("|") + end,
      "g"
    );

    // iterate over divs
    for (const div of divs) {
      // calculate indentation depths
      var canvasFont = getCanvasFont(div);
      var circledWidth = getTextWidth("① ", canvasFont).toString() + "px";
      var bulletPWidth = getTextWidth("• ", canvasFont).toString() + "px";
      var minusWidth = getTextWidth("– ", canvasFont).toString() + "px";
      var enterWidth = getTextWidth("↳ ", canvasFont).toString() + "px";
      var arrowWidth = getTextWidth("→ ", canvasFont).toString() + "px";

      var indentStart =
        '<indent style="margin: 0; display: block; padding-left:'; // display: inline-block; vertical-align: top;
      var indentEnd = ';">$1</indent>';

      // do the indentation
      divHTML = div.outerHTML;
      divHTML = divHTML
        .replaceAll(/(\d|<sup>|<sub>)–(\d|<\/sup>|<\/sub>|&#8288;)/g, "$1‒$2")
        .replaceAll("–&#8288;", "‒&#8288;");
      divHTML = divHTML.replaceAll(
        reNumbers,
        indentStart +
          circledWidth +
          "; text-indent: -" +
          circledWidth +
          indentEnd
      );
      divHTML = divHTML.replaceAll(
        reLetters,
        indentStart +
          circledWidth +
          "; text-indent: -" +
          circledWidth +
          indentEnd
      );
      divHTML = divHTML.replaceAll(
        reBulletP,
        indentStart +
          bulletPWidth +
          "; text-indent: -" +
          bulletPWidth +
          indentEnd
      );
      divHTML = divHTML.replaceAll(
        reMinus,
        indentStart + minusWidth + "; text-indent: -" + minusWidth + indentEnd
      );

      divHTML = divHTML.replaceAll(
        reEnter,
        indentStart + enterWidth + "; text-indent: -" + enterWidth + indentEnd
      );
      divHTML = divHTML.replaceAll("↳ ↳ ", "↳ ");
      divHTML = divHTML.replaceAll(
        reEnter,
        indentStart + enterWidth + "; text-indent: -" + enterWidth + indentEnd
      );
      divHTML = divHTML.replaceAll("↳ ↳ ", "↳ ");
      divHTML = divHTML.replaceAll(
        reEnter,
        indentStart + enterWidth + "; text-indent: -" + enterWidth + indentEnd
      );
      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)

      div.outerHTML = divHTML
        .replaceAll("<br></indent>", "</indent><br>")
        .replaceAll("</indent><br><br>", "</indent><br>");
    }

    // remove uneeded EventListener -> see line 284
    window.removeEventListener("load", doIndentText);
  }

  // use a function for the EventListener in line 284
  function doIndentText() {
    indentText(document.getElementById("content").getElementsByTagName("div"));
    indentText(document.getElementById("buttons").getElementsByTagName("div"));
  }

  // do the indentation only after the text content of the card is loaded
  window.addEventListener("load", doIndentText, {
    once: true,
  });
  dispatchEvent(new Event("load"));
</script>

<!-- NOT-PERSISTING EVENT LISTENER -->
<script>
  if (window.ankingEventListeners) {
    for (const listener of ankingEventListeners) {
      const type = listener[0];
      const handler = listener[1];
      document.removeEventListener(type, handler);
    }
  }
  window.ankingEventListeners = [];

  window.ankingAddEventListener = function (type, handler) {
    document.addEventListener(type, handler);
    window.ankingEventListeners.push([type, handler]);
  };
</script>

<!-- Shortcut Matcher Function -->
<script>
  var specialCharCodes = {
    "-": "minus",
    "=": "equal",
    "[": "bracketleft",
    "]": "bracketright",
    ";": "semicolon",
    "'": "quote",
    "`": "backquote",
    "\\": "backslash",
    ",": "comma",
    ".": "period",
    "/": "slash",
  };

  // Returns function that match keyboard event to see if it matches given shortcut.
  function shortcutMatcher(shortcut) {
    let shortcutKeys = shortcut
      .toLowerCase()
      .split(/[+]/)
      .map((key) => key.trim());
    let mainKey = shortcutKeys[shortcutKeys.length - 1];
    if (mainKey.length === 1) {
      if (/\d/.test(mainKey)) {
        mainKey = "digit" + mainKey;
      } else if (/[a-zA-Z]/.test(mainKey)) {
        mainKey = "key" + mainKey;
      } else {
        let code = specialCharCodes[mainKey];
        if (code) {
          mainKey = code;
        }
      }
    }
    let ctrl = shortcutKeys.includes("ctrl");
    let shift = shortcutKeys.includes("shift");
    let alt = shortcutKeys.includes("alt");

    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {
      if (mainKey !== event.code.toLowerCase()) return false;
      if (ctrl !== (event.ctrlKey || event.metaKey)) return false;
      if (shift !== event.shiftKey) return false;
      if (alt !== event.altKey) return false;
      return true;
    }.bind(window, ctrl, shift, alt, mainKey);

    return matchShortcut;
  }
</script>

<!-- HINT BUTTONS SETUP -->
<script>
  (function () {
    window.toggleHintBtn = function (containerId, noScrolling = false) {
      const container = document.getElementById(containerId);
      const button = container.getElementsByTagName("button")[0];
      const hint = container.getElementsByTagName("div")[0];

      if (hint.style.display == "none") {
        button.classList.add("expanded-button");
        hint.style.display = button.classList.contains("headhov")
          ? "inline-block"
          : "block"; // header hints have class headhov
        if (ScrollToButton && !noScrolling) {
          hint.scrollIntoView({
            behavior: "smooth", // "auto" for instant scrolling
            block: "start",
            inline: "nearest",
          });
        }
      } else {
        button.classList.remove("expanded-button");
        hint.style.display = "none";
      }
    };

    window.toggleNextButton = function () {
      // adapted from Hint Hotkey add-on
      var customEvent = document.createEvent("MouseEvents");
      customEvent.initEvent("click", false, true);
      var arr = document.querySelectorAll("span[data-name]");
      for (var i = 0; i < arr.length; i++) {
        var el = arr[i];

        if (el.getElementsByTagName("div")[0].style.display !== "none") {
          continue;
        }

        el.getElementsByTagName("button")[0].dispatchEvent(customEvent);
        break;
      }
    };

    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut);
    ankingAddEventListener("keydown", (evt) => {
      if (evt.repeat) return;
      if (isToggleNextShortcut(evt)) {
        toggleNextButton();
      }
    });

    const setupHintBtn = function (elem) {
      const containerId = elem.id;
      const fieldName = elem.dataset.name;
      const button = elem.getElementsByClassName("button")[0];

      if (ButtonAutoReveal[fieldName]) {
        toggleHintBtn(containerId, (noScrolling = true));
      }

      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName]);
      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut);
      ankingAddEventListener("keydown", (evt) => {
        if (evt.repeat) return;
        if (isShortcut(evt) || isToggleAllShortcut(evt)) {
          toggleHintBtn(containerId);
        }
      });
    };

    const hints = document.getElementsByClassName("hintBtn");
    for (let i = 0; i < hints.length; i++) {
      setupHintBtn(hints[i]);
    }
  })();
</script>

<!-- CLICKABLE COLORFUL TAGS -->
{{#Tags}}
<script>
  var tagContainer = document.getElementById("tags-container");

  if (tagContainer.childElementCount == 0) {
    var tagList = tagContainer.innerHTML.trim().split(" ");
    var kbdList = [];
    var newTagContent = document.createElement("div");

    for (var i = 0; i < tagList.length; i++) {
      var newTag = document.createElement("kbd");
      var tag = tagList[i];
      // numTagLevelsToShow == 0 means the whole tag should be shown
      if (numTagLevelsToShow != 0) {
        tag = tag.split("::").slice(-numTagLevelsToShow).join("::");
      }

      // Zankiphil / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags
      if (
        (tag.split("::")[1] == "#UNIVERSITÄTEN" ||
          tag.split("::")[1] == "#Universitäten") &&
        tag.split("::")[2] != tagUniversity
      )
        continue;
      if (tag.split("::")[1] == "!NEW_CARDS") continue;
      if (tag.split("::")[1] == "§Projekt_Anki") continue;

      // improve legibility of tags
      tag = tag.replaceAll("#Zankiphil_v2.0_Pre-Release_vAnkihub::", "");
      tag = tag.replaceAll("#AMBOSS::", "");
      tag = tag
        .replaceAll("Bibliothek::", "")
        .replaceAll("M2-100-Tage-Lernplan", "100_Tage");
      newTag.innerHTML = tag.replaceAll("::", " →&nbsp;").replaceAll("_", " ");
      newTagContent.append(newTag);
    }

    tagContainer.innerHTML = newTagContent.innerHTML;
    tagContainer.style.cursor = "default";
  }

  if (tagContainer.innerHTML.indexOf(tagID) != -1) {
    tagContainer.style.backgroundColor = "rgba(251,11,11,.15)";
  }

  function showtags() {
    var tagContainerShortcut = document.getElementById("tags-container");

    if (tagContainerShortcut.style.display === "none") {
      tagContainerShortcut.style.display = "inline";
    } else {
      tagContainerShortcut.style.display = "none";
    }
  }

  var isShortcut = shortcutMatcher(toggleTagsShortcut);

  ankingAddEventListener("keyup", function (e) {
    if (isShortcut(e)) {
      toggleHintBtn("hint-tags");
      showtags();
    }
  });
</script>
<script>
  for (const tag of document.getElementsByTagName("kbd")) {
    tag.innerHTML = tag.innerHTML.replace(/::/g, "::<wbr>");
  }
</script>
{{/Tags}}

<!-- DIVI FORMATTING -->
<script>
  var diviDict = {
    Esketamin: "esKETAmin",
    Ketamin: "KETAmin",
    Clonazepam: "clonazePAM",
    Lorazepam: "LORazepam",
    Pancuronium: "PANcuronium",
    Rocuronium: "ROCuronium",
    Vecuronium: "VECuronium",
    Fentanyl: "fentaNYL",
    Hydromorphon: "HYDROmorphon",
    Oxycodon: "oxyCODON",
    Piritramid: "PIRItramid",
    Sufentanil: "SUFentanil",
    Tramadol: "traMADol",
    Dopamin: "DOPamin",
    Ephedrin: "ePHEDrin",
    Epinephrin: "EPINEPHrin",
    Clonidin: "cloNIDin",
    Dihydralazin: "dihydrALAZIN",
    Nifedipin: "NIFEdipin",
    Nimodipin: "niMODipin",
    Bupivacain: "BUPIvacain",
    Ropivacain: "ROPIvacain",
    Physostigmin: "pHYSostigmin",
    Pyridostigmin: "pYRIDostigmin",
    Dimenhydrinat: "dimenhyDRINAT",
    Dolasetron: "DOLAsetron",
    Granisetron: "GRANIsetron",
    Ondansetron: "ONDANsetron",
    Tropisetron: "TROPIsetron",
    Adenosin: "aDENOsin",
    Ajmalin: "aJMALin",
    Amiodaron: "aMIOdaron",
    Levetiracetam: "levETIRAcetam",
    Desmopressin: "desmoPRESSIN",
    Dexamethason: "DEXAmethason",
    Levothyroxin: "LEVOthyroxin",
    Liothyronin: "LIOthyronin",
    Methylprednisolon: "methylPREDNISolon",
    Prednisolon: "prednisoLON",
    Octreotid: "ocTREOtid",
    Oxytocin: "OXYTOcin",
    Dobutamin: "DOBUTamin",
    Dopexamin: "dOPEXamin",
    Cimetidin: "cIMEtidin",
    Clemastin: "cLEMAstin",
    Furosemid: "fUROsemid",
    Glyceroltrinitrat:
      "<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>",
    Metoclopramid:
      "<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>",
    Acetylsalicylsäure:
      "<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>",
    "4-Dimethylaminophenol":
      "4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>",
    Tranexamsäure: "Tranexam<small>säure</small>",
    Valproinsäure: "Valproin<small>säure</small>",
    Calciumchlorid: "Calcium<small>chlorid</small>",
    Calciumgluconat: "Calcium<small>gluconat</small>",
    "Glyceroldihydrogen-Phosphat": "<small>Glyceroldihydrogen</small>-Phosphat",
    Magnesiumasparat: "Magnesium<small>asparat</small>",
    Magnesiumsulfat: "Magnesium<small>sulfat</small>",
    "Na-Hydrogencarbonat": "<small>Na</small>&#8209;Hydrogencarbonat",
    "Na-Thiosulfat": "<small>Na</small>&#8209;Thiosulfat",
    "Na-Phosphat": "<small>Na</small>&#8209;Phosphat",
    "Ca-Folinat": "<small>Ca</small>&#8209;FOLINAT",
    "Nitroprussid-Na": "Nitroprussid&#8209;<small>Na</small>",
  };

  /*
    MODIFIED VERSION OF:
    * @name        replaceUsingDictionary
    * @author      Rob W http://stackoverflow.com/users/938089/rob-w
    * @description Replaces phrases in a string, based on keys in a given dictionary.
    *              Each key is used only once, and the replacements are case-insensitive
    * @param       Object dictionary  {key: phrase, ...}
    * @param       String content
    * @param       Function replacehandler
    * @returns     Modified string
  */
  function replaceUsingDictionary(dictionary, content, replacehandler) {
    if (typeof replacehandler != "function") {
      // Default replacehandler function.
      replacehandler = function (key, dictionary) {
        return dictionary[key];
      };
    }

    var patterns = [], // \b is used to mark boundaries "foo" doesn't match food
      patternHash = {},
      oldkey,
      key,
      index = 0,
      output = [];
    for (key in dictionary) {
      // Case-insensitivity:
      key = (oldkey = key).toLowerCase();
      dictionary[key] = dictionary[oldkey];

      // Sanitize the key, and push it in the list
      // patterns.push('\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\$1') + ')\\b');
      patterns.push("(?:" + key.replace(/([[^$.|?*+(){}])/g, "\\$1") + ")");

      // Add entry to hash variable, for an optimized backtracking at the next loop
      patternHash[key] = index++;
    }
    var pattern = new RegExp(patterns.join("|"), "gi"),
      lastIndex = 0;

    // We should actually test using !== null, but for foolproofness,
    //  we also reject empty strings
    while ((key = pattern.exec(content))) {
      // Case-insensitivity
      key = key[0].toLowerCase();

      // Add to output buffer
      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));
      // The next line is the actual replacement method
      output.push(replacehandler(key, dictionary));

      // Update lastIndex variable
      lastIndex = pattern.lastIndex;

      // Don't match again by removing the matched word, create new pattern
      // patterns[patternHash[key]] = '^';
      // pattern = new RegExp(patterns.join('|'), 'gi');

      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop
      pattern.lastIndex = lastIndex;
    }
    output.push(content.substring(lastIndex, content.length));
    return output.join("");
  }

  if (diviformatting) {
    document.getElementById("container").innerHTML = replaceUsingDictionary(
      diviDict,
      document.getElementById("container").innerHTML,
      function (key, dictionary) {
        return dictionary[key];
      }
    );
  }
</script>
