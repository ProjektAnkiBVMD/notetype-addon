<!-- version fb71306 -->
<script>
  // ############## USER CONFIGURATION START ##############
  // ##############  HINT REVEAL SHORTCUTS  ##############
  // All shortcuts will also open with "H" if using the Hint Hotkeys add-on 
  var ButtonShortcuts = {
    "Eigene Notizen": "Alt + 1",
    "Prüfungsfragen": "Alt + 2",
    "Klinik": "Alt + 3",
    "Präparat": "Alt + 4",
    "Meditricks": "Alt + M",
    "Tags": "Alt + 8",
    "Quelle": "Alt + 9",
    "Note ID": "Alt + 0"
  }
  var ToggleNextButtonShortcut = "H"
  var ToggleAllButtonsShortcut = "J"
  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)

  // ##############  SHOW HINTS AUTOMATICALLY  ##############
  var ButtonAutoReveal = {
    "Eigene Notizen": false,
    "Prüfungsfragen": false,
    "Klinik": false,
    "Präparat": false,
    "Meditricks": false,
    "Tags": false,
    "Quelle": false,
    "Note ID": false
  }
  var ScrollToButton = false;

  // ##############  TAG SHORTCUT  ##############
  var toggleTagsShortcut = "C";

  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND
  var tagID = "XXXYYYZZZ"

  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN
  var numTagLevelsToShow = 0;

  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN
  var tagUniversity = "XXXYYYZZZ"

  // ##############  INDENTATION  ##############
  // Enable experimental heuristic indentation feature
  var indentation = true;

  // ##############  DIVI FORMAT  ##############
  // Enable experimental DIVI medication formatting feature
  var formattingDIVI = false;

  // ##############  CONFOUNDER FORMAT  ##############
  // Enable experimental confounder formatting feature
  var formattingConfounders = false;

  // ############  BIONIC READING  ############
  // Enable bionic reading feature (based on AnKing add-on)
  var bionicReading = false;

  // ##############  TWO COLUMN  ##############
  // Enable experimental two column layout feature
  // Will work on Save
  var twoColumnLayout = false;
  var columnRatio = "1fr 1.5fr"; // variable for grid-template-columns

  // ##############  CLOZE ONE BY ONE  ##############
  var revealNextShortcut = "N"
  var revealNextWordShortcut = "Shift + N"
  var toggleAllShortcut = ","

  // Enables revealing of next Cloze by simply clicking / tapping anywhere on the card (except the buttons)
  var revealAnywhere = true;

  // INFO ----------------------
  // to make a card behave like normal clozes without one-by-one, set:
  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false
  // ---------------------------
  // THIS NEEDS TO BE SET ON THE BACK AS WELL
  // enables selective cloze one-by-one (e.g. only c1 and c3)
  // seperate wanted numbers by "," in one-by-one field
  var selectiveOneByOne = false;

  // THIS NEEDS TO BE SET ON THE BACK AS WELL
  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1
  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting
  var minNumberOfClozes = 3;

  // THIS NEEDS TO BE SET ON THE BACK AS WELL
  // enables cloze one-by-one even when one-by-one field is empty
  // minNumberOfClozes is still considered in this case
  // overridden in importance by selectiveOneByOne
  var alwaysOneByOne = true;
  // ----------------------------

  // Changes how "Reveal Next" and clicking behaves. Either "cloze" or "word".
  // "word" reveals word by word. 
  var revealNextClozeMode = "cloze"

  // Changes how fields with additional information are displayed.
  // true displays fields with additional information only if all clozes are revealed.
  var hideAdditional = true;
  var hideAdditionalButtons = true;

  // What cloze is hidden with
  var clozeHider = (elem) => "___"
  /*
  You can replace the above line with below examples. '█' or '_' works well for hiding clozes.
  
  // Fixed length:
  var clozeHider = (elem) => "███"
  // Replace each character with "█":
  var clozeHider = (elem) => "█".repeat(elem.textContent.length)
  // Show whitespaces:
  var clozeHider = (elem) => "[" + elem.textContent.split(" ").map((t) => "█".repeat(t.length)).join(" ") + "]"
  // Color-filled box (doesn't hide images):
  var clozeHider = (elem) => `<span style="background-color: red; color: transparent;">${elem.innerHTML}</span>`
  */

  // ############### USER CONFIGURATION END ###############
</script>

<!-- ###################################### -->
<!-- ##############  HEADER  ############## -->
<!-- ###################################### -->
<div id="header-container">
  <div class="header">
    <!-- TIMER -->
    <div class="head-flex-left">
      <span class="timer" id="timer"></span>
    </div>

    <div class="head-flex-mid">
      <!-- TAGS FIELD -->
      {{#Tags}}
      <button id="button-tags" class="button-general headhov"
        onclick="toggleHintBtn('hint-tags'); event.stopPropagation()">
        Tags
      </button> |
      {{/Tags}}

      <!-- SOURCE FIELD -->
      {{#Quelle}}
      <button id="button-src" class="button-general headhov"
        onclick="toggleHintBtn('hint-src'); event.stopPropagation()">
        Quelle
      </button>
      {{/Quelle}}

      <!-- NOTE ID FIELD -->
      {{#Note ID}} |
      <button id="button-nid" class="button-general headhov"
        onclick="toggleHintBtn('hint-nid'); event.stopPropagation()">
        Note ID
      </button>
      {{/Note ID}}
    </div>

    <!-- ERRATA BUTTON -->
    <div class="head-flex-right" onclick="event.stopPropagation()">
      <a href="https://app.ankihub.net/">
        <button id="button-ankihub" class="button-general" title="Karte in AnkiHub">
          <strong>AnkiHub</strong>
        </button>
      </a>
    </div>
  </div>

  <!-- CLICKABLE COLORFUL TAGS -->
  {{#Tags}}
  <span id="hint-tags" class="hintBtn" data-name="Tags" style="display: flex">
    <button id="button-tags" style="all: unset !important; display: none"
      onclick="toggleHintBtn('hint-tags'); event.stopPropagation()"></button>
    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->
    <div id="tags-container" class="hints" style="display: none">
      {{clickable::Tags}}
    </div>
  </span>
  {{/Tags}} {{#Quelle}}
  <span id="hint-src" class="hintBtn" data-name="Quelle" style="display: flex">
    <button id="button-src" style="all: unset !important; display: none"
      onclick="toggleHintBtn('hint-src'); event.stopPropagation()"></button>
    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->
    <div id="src" class="hints" style="display: none">Quelle: {{Quelle}}</div>
  </span>
  {{/Quelle}} {{#Note ID}}
  <span id="hint-nid" class="hintBtn" data-name="Note ID" style="display: flex">
    <button id="button-nid" style="all: unset !important; display: none"
      onclick="toggleHintBtn('hint-nid'); event.stopPropagation()"></button>
    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->
    <div id="nid" class="hints" style="display: none">ID: {{Note ID}}</div>
  </span>
  {{/Note ID}}

  <hr />
</div>


<div id="container">
  <div class="col" id="content">

    <!-- ####################################### -->
    <!-- ##############  CONTENT  ############## -->
    <!-- ####################################### -->

    <div class="clozefield" id="text">{{cloze:Text}}</div>

    <!-- ##############  EDIT CLOZE DURING REVIEW  ##############
      change below (not above) to  "edit:cloze:Text" for editable field, 
      but be sure to have the correct add-on installed -->

    <div class="editcloze" id="text">{{edit:cloze:Text}}</div>

    <br>

    <!-- BUTTON FIELDS -->
    <!-- ClOZE ONE BY ONE BUTTONS -->
    <div id="onebyone-buttons" class="onebyone">
      <button id="button-reveal-next" class="button-general button-one-by-one"
        onclick="revealNextCloze(); event.stopPropagation()">Reveal Next</button>
      <button id="button-toggle-all" class="button-general button-one-by-one"
        onclick="toggleAllCloze(); event.stopPropagation()">Toggle All</button>
    </div>

  </div>

  <div class="col" id="buttons">

    <!-- ####################################### -->
    <!-- ##############  BUTTONS  ############## -->
    <!-- ####################################### -->
    <!-- BUTTON FIELDS -->
    {{#Zusatzinfos}}
    <span id="hint-zusatz" class="hintBtn" data-name="Zusatzinfos" style="display: none;">
      <button id="button-zusatz" class="button-general" onclick="toggleHintBtn('hint-zusatz'); event.stopPropagation()">
        <img src="_zusatz.svg" style="height: 10px;"> Zusatzinfos
      </button>
      <div id="zusatz" class="hints" style="display: none;">{{edit:Zusatzinfos}}</div>
    </span>
    {{/Zusatzinfos}}

    {{#Hammer}}
    <span id="hint-hammer" class="hintBtn" data-name="Hammer" style="display: none;">
      <button id="button-hammer" class="button-general" onclick="toggleHintBtn('hint-hammer'); event.stopPropagation()">
        <img src="_hammer.svg" style="height: 10px;"> Hammer
      </button>
      <div id="hammer" class="hints" style="display: none;">{{edit:Hammer}}</div>
    </span>
    {{/Hammer}}

    {{#Klinik}}
    <span id="hint-klinik" class="hintBtn" data-name="Klinik" style="display: none;">
      <button id="button-klinik" class="button-general" onclick="toggleHintBtn('hint-klinik'); event.stopPropagation()">
        <img src="_stethoscope.svg" style="height: 10px;"> Klinik
      </button>
      <div id="klinik" class="hints" style="display: none;">{{edit:Klinik}}</div>
    </span>
    {{/Klinik}}

    {{#Präparat}}
    <span id="hint-praeparat" class="hintBtn" data-name="Präparat" style="display: none;">
      <button id="button-praeparat" class="button-general"
        onclick="toggleHintBtn('hint-praeparat'); event.stopPropagation()">
        <img src="_microscope.svg" style="height: 10px;"> Präparat
      </button>
      <div id="praeparat" class="hints" style="display: none;">{{edit:Präparat}}</div>
    </span>
    {{/Präparat}}

    <!-- Extra field -->
    {{#Extra}}
    <span id="extra" style="display: none;">
      <div><br><br>{{edit:Extra}}</div>
    </span>
    {{/Extra}}

    <!-- Image field -->
    {{#Bild}}
    <div id="image" style="display: none;">
      <br><br>{{edit:Bild}}
    </div>
    {{/Bild}}
    {{^Bild}}
    <span id="image" style="display: none;"></span>
    {{/Bild}}
    <br>
    {{#Bild}}
    <span id="hint-image" style="display: none;">
      <button id="button-image" class="button-general"
        onclick="var image = document.getElementById('image'); if (image.style.display == 'none') { image.style.display = 'block' } else { image.style.display = 'none' }; event.stopPropagation()">
        <img src="_image.svg" style="height: 10px;"> Abbildung
      </button>
    </span>
    {{/Bild}}
    {{#AMBOSS-Link}}
    <span id="hint-amboss" onclick="event.stopPropagation()" style="display: none;">
      <a href="{{text:AMBOSS-Link}}">
        <button id="button-amboss" class="button-general">
          <img src="_amboss.svg" style="height: 10px;"> AMBOSS
        </button>
      </a>
    </span>
    {{/AMBOSS-Link}}

    {{#Meditricks}}
    <span id="hint-meditricks" class="hintBtn" data-name="Meditricks" style="display: none;">
      <button id="button-meditricks" class="button-general"
        onclick="toggleHintBtn('hint-meditricks'); event.stopPropagation()">
        <img src="_meditricks.svg" style="height: 10px;"> Meditricks
      </button>
      <div id="meditricks" class="hints" style="display: none;">{{edit:Meditricks}}</div>
    </span>
    {{/Meditricks}}

  </div>
</div>

<!-- ##############  TEXT-TO-SPEECH ##############
replace the arrows/dashes from the statement below with double curly brackets-->
<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->

<!-- ####################################### -->
<!-- ##############  SCRIPTS  ############## -->
<!-- ####################################### -->
<script>
  /**
   * Uses canvas.measureText to compute and return the width of the given text of given font in pixels.
   * 
   * @param {String} text: The text to be rendered.
   * @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. "bold 14px verdana").
   * 
   * @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393
   */
  function getTextWidth(text, font) {
    // re-use canvas object for better performance
    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement("canvas"));
    const context = canvas.getContext("2d");
    context.font = font;
    const metrics = context.measureText(text);
    return metrics.width;
  }

  function getCSSStyle(element, prop) {
    return window.getComputedStyle(element, null).getPropertyValue(prop);
  }

  function getCanvasFont(el = document.body) {
    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';
    const fontSize = getCSSStyle(el, 'font-size') || '16px';
    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';

    return `${fontWeight} ${fontSize} ${fontFamily}`;
  }

  /**
   * Iterates over a list of divs containing text to be indented
   *
   * @param {HTMLCollection} divs: The divs to be iterated over.
   */
  function indentText(divs) {
    // if heuristic indentation is not wanted, don't indent
    if (!indentation) {
      return;
    }

    // setup the indentation markers
    var numbers = "(" + "⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳".split("").join("|") + ")"
    var letters = "(" + "ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ".split("").join("|") + ")"
    var bulletP = "•"
    var minus = "– "
    var enter = "↳(?! ↳)"
    var arrow = "→"

    // heuristic indentation hierarchy
    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]

    // set up RegEx to analyze the provided divs
    // negative lookbehinds unfortunately do not work yet on iPad / Android
    var beginning = '(?<=<br>)(?<!cloze=")('
    var middle = ".*?)((?:<br>)(?=("
    var end = "))|(?=(<\/indent>|<\/div>|<br><br>)))"

    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + "))|(?=<\/div>|<br><br>))", "g")
    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, "g")
    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, "g")
    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, "g")
    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, "g")
    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, "g")

    // iterate over divs
    for (const div of divs) {
      // calculate indentation depths
      var canvasFont = getCanvasFont(div)
      var circledWidth = getTextWidth("① ", canvasFont).toString() + "px"
      var bulletPWidth = getTextWidth("• ", canvasFont).toString() + "px"
      var minusWidth = getTextWidth("– ", canvasFont).toString() + "px"
      var enterWidth = getTextWidth("↳ ", canvasFont).toString() + "px"
      var arrowWidth = getTextWidth("→ ", canvasFont).toString() + "px"

      var indentStart = '<indent style="margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;
      var indentEnd = ';">$1</indent>'

      // do the indentation
      divHTML = div.outerHTML
      divHTML = divHTML.replaceAll(/(\d|<sup>|<sub>)–(\d|<\/sup>|<\/sub>|&#8288;)/g, "$1‒$2").replaceAll("–&#8288;", "‒&#8288;")
      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)
      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)
      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)
      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)

      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)
      divHTML = divHTML.replaceAll("↳ ↳ ", "↳ ")
      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)
      divHTML = divHTML.replaceAll("↳ ↳ ", "↳ ")
      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)
      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)

      div.outerHTML = divHTML.replaceAll("<br></indent>", "</indent><br>").replaceAll("</indent><br><br>", "</indent><br>")
    }
  }

  // do the indentation if wanted
  if (indentation) {
    indentText(document.getElementById("content").getElementsByTagName("div"));
    indentText(document.getElementById("buttons").getElementsByTagName("div"));
  }
</script>

<!-- NOT-PERSISTING EVENT LISTENER -->
<script>
  if (window.ankingEventListeners) {
    for (const listener of ankingEventListeners) {
      const type = listener[0]
      const handler = listener[1]
      document.removeEventListener(type, handler)
    }
  }
  window.ankingEventListeners = []

  window.ankingAddEventListener = function (type, handler) {
    document.addEventListener(type, handler)
    window.ankingEventListeners.push([type, handler])
  }
</script>

<!-- Shortcut Matcher Function -->
<script>
  var specialCharCodes = {
    "-": "minus",
    "=": "equal",
    "[": "bracketleft",
    "]": "bracketright",
    ";": "semicolon",
    "'": "quote",
    "`": "backquote",
    "\\": "backslash",
    ",": "comma",
    ".": "period",
    "/": "slash",
  };

  // Returns function that match keyboard event to see if it matches given shortcut.
  function shortcutMatcher(shortcut) {
    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())
    let mainKey = shortcutKeys[shortcutKeys.length - 1]
    if (mainKey.length === 1) {
      if (/\d/.test(mainKey)) {
        mainKey = "digit" + mainKey
      } else if (/[a-zA-Z]/.test(mainKey)) {
        mainKey = "key" + mainKey
      } else {
        let code = specialCharCodes[mainKey];
        if (code) {
          mainKey = code
        }
      }
    }
    let ctrl = shortcutKeys.includes("ctrl")
    let shift = shortcutKeys.includes("shift")
    let alt = shortcutKeys.includes("alt")

    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {
      if (mainKey !== event.code.toLowerCase()) return false
      if (ctrl !== (event.ctrlKey || event.metaKey)) return false
      if (shift !== event.shiftKey) return false
      if (alt !== event.altKey) return false
      return true
    }.bind(window, ctrl, shift, alt, mainKey)

    return matchShortcut
  }
</script>

<!-- IMAGE BLUR -->
<script>
  for (const image of document.querySelectorAll(".blur")) {
    image.classList.add("tappable");
    image.addEventListener("click", () => {
      image.classList.toggle("blur");
    });
  }
</script>

<!-- CLICKABLE COLORFUL TAGS -->
{{#Tags}}
<script>
  var tagContainer = document.getElementById("tags-container")

  if (tagContainer.childElementCount == 0) {
    var tagList = tagContainer.innerHTML.trim().split(" ");
    var kbdList = [];
    var newTagContent = document.createElement("div");

    for (var i = 0; i < tagList.length; i++) {
      var newTag = document.createElement("kbd");
      var tag = tagList[i];
      // numTagLevelsToShow == 0 means the whole tag should be shown
      if (numTagLevelsToShow != 0) {
        tag = tag.split("::").slice(-numTagLevelsToShow).join("::");
      }

      // Zankiphil / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags
      if (((tag.split("::")[1] == "#UNIVERSITÄTEN") || (tag.split("::")[1] == "#Universitäten")) && (tag.split("::")[2] != tagUniversity)) continue;
      if (tag.split("::")[1] == "!NEW_CARDS") continue;
      if (tag.split("::")[1] == "§Projekt_Anki") continue;

      // improve legibility of tags
      tag = tag.replaceAll("#Zankiphil_v2.0_Pre-Release_vAnkihub::", "");
      tag = tag.replaceAll("#AMBOSS::", "");
      tag = tag.replaceAll("Bibliothek::", "").replaceAll("M2-100-Tage-Lernplan", "100_Tage");;
      newTag.innerHTML = tag.replaceAll("::", " →&nbsp;").replaceAll("_", " ");
      newTagContent.append(newTag)
    }

    tagContainer.innerHTML = newTagContent.innerHTML;
    tagContainer.style.cursor = "default";
  }

  if (tagContainer.innerHTML.indexOf(tagID) != -1) {
    tagContainer.style.backgroundColor = "rgba(251,11,11,.15)";
  }

  function showtags() {
    var tagContainerShortcut = document.getElementById("tags-container");

    if (tagContainerShortcut.style.display === "none") {
      tagContainerShortcut.style.display = "inline";
    } else {
      tagContainerShortcut.style.display = "none";
    }
  }

  var isShortcut = shortcutMatcher(toggleTagsShortcut)

  ankingAddEventListener('keyup', function (e) {
    if (isShortcut(e)) {
      toggleHintBtn('hint-tags');
      showtags();
    }
  });
</script>
<script>
  for (const tag of document.getElementsByTagName('kbd')) {
    tag.innerHTML = tag.innerHTML.replace(/::/g, '::<wbr>')
  }
</script>
{{/Tags}}

<!-- HINT BUTTONS SETUP -->
<script>
  (function () {
    window.toggleHintBtn = function (containerId, noScrolling = false) {
      const container = document.getElementById(containerId)
      const button = container.getElementsByTagName("button")[0]
      const hint = container.getElementsByTagName("div")[0]

      if (hint.style.display == "none") {
        button.classList.add("expanded-button")
        hint.style.display = button.classList.contains("headhov") ? "inline-block" : "block" // header hints have class headhov
        if (ScrollToButton && !noScrolling) {
          hint.scrollIntoView({
            behavior: "smooth", // "auto" for instant scrolling
            block: "start",
            inline: "nearest"
          });
        }
      } else {
        button.classList.remove("expanded-button")
        hint.style.display = "none"
      }
    }

    window.toggleNextButton = function () {
      // adapted from Hint Hotkey add-on
      var customEvent = document.createEvent('MouseEvents');
      customEvent.initEvent('click', false, true);
      var arr = document.querySelectorAll("span[data-name]");
      for (var i = 0; i < arr.length; i++) {
        var el = arr[i];

        if (el.getElementsByTagName("div")[0].style.display !== 'none') {
          continue;
        }

        el.getElementsByTagName("button")[0].dispatchEvent(customEvent);
        break;
      }
    }

    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)
    ankingAddEventListener("keydown", (evt) => {
      if (evt.repeat) return
      if (isToggleNextShortcut(evt)) {
        toggleNextButton()
      }
    })

    const setupHintBtn = function (elem) {
      const containerId = elem.id
      const fieldName = elem.dataset.name
      const button = elem.getElementsByClassName("button")[0]

      if (ButtonAutoReveal[fieldName]) {
        toggleHintBtn(containerId, noScrolling = true)
      }

      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])
      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)
      ankingAddEventListener("keydown", (evt) => {
        if (evt.repeat) return
        if (isShortcut(evt) || isToggleAllShortcut(evt)) {
          toggleHintBtn(containerId)
        }
      })
    }

    const hints = document.getElementsByClassName("hintBtn")
    for (let i = 0; i < hints.length; i++) {
      setupHintBtn(hints[i])
    }
  })()
</script>

<!-- CLOZE ONE BY ONE SCRIPT -->
<style>
  .cloze[data-content]:hover {
    cursor: pointer;
  }

  .cloze[data-hint] {
    color: #009400 !important;
  }
</style>

<script>
    /**
     * Based on the AnKing Notetype, but expanded and modified by phyn.
     * Credit to the original authors, except where modified or otherwise indicated.
     */

    (function () {
      document.documentElement.removeAttribute("onclick")

      // check if OneByOne is generally enabled for this card
      var oneByOneFieldEmpty = "{{One by one}}" === "";
      var clozeOneByOneEnabled = true;
      try {
        clozeOneByOneEnabled = alwaysOneByOne ? true : !oneByOneFieldEmpty
      } catch (exception) {
        console.log(exception)
      }

      /**
       * helper functions to show / hide fields containing additional information
       */
      const showExtra = function () {
        try {
          document.getElementById("extra").style.removeProperty("display")
        } catch (exception) {
          console.log(exception)
        }
        try {
          document.getElementById("image").style.removeProperty("display")
        } catch (exception) {
          console.log(exception)
        }
      }

      const hideExtra = function () {
        try {
          document.getElementById("extra").style.display = "none"
        } catch (exception) {
          console.log(exception)
        }
        try {
          document.getElementById("image").style.display = "none"
        } catch (exception) {
          console.log(exception)
        }
      }

      const buttonIds = ["hint-zusatz", "hint-definition", "hint-hammer", "hint-klinik", "hint-praeparat", "hint-merksprueche", "hint-memes", "hint-image", "hint-amboss", "hint-thieme", "hint-meditricks", "hint-linkcontainer"]

      const showExtraButtons = function () {
        for (const button in buttonIds) {
          try {
            document.getElementById(buttonIds[button]).style.removeProperty("display")
          } catch (exception) {
            console.log(exception)
          }
        }
      }

      const hideExtraButtons = function () {
        for (const button in buttonIds) {
          try {
            document.getElementById(buttonIds[button]).style.display = "none"
          } catch (exception) {
            console.log(exception)
          }
        }
      }

      // show normal backside if OneByOne is disabled some way
      if (!clozeOneByOneEnabled && !alwaysOneByOne) {
        showExtra();
        showExtraButtons();
        return
      }

      /**
       * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)
       */
      const getCardNumber = function () {
        clz = document.body.className;
        const regex = /card(\d+)/gm;
        let m;

        if ((m = regex.exec(clz)) !== null) {
          return m[1];
        } else {
          // Should only fire if card is not cloze
          console.error("Cannot find cardN class of body element!");
          return "0";
        }
      }

      // parse the cloze numbers for which selectiveOneByOne is enabled
      cardNumberIsOneByOne = `{{One by one}}`.split(',').filter(element => element).map(Number).includes(parseInt(getCardNumber()))

      // check the amount of clozes -> disable OneByOne if less than minimum value wanted (minNumberOfClozes)
      numClozesForNumber = (minNumberOfClozes) ? document.querySelectorAll('.clozefield .cloze').length : 0

      // stop OneByOne if selectiveOneByOne is not enabled for this specific card OR if OneByOne is disabled some other way
      // -> show normal backside
      if ((selectiveOneByOne && !alwaysOneByOne && !cardNumberIsOneByOne) || (oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes))) {
        clozeOneByOneEnabled = false
        showExtra()
        showExtraButtons()
        document.getElementById("onebyone-buttons").style.display = "none"
        document.getElementById("qa").style.removeProperty("display")
        return
      }

      // show some additional information if wanted on the clozed backside (of OneByOne is enabled)
      if (!hideAdditional || (!clozeOneByOneEnabled && !alwaysOneByOne)) {
        showExtra()
      }
      if (!hideAdditionalButtons || (!clozeOneByOneEnabled && !alwaysOneByOne)) {
        showExtraButtons()
      }

      /**
       * functions to reveal specific clozes
       */
      const revealCloze = function (elem) {
        // Checking for dataset.content is undefined may not be needed anymore?
        if (elem.dataset.content === undefined) {
          return
        }
        elem.innerHTML = elem.dataset.content
        delete elem.dataset.content
        delete elem.dataset.hint
      }

      const revealClozeWord = function (elem) {
        if (elem.dataset.content === undefined) {
          return
        }
        if (elem.dataset.hidden !== undefined) {
          let words = elem.dataset.hidden.split(" ");
          if (words.length == 1) {
            revealCloze(elem)
            delete elem.dataset.hidden
            delete elem.dataset.revealed
          } else {
            elem.dataset.revealed = elem.dataset.revealed + " " + words[0]
            elem.dataset.hidden = words.slice(1).join(" ");
            let temp = document.createElement("div");
            temp.innerHTML = elem.dataset.hidden;
            elem.innerHTML = elem.dataset.revealed + " " + clozeHider(temp);
            delete elem.dataset.hint
          }
        } else {
          let temp = document.createElement("div");
          temp.innerHTML = elem.dataset.content;
          elem.dataset.hidden = temp.textContent;
          elem.dataset.revealed = "";
          revealClozeWord(elem)
        }
      }

      window.revealNextCloze = function () {
        let nextCloze = document.querySelector(".cloze[data-content]")
        let nextNextCloze = document.querySelectorAll('.cloze[data-content]')[1]
        if (!nextCloze) {
          noMoreTaps()
          return
        }
        if (revealNextClozeMode === "word") {
          revealClozeWord(nextCloze)
          if (!nextNextCloze) {
            noMoreClozes();
            noMoreTaps()
          }
        } else {
          revealCloze(nextCloze)
          if (!nextNextCloze) {
            noMoreClozes();
            noMoreTaps()
          }
        }
      }

      /**
       * hide all clozes on initialization or if toggled
       */
      const hideAllCloze = function (initial) {
        let clozes = document.getElementsByClassName("cloze")
        let count = 0 // hidden cloze count
        for (let i = 0; i < clozes.length; i++) {
          let cloze = clozes[i]
          if (cloze.offsetWidth === 0) {
            continue
          }

          cloze.dataset.content = cloze.innerHTML
          if (window.clozeHints && window.clozeHints[count]) {
            cloze.innerHTML = window.clozeHints[count]
            cloze.dataset.hint = true
          } else {
            cloze.innerHTML = clozeHider(cloze)
          }

          cloze.addEventListener("touchend", revealClozeClicked)
          cloze.addEventListener("click", revealClozeClicked)

          count += 1
        }

        if (initial === false) {
          document.getElementById("button-reveal-next").style.removeProperty("display")
        }

        if (revealAnywhere) {
          document.documentElement.setAttribute("onclick", "revealNextCloze(); event.stopPropagation()")
        }
      }

      // either show or hide all clozes depending on their state
      window.toggleAllCloze = function () {
        let elems = document.querySelectorAll(".cloze[data-content]")
        let button = document.getElementById("button-toggle-all")
        if (elems.length > 0) {
          for (let i = 0; i < elems.length; i++) {
            revealCloze(elems[i])
          }
          noMoreClozes()
          noMoreTaps()
        } else {
          hideAllCloze(initial = false)
          if (hideAdditional) {
            hideExtra();
            hideExtraButtons();
          }
        }
      }

      // show cloze out of order of appearence on click
      const revealClozeClicked = function (ev) {
        let elem = ev.currentTarget
        let nextCloze = document.querySelectorAll('.cloze[data-content]')[1]
        if (elem.dataset.content === undefined) {
          noMoreTaps()
          return
        }
        if (!ev.altKey && (revealNextClozeMode !== "word")) {
          revealCloze(elem)
          if (!nextCloze) {
            noMoreClozes();
            noMoreTaps()
          }
        } else {
          revealClozeWord(elem)
          if (!nextCloze) {
            noMoreClozes();
            noMoreTaps()
          }
        }
        ev.stopPropagation()
        ev.preventDefault()
      }

      /**
       * helper functions for when everything is revealed
       */
      const noMoreTaps = function () {
        document.documentElement.removeAttribute("onclick")
      }

      const noMoreClozes = function () {
        document.getElementById("button-reveal-next").style.display = "none"
        showExtra()
        showExtraButtons()
      }

      // autoflip hides card in front template, still need to hide all clozes 
      document.getElementById("qa").style.removeProperty("display")
      hideAllCloze(initial = true)

      // setup shortcuts and their respective EventListeners
      let isShowNextShortcut = shortcutMatcher(window.revealNextShortcut)
      let isShowWordShortcut = shortcutMatcher(window.revealNextWordShortcut)
      let isToggleAllShortcut = shortcutMatcher(window.toggleAllShortcut)
      ankingAddEventListener("keydown", (ev) => {
        let next = isShowNextShortcut(ev)
        let word = isShowWordShortcut(ev)
        let all = isToggleAllShortcut(ev)
        if (next || word) {
          let elem = document.querySelector(".cloze[data-content]")
          let nextCloze = document.querySelectorAll('.cloze[data-content]')[1]
          if (elem) {
            if (next) {
              revealCloze(elem)
              if (!nextCloze) {
                noMoreClozes();
                noMoreTaps()
              }
            } else {
              revealClozeWord(elem)
              if (!nextCloze) {
                noMoreClozes();
                noMoreTaps()
              }
            }
            ev.stopPropagation()
            ev.preventDefault()
          } else {
            noMoreClozes();
            noMoreTaps()
          }
        } else if (all) {
          toggleAllCloze()
          ev.stopPropagation()
          ev.preventDefault()
        }
      });
    })()
</script>

<!-- TWO COLUMN LAYOUT -->
<script>
  /**
   * Enables different styling for a two column layout on widescreen devices
   * only if twoColumnLayout is set to true
   */

  function mediaQuery(x) {
    var content = document.getElementById("content");
    var buttons = document.getElementById("buttons");
    var extra = document.getElementById("extra");
    var image = document.getElementById("image");

    if (x.matches) {
      // If media query matches
      try {
        content.appendChild(extra);
      } catch (exception) {
        console.log(exception);
      }
    } else {
      try {
        buttons.insertBefore(extra, image);
      } catch (exception) {
        console.log(exception);
      }
    }
  }

  var x = window.matchMedia("(min-width: 768px)");
  var s = `
    @media only screen and (min-width: 768px) {
      #qa #container {
        display: grid;
        grid-template-columns: ${columnRatio};
        grid-column-gap: 15px;
      }
  
      .col {
        overflow-y: scroll;
        overflow-x: hidden;
      }
    }
  `;

  var styleSheet = document.createElement("style");
  styleSheet.innerHTML = s;

  if (twoColumnLayout) {
    mediaQuery(x); // Call listener function at run time
    x.addListener(mediaQuery); // Attach listener function on state changes

    document.getElementById("qa").appendChild(styleSheet);
  }

  if (!twoColumnLayout) {
    document.getElementById("qa").removeChild(styleSheet);
    x.removeListener(mediaQuery);
    x.removeListener(mediaQuery);
  }
</script>


<script>
  /*
    MODIFIED VERSION OF:
    * @name        replaceUsingDictionary
    * @author      Rob W http://stackoverflow.com/users/938089/rob-w
    * @description Replaces phrases in a string, based on keys in a given dictionary.
    *              Each key is used only once, and the replacements are case-insensitive
    * @param       Object dictionary  {key: phrase, ...}
    * @param       String content
    * @param       Function replacehandler
    * @returns     Modified string
  */
  function replaceUsingDictionary(dictionary, content, replacehandler) {
    if (typeof replacehandler != "function") {
      // Default replacehandler function.
      replacehandler = function (key, dictionary) {
        return dictionary[key];
      }
    }

    var patterns = [], // \b is used to mark boundaries "foo" doesn't match food
      patternHash = {},
      oldkey, key, index = 0,
      output = [];
    for (key in dictionary) {
      // Case-insensitivity:
      key = (oldkey = key).toLowerCase();
      dictionary[key] = dictionary[oldkey];

      // Sanitize the key, and push it in the list
      // patterns.push('\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\$1') + ')\\b');
      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\$1') + ')');

      // Add entry to hash variable, for an optimized backtracking at the next loop
      patternHash[key] = index++;
    }
    var pattern = new RegExp(patterns.join('|'), 'gi'),
      lastIndex = 0;

    // We should actually test using !== null, but for foolproofness,
    //  we also reject empty strings
    while (key = pattern.exec(content)) {
      // Case-insensitivity
      key = key[0].toLowerCase();

      // Add to output buffer
      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));
      // The next line is the actual replacement method
      output.push(replacehandler(key, dictionary));

      // Update lastIndex variable
      lastIndex = pattern.lastIndex;

      // Don't match again by removing the matched word, create new pattern
      // patterns[patternHash[key]] = '^';
      // pattern = new RegExp(patterns.join('|'), 'gi');

      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop
      pattern.lastIndex = lastIndex;
    }
    output.push(content.substring(lastIndex, content.length));
    return output.join('');
  }
</script>

<!-- DIVI FORMATTING -->
<script>
  var diviDict = {
    "Esketamin": "esKETAmin",
    "Ketamin": "KETAmin",
    "Clonazepam": "clonazePAM",
    "Lorazepam": "LORazepam",
    "Pancuronium": "PANcuronium",
    "Rocuronium": "ROCuronium",
    "Vecuronium": "VECuronium",
    "Fentanyl": "fentaNYL",
    "Hydromorphon": "HYDROmorphon",
    "Oxycodon": "oxyCODON",
    "Piritramid": "PIRItramid",
    "Sufentanil": "SUFentanil",
    "Tramadol": "traMADol",
    "Dopamin": "DOPamin",
    "Ephedrin": "ePHEDrin",
    "Epinephrin": "EPINEPHrin",
    "Clonidin": "cloNIDin",
    "Dihydralazin": "dihydrALAZIN",
    "Nifedipin": "NIFEdipin",
    "Nimodipin": "niMODipin",
    "Bupivacain": "BUPIvacain",
    "Ropivacain": "ROPIvacain",
    "Physostigmin": "pHYSostigmin",
    "Pyridostigmin": "pYRIDostigmin",
    "Dimenhydrinat": "dimenhyDRINAT",
    "Dolasetron": "DOLAsetron",
    "Granisetron": "GRANIsetron",
    "Ondansetron": "ONDANsetron",
    "Tropisetron": "TROPIsetron",
    "Adenosin": "aDENOsin",
    "Ajmalin": "aJMALin",
    "Amiodaron": "aMIOdaron",
    "Levetiracetam": "levETIRAcetam",
    "Desmopressin": "desmoPRESSIN",
    "Dexamethason": "DEXAmethason",
    "Levothyroxin": "LEVOthyroxin",
    "Liothyronin": "LIOthyronin",
    "Methylprednisolon": "methylPREDNISolon",
    "Prednisolon": "prednisoLON",
    "Octreotid": "ocTREOtid",
    "Oxytocin": "OXYTOcin",
    "Dobutamin": "DOBUTamin",
    "Dopexamin": "dOPEXamin",
    "Cimetidin": "cIMEtidin",
    "Clemastin": "cLEMAstin",
    "Furosemid": "fUROsemid",
    "Glyceroltrinitrat": "<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>",
    "Metoclopramid": "<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>",
    "Acetylsalicylsäure": "<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>",
    "4-Dimethylaminophenol": "4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>",
    "Tranexamsäure": "Tranexam<small>säure</small>",
    "Valproinsäure": "Valproin<small>säure</small>",
    "Calciumchlorid": "Calcium<small>chlorid</small>",
    "Calciumgluconat": "Calcium<small>gluconat</small>",
    "Glyceroldihydrogen-Phosphat": "<small>Glyceroldihydrogen</small>-Phosphat",
    "Magnesiumasparat": "Magnesium<small>asparat</small>",
    "Magnesiumsulfat": "Magnesium<small>sulfat</small>",
    "Na-Hydrogencarbonat": "<small>Na</small>&#8209;Hydrogencarbonat",
    "Na-Thiosulfat": "<small>Na</small>&#8209;Thiosulfat",
    "Na-Phosphat": "<small>Na</small>&#8209;Phosphat",
    "Ca-Folinat": "<small>Ca</small>&#8209;FOLINAT",
    "Nitroprussid-Na": "Nitroprussid&#8209;<small>Na</small>"
  }

  if (formattingDIVI) {
    document.getElementById("container").innerHTML = replaceUsingDictionary(
      diviDict,
      document.getElementById("container").innerHTML,
      function (key, dictionary) {
        return dictionary[key];
      }
    );
  }
</script>


<!-- CONFOUNDER FORMATTING -->
<script>
  var confounderDict = {
    "atypisch": '<emu>a</emu>typisch',
    "Atypisch": '<emu>A</emu>typisch',
    "Antagonist": '<emu>Ant</emu>agonist',
    "hyper": 'hyp<emu>er</emu>',
    "Hyper": 'Hyp<emu>er</emu>',
    "hypo": 'hyp<emu>o</emu>',
    "Hypo": 'Hyp<emu>o</emu>',
    "inter": 'int<emu>er</emu>',
    "Inter": 'Int<emu>er</emu>',
    "intra": 'int<emu>ra</emu>',
    "Intra": 'int<emu>ra</emu>',
    "post": '<emu>post</emu>',
    "Post": '<emu>Post</emu>',
    "pre": '<emu>pre</emu>',
    "Pre": '<emu>Pre</emu>',
    "ab": '<emu>ab</emu>',
    "Ab": '<emu>Ab</emu>',
    "ad": '<emu>ad</emu>',
    "Ad": '<emu>Ad</emu>',
    "Insuffizienz": '<emu>In</emu>suffizienz',
  }

  if (formattingConfounders) {
    document.getElementById("container").innerHTML = replaceUsingDictionary(
      confounderDict,
      document.getElementById("container").innerHTML,
      function (key, dictionary) {
        return dictionary[key];
      }
    );
  }
</script>


<script>
  /**
   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.
   * Full credit to the original authors, except where modified or otherwise indicated.
   */

  /**
   *
   * We try to respect that people use various note types
   * which may do 'weird' stuff.
   * Elements may have event listeners that can be removed if we just innerHTML stuff
   * <i> may be styled 'i { display: block }', etc.
   *
   * Another problem that complicate the design of this script is that
   * a word may not be cleanly separated by html tags.
   * e.g. "A<i>long</i>word"
   *
   */

  (function () {
    /**
     * @param {String} text
     * @returns {number}
     */
    function getBoldLength(text) {
      return Math.floor(text.length / 2);
    }

    // Ignore node if any of the filters return true
    const excludeFilters = [
      (elem) => elem.tagName === "SCRIPT",
      (elem) => elem.tagName === "STYLE",
      (elem) => elem.classList.contains("cloze"),
    ];

    function newBoldElement(text) {
      const elem = document.createElement("strong");
      elem.innerText = text;
      return elem;
    }

    function indexOfWhitespace(text, startPos) {
      const whitespaces = [
        " ",
        "\n",
        "\t",
        " ",
        "&nbsp;",
        "‑",
        "-",
        "/",
        "(",
        ")",
      ];
      let nextPos = text.length;
      for (const whitespace of whitespaces) {
        const next = text.indexOf(whitespace, startPos);
        if (next !== -1 && next < nextPos) {
          nextPos = next;
        }
      }
      if (nextPos === text.length) {
        nextPos = -1;
      }
      return nextPos;
    }

    // Bolds a line of words
    class BionicReaderBolder {
      constructor(nodes) {
        this.nodes = nodes;
        this.startNodeIndex = 0;
        this.startPos = 0;
        this.replaceNodes = [];
        while (!this.isFinished()) {
          this.runWithinNode();
          this.runInterNode();
        }
      }

      static run(nodes) {
        new BionicReaderBolder(nodes);
      }

      isFinished() {
        return this.startNodeIndex === this.nodes.length;
      }

      replaceNode() {
        const node = this.nodes[this.startNodeIndex];
        const parent = node.parentNode;
        for (let add of this.replaceNodes) {
          parent.insertBefore(add, node);
        }
        parent.removeChild(node);
        this.replaceNodes = [];
      }

      runWithinNode() {
        const textContent = this.nodes[this.startNodeIndex].textContent;
        let nextPos = indexOfWhitespace(textContent, this.startPos);
        while (nextPos !== -1) {
          const word = textContent.substring(this.startPos, nextPos);
          const boldLength = getBoldLength(word);
          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));
          this.replaceNodes.push(
            document.createTextNode(
              word.substring(boldLength, nextPos) + textContent[nextPos]
            )
          );
          this.startPos = nextPos + 1;
          nextPos = indexOfWhitespace(textContent, this.startPos);
        }
      }

      // after this, startPos is likely to be at whitespace char
      runInterNode() {
        let word = "";
        let endNodeIndex = this.startNodeIndex;
        let endPos = this.startPos; // last word char pos + 1

        // Find word boundary
        while (endNodeIndex < this.nodes.length) {
          const textContent = this.nodes[endNodeIndex].textContent;
          let nextPos = indexOfWhitespace(textContent, endPos);
          if (nextPos === -1) {
            word += textContent.substring(endPos);
            endNodeIndex += 1;
            endPos = 0;
          } else {
            word += textContent.substring(endPos, nextPos);
            endPos = nextPos;
            break;
          }
        }
        // Calculate bold length
        let remainingBoldLength = getBoldLength(word);

        // Bold part of word
        while (remainingBoldLength > 0) {
          const textContent = this.nodes[this.startNodeIndex].textContent;
          if (remainingBoldLength > textContent.length - this.startPos) {
            const wordPart = textContent.substring(this.startPos);
            remainingBoldLength -= wordPart.length;
            this.replaceNodes.push(newBoldElement(wordPart));
            this.replaceNode();
            this.startNodeIndex += 1;
            this.startPos = 0;
          } else {
            const wordPart = textContent.substring(
              this.startPos,
              this.startPos + remainingBoldLength
            );
            this.startPos += remainingBoldLength;
            this.replaceNodes.push(newBoldElement(wordPart));
            remainingBoldLength -= wordPart.length;
          }
        }

        // Add non-bolded part of words
        while (this.startNodeIndex < endNodeIndex) {
          const textContent = this.nodes[this.startNodeIndex].textContent;
          const wordPart = textContent.substring(this.startPos);
          if (wordPart.length > 0) {
            this.replaceNodes.push(document.createTextNode(wordPart));
          }
          this.replaceNode();
          this.startNodeIndex += 1;
          this.startPos = 0;
        }

        if (this.startPos < endPos) {
          const textContent = this.nodes[this.startNodeIndex].textContent;
          const wordPart = textContent.substring(this.startPos, endPos);
          if (wordPart.length > 0) {
            this.replaceNodes.push(document.createTextNode(wordPart));
          }
          this.startPos = endPos;
        }
      }
    }

    /**
     * Builds a list of (list of nodes that makes up one non-line-broken line)
     * @param {Node} elem
     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.
     * @returns {void}
     */
    function forTextNodesInTree(elem, nodes, exclude = false) {
      const children = elem.childNodes;
      for (const filter of excludeFilters) {
        if (filter(elem)) {
          exclude = true;
          break;
        }
      }
      for (const child of children) {
        if (child.nodeType === Node.ELEMENT_NODE) {
          const style = window.getComputedStyle(child);
          if (
            child.tagName !== "BR" &&
            (style === "inline" || style === "inline-block")
          ) {
            forTextNodesInTree(child, nodes, exclude);
          } else {
            if (nodes[nodes.length - 1].length > 0) {
              nodes.push([]);
            }
            forTextNodesInTree(child, nodes, exclude);
          }
        } else if (
          !exclude &&
          child.nodeType === Node.TEXT_NODE &&
          child.textContent.length > 0
        ) {
          nodes[nodes.length - 1].push(child);
        }
      }
    }

    function makeBionic() {
      const cardContainer = document.getElementById("container");
      cardContainer.normalize();

      let nodesLines = [[]];
      forTextNodesInTree(cardContainer, nodesLines);
      for (const nodes of nodesLines) {
        BionicReaderBolder.run(nodes);
      }

      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(
        "<strong></strong>",
        ""
      );
      cardContainer.normalize();
    }

    let start = performance.now();
    if (bionicReading) {
      makeBionic();
    }
    let end = performance.now();
    console.log(`Initialized bionic reading: ${end - start}ms`);
  })();
</script>


<!-- ANKIMOBILE USER ACTIONS -->
<script>
  var userJs1 = undefined
  var userJs2 = undefined
  var userJs3 = undefined
  var userJs4 = undefined
  var userJs5 = undefined
  var userJs6 = undefined
  var userJs7 = undefined
  var userJs8 = undefined
</script>