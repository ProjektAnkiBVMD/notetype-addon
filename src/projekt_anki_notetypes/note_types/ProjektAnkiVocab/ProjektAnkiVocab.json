{
  "id": 160000010,
  "name": "ProjektAnkiVocab",
  "type": 0,
  "mod": 1600000000,
  "usn": -1,
  "sortf": 0,
  "did": 1,
  "tmpls": [
    {
      "name": "Front -> Back",
      "ord": 0,
      "qfmt": "<!-- version f0935e4 -->\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Subdeck\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Subdeck\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Subdeck}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Subdeck\n      </button> |\n      {{/Subdeck}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}}\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex;\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none;\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none;\">{{clickable::Tags}}</div>\n  </span>\n  {{/Tags}}\n  {{#Subdeck}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex;\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none;\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none;\">Subdeck: {{Subdeck}}</div>\n  </span>\n  {{/Subdeck}}\n  {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex;\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none;\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none;\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr>\n\n</div>\n\n<div id=\"container\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    <div>{{Vorderseite}}</div>\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    if (!indentation) { return; }\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>",
      "afmt": "<!-- version f0935e4 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Subdeck\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Subdeck\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Subdeck}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Subdeck\n      </button> |\n      {{/Subdeck}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}}\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex;\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none;\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none;\">{{clickable::Tags}}</div>\n  </span>\n  {{/Tags}}\n  {{#Subdeck}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex;\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none;\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none;\">Subdeck: {{Subdeck}}</div>\n  </span>\n  {{/Subdeck}}\n  {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex;\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none;\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none;\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr>\n\n</div>\n\n<div id=\"container\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    <div>{{Vorderseite}}</div>\n\n    <hr>\n\n    <div>{{Rückseite}}</div>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- Extra field -->\n    {{#Extra}}\n    <div id=\"extra\" style=\"display: none;\">\n      <br><br>{{edit:Extra}}\n    </div><br>\n    {{/Extra}}\n\n    <!-- BUTTON FIELDS -->\n    {{#Tabellen}}\n    <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Tabellen\" style=\"display: none;\">\n      <button id=\"button-definition\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Tabellen\n      </button>\n      <div dir=\"auto\" id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Tabellen}}</div>\n    </span>\n    {{/Tabellen}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n  try {\n    for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n      href = link.href\n      text = link.innerText\n\n      const el = document.createElement('a');\n      el.setAttribute('href', link.href);\n\n      const btn = document.createElement('button');\n      btn.classList.add('button-general');\n      btn.classList.add('expanded-button');\n\n      domain = href.replace(/.+\\/\\/|(www|flexikon|register|de|next|com).|\\..+/g, '');\n      domainDict = {\n        \"amboss\": \"__amboss.svg\",\n        \"wikipedia\": \"__wikipedia.svg\",\n        \"doccheck\": \"__doccheck.png\",\n        \"notfallguru\": \"__notfallguru.svg\",\n        \"awmf\": \"__awmf.svg\",\n        \"gelbe-liste\": \"__gelbe-liste.png\",\n        \"embryotox\": \"__embryotox.svg\",\n        \"radiopaedia\": \"__radiopaedia.png\",\n        \"orphanet\": \"__orphanet.png\",\n      }\n      if (domain in domainDict) {\n        icon = domainDict[domain]\n      } else {\n        icon = \"__internet.svg\"\n      }\n\n      const img = document.createElement('img');\n      img.setAttribute('src', icon);\n      img.setAttribute('style', 'height: 10px;');\n\n      btn.appendChild(img);\n      btn.innerHTML = btn.innerHTML + \" \" + text;\n\n      el.appendChild(btn);\n\n      document.getElementById(\"linkcontainer\").appendChild(el)\n    }\n  }\n  catch (err) {\n    console.log(err)\n  }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-uafi\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>",
      "bqfmt": "{{Vorderseite}}",
      "bafmt": "{{Vorderseite}}",
      "did": null,
      "bfont": "Helvetica",
      "bsize": 0
    },
    {
      "name": "Back -> Front",
      "ord": 0,
      "qfmt": "<!-- version f0935e4 -->\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Subdeck\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Subdeck\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Subdeck}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Subdeck\n      </button> |\n      {{/Subdeck}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}}\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex;\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none;\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none;\">{{clickable::Tags}}</div>\n  </span>\n  {{/Tags}}\n  {{#Subdeck}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex;\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none;\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none;\">Subdeck: {{Subdeck}}</div>\n  </span>\n  {{/Subdeck}}\n  {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex;\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none;\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none;\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr>\n\n</div>\n\n<div id=\"container\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    <div>{{Rückseite}}</div>\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    if (!indentation) { return; }\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>",
      "afmt": "<!-- version f0935e4 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Subdeck\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Subdeck\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Subdeck}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Subdeck\n      </button> |\n      {{/Subdeck}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}}\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex;\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none;\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none;\">{{clickable::Tags}}</div>\n  </span>\n  {{/Tags}}\n  {{#Subdeck}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex;\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none;\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none;\">Subdeck: {{Subdeck}}</div>\n  </span>\n  {{/Subdeck}}\n  {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex;\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none;\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none;\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr>\n\n</div>\n\n<div id=\"container\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    <div>{{Rückseite}}</div>\n\n    <hr>\n\n    <div>{{Vorderseite}}</div>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- Extra field -->\n    {{#Extra}}\n    <div id=\"extra\" style=\"display: none;\">\n      <br><br>{{edit:Extra}}\n    </div><br>\n    {{/Extra}}\n\n    <!-- BUTTON FIELDS -->\n    {{#Tabellen}}\n    <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Tabellen\" style=\"display: none;\">\n      <button id=\"button-definition\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Tabellen\n      </button>\n      <div dir=\"auto\" id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Tabellen}}</div>\n    </span>\n    {{/Tabellen}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n  try {\n    for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n      href = link.href\n      text = link.innerText\n\n      const el = document.createElement('a');\n      el.setAttribute('href', link.href);\n\n      const btn = document.createElement('button');\n      btn.classList.add('button-general');\n      btn.classList.add('expanded-button');\n\n      domain = href.replace(/.+\\/\\/|(www|flexikon|register|de|next|com).|\\..+/g, '');\n      domainDict = {\n        \"amboss\": \"__amboss.svg\",\n        \"wikipedia\": \"__wikipedia.svg\",\n        \"doccheck\": \"__doccheck.png\",\n        \"notfallguru\": \"__notfallguru.svg\",\n        \"awmf\": \"__awmf.svg\",\n        \"gelbe-liste\": \"__gelbe-liste.png\",\n        \"embryotox\": \"__embryotox.svg\",\n        \"radiopaedia\": \"__radiopaedia.png\",\n        \"orphanet\": \"__orphanet.png\",\n      }\n      if (domain in domainDict) {\n        icon = domainDict[domain]\n      } else {\n        icon = \"__internet.svg\"\n      }\n\n      const img = document.createElement('img');\n      img.setAttribute('src', icon);\n      img.setAttribute('style', 'height: 10px;');\n\n      btn.appendChild(img);\n      btn.innerHTML = btn.innerHTML + \" \" + text;\n\n      el.appendChild(btn);\n\n      document.getElementById(\"linkcontainer\").appendChild(el)\n    }\n  }\n  catch (err) {\n    console.log(err)\n  }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-uafi\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>",
      "bqfmt": "{{Rückseite}}",
      "bafmt": "{{Rückseite}}",
      "did": null,
      "bfont": "Helvetica",
      "bsize": 0
    }
  ],
  "flds": [
    {
      "name": "Vorderseite",
      "ord": 0,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "description": "",
      "plainText": false,
      "collapsed": false,
      "excludeFromSearch": false
    },
    {
      "name": "Rückseite",
      "ord": 1,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "description": "",
      "plainText": false,
      "collapsed": false,
      "excludeFromSearch": false
    },
    {
      "name": "Extra",
      "ord": 2,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "description": "",
      "plainText": false,
      "collapsed": false,
      "excludeFromSearch": false
    },
    {
      "name": "Tabellen",
      "ord": 3,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "description": "",
      "plainText": false,
      "collapsed": false,
      "excludeFromSearch": false
    },
    {
      "name": "Note ID",
      "ord": 4,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "description": "",
      "plainText": false,
      "collapsed": false,
      "excludeFromSearch": false,
      "meta": "noteid"
    }
  ],
  "css": "",
  "latexPre": "\\documentclass[12pt]{article}\n\\special{papersize=3in,5in}\n\\usepackage[utf8]{inputenc}\n\\usepackage{amssymb,amsmath}\n\\pagestyle{empty}\n\\setlength{\\parindent}{0in}\n\\begin{document}\n",
  "latexPost": "\\end{document}",
  "latexsvg": false,
  "req": [
    [
      0,
      "any",
      [
        0
      ]
    ]
  ],
  "tags": [],
  "vers": []
}