<!-- version f0935e4 -->
<!-- empty div to make AnkiDroid happy -->
<div></div>

<!-- include cloze_anything -->
<script defer src="_cloze_anything_0.4.js"></script>
<div id="back"></div>
<div id="cloze" data-card="{{Card}}"></div>

<script>
  // ############## USER CONFIGURATION START ##############
  // ##############  HINT REVEAL SHORTCUTS  ##############
  // All shortcuts will also open with "H" if using the Hint Hotkeys add-on 
  var ButtonShortcuts = {
    "Eigene Notizen & Bilder": "Alt + 1",
    "Eigene Prüfungsfragen": "Alt + 2",
    "Definitionen": "Alt + 3",
    "Merksprüche": "Alt + 4",
    "Klinik": "Alt + 5",
    "Präparat": "Alt + 6",
    "Memes": "Alt + 7",
    "linkContainer": "Alt + L",
    "Meditricks": "Alt + M",
    "Tags": "Alt + 8",
    "Quelle": "Alt + 9",
    "Note ID": "Alt + 0"
  }
  var ToggleNextButtonShortcut = "H"
  var ToggleAllButtonsShortcut = "J"
  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)

  // ##############  SHOW HINTS AUTOMATICALLY  ##############
  var ButtonAutoReveal = {
    "Eigene Notizen & Bilder": false,
    "Eigene Prüfungsfragen": false,
    "Definitionen": false,
    "Merksprüche": false,
    "Klinik": false,
    "Präparat": false,
    "Memes": false,
    "linkContainer": true,
    "Meditricks": false,
    "Tags": false,
    "Quelle": false,
    "Note ID": false
  }
  var ScrollToButton = false;

  // ##############  TAG SHORTCUT  ##############
  var toggleTagsShortcut = "C";

  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND
  var tagID = "XXXYYYZZZ"

  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN
  var numTagLevelsToShow = 0;

  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN
  var tagUniversity = "XXXYYYZZZ"

  // ##############  INDENTATION  ##############
  // Enable experimental heuristic indentation feature
  var indentation = true;

  // ##############  DIVI FORMAT  ##############
  // Enable experimental DIVI medication formatting feature
  var formattingDIVI = false;

  // ##############  CONFOUNDER FORMAT  ##############
  // Enable experimental confounder formatting feature
  var formattingConfounders = false;

  // ############  BIONIC READING  ############
  // Enable bionic reading feature (based on AnKing add-on)
  var bionicReading = false;

  // ##############  CLOZE ONE BY ONE  ##############
  var revealNextShortcut = "N"
  var revealNextWordShortcut = "Shift + N"
  var toggleAllShortcut = ","

  // Enables revealing of next Cloze by simply clicking / tapping anywhere on the card (except the buttons)
  var revealAnywhere = true;

  // INFO ----------------------
  // to make a card behave like normal clozes without one-by-one, set:
  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false
  // ---------------------------
  // THIS NEEDS TO BE SET ON THE BACK AS WELL
  // enables selective cloze one-by-one (e.g. only c1 and c3)
  // seperate wanted numbers by "," in one-by-one field
  var selectiveOneByOne = false;

  // THIS NEEDS TO BE SET ON THE BACK AS WELL
  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1
  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting
  var minNumberOfClozes = 3;

  // THIS NEEDS TO BE SET ON THE BACK AS WELL
  // enables cloze one-by-one even when one-by-one field is empty
  // minNumberOfClozes is still considered in this case
  // overridden in importance by selectiveOneByOne
  var alwaysOneByOne = true;
  // ----------------------------

  // Changes how "Reveal Next" and clicking behaves. Either "cloze" or "word".
  // "word" reveals word by word. 
  var revealNextClozeMode = "cloze"

  // Changes how fields with additional information are displayed.
  // true displays fields with additional information only if all clozes are revealed.
  var hideAdditional = true;
  var hideAdditionalButtons = true;

  // What cloze is hidden with
  var clozeHider = (elem) => "[&nbsp;_&nbsp;]"
  /*
  You can replace the above line with below examples. '█' or '_' works well for hiding clozes.
  
  // Fixed length:
  var clozeHider = (elem) => "███"
  // Replace each character with "█":
  var clozeHider = (elem) => "█".repeat(elem.textContent.length)
  // Show whitespaces:
  var clozeHider = (elem) => "[" + elem.textContent.split(" ").map((t) => "█".repeat(t.length)).join(" ") + "]"
  // Color-filled box (doesn't hide images):
  var clozeHider = (elem) => `<span style="background-color: red; color: transparent;">${elem.innerHTML}</span>`
  */

  // ############### USER CONFIGURATION END ###############
</script>

<!-- ###################################### -->
<!-- ##############  HEADER  ############## -->
<!-- ###################################### -->
<div id="header-container">
  <div class="header">
    <!-- TIMER -->
    <div class="head-flex-left">
      <span class="timer" id="timer"></span>
    </div>

    <div class="head-flex-mid">
      <!-- TAGS FIELD -->
      {{#Tags}}
      <button id="button-tags" class="button-general headhov"
        onclick="toggleHintBtn('hint-tags'); event.stopPropagation()">
        Tags
      </button> |
      {{/Tags}}

      <!-- SOURCE FIELD -->
      {{#Quelle}}
      <button id="button-src" class="button-general headhov"
        onclick="toggleHintBtn('hint-src'); event.stopPropagation()">
        Quelle
      </button>
      {{/Quelle}}

      <!-- NOTE ID FIELD -->
      {{#Note ID}} |
      <button id="button-nid" class="button-general headhov"
        onclick="toggleHintBtn('hint-nid'); event.stopPropagation()">
        Note ID
      </button>
      {{/Note ID}}
    </div>

    <!-- ERRATA BUTTON -->
    <div class="head-flex-right" onclick="event.stopPropagation()">
      <a id="link-ankihub" href="https://app.ankihub.net/">
        <button id="button-ankihub" class="button-general" title="Karte in AnkiHub">
          <strong>AnkiHub</strong>
        </button>
      </a>
      <script>
        try {
          document.getElementById("link-ankihub").href =
            document.getElementsByClassName("ankihub-view-note")[0].href
        } catch (e) { }
      </script>
    </div>
  </div>

  <!-- CLICKABLE COLORFUL TAGS -->
  {{#Tags}}
  <span id="hint-tags" class="hintBtn" data-name="Tags" style="display: flex">
    <button id="button-tags" style="all: unset !important; display: none"
      onclick="toggleHintBtn('hint-tags'); event.stopPropagation()"></button>
    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->
    <div id="tags-container" class="hints" style="display: none">
      {{clickable::Tags}}
    </div>
  </span>
  {{/Tags}} {{#Quelle}}
  <span id="hint-src" class="hintBtn" data-name="Quelle" style="display: flex">
    <button id="button-src" style="all: unset !important; display: none"
      onclick="toggleHintBtn('hint-src'); event.stopPropagation()"></button>
    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->
    <div id="src" class="hints" style="display: none">
      Quelle: {{Quelle}}
      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}
    </div>
  </span>
  {{/Quelle}} {{#Note ID}}
  <span id="hint-nid" class="hintBtn" data-name="Note ID" style="display: flex">
    <button id="button-nid" style="all: unset !important; display: none"
      onclick="toggleHintBtn('hint-nid'); event.stopPropagation()"></button>
    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->
    <div id="nid" class="hints" style="display: none">ID: {{Note ID}}</div>
  </span>
  {{/Note ID}}

  <hr />
</div>


<div id="container" class="anatomietrainer">
  <div class="col" id="container-content">

    <!-- ####################################### -->
    <!-- ##############  CONTENT  ############## -->
    <!-- ####################################### -->

    Wo liegt der <i>Ursprung</i> von <span class="frage">{{Muskel / Leitungsbahn}}</span>?

    <br>

    <!-- has to be <div> to allow for indentation -->
    <div class="cloze"><br>{{Ursprung}}</div>

    <!-- ClOZE ONE BY ONE BUTTONS -->
    <div id="onebyone-buttons" class="onebyone">
      <br>
      <button id="button-reveal-next" class="button-general button-one-by-one"
        onclick="revealNextCloze(); event.stopPropagation()">Reveal Next</button>
      <button id="button-toggle-all" class="button-general button-one-by-one"
        onclick="toggleAllCloze(); event.stopPropagation()">Toggle All</button>
    </div>

    <br>
    <br>

  </div>

  <div class="col" id="container-buttons">

    <!-- ####################################### -->
    <!-- ##############  BUTTONS  ############## -->
    <!-- ####################################### -->
    <!-- BUTTON FIELDS -->
    {{#Eigene Notizen & Bilder}}
    <span id="hint-zusatz" class="hintBtn" data-name="Eigene Notizen & Bilder" style="display: none;">
      <button id="button-zusatz" class="button-general" onclick="toggleHintBtn('hint-zusatz'); event.stopPropagation()">
        <img src="__zusatz.svg" style="height: 10px;"> Eigene Notizen & Bilder
      </button>
      <div dir="auto" id="zusatz" class="hints" style="display: none;">{{edit:Eigene Notizen & Bilder}}</div>
    </span>
    {{/Eigene Notizen & Bilder}}

    {{#Eigene Prüfungsfragen}}
    <span id="hint-hammer" class="hintBtn" data-name="Eigene Prüfungsfragen" style="display: none;">
      <button id="button-hammer" class="button-general" onclick="toggleHintBtn('hint-hammer'); event.stopPropagation()">
        <img src="__hammer.svg" style="height: 10px;"> Eigene Prüfungsfragen
      </button>
      <div dir="auto" id="hammer" class="hints" style="display: none;">{{edit:Eigene Prüfungsfragen}}</div>
    </span>
    {{/Eigene Prüfungsfragen}}

    {{#Definitionen}}
    <span id="hint-definition" class="hintBtn" data-name="Definitionen" style="display: none;">
      <button id="button-definition" class="button-general"
        onclick="toggleHintBtn('hint-definition'); event.stopPropagation()">
        <img src="__explanation.svg" style="height: 10px;"> Definitionen
      </button>
      <div dir="auto" id="definition" class="hints" style="display: none;">{{edit:Definitionen}}</div>
    </span>
    {{/Definitionen}}

    {{#Merksprüche}}
    <span id="hint-merksprueche" class="hintBtn" data-name="Merksprüche" style="display: none;">
      <button id="button-merksprueche" class="button-general"
        onclick="toggleHintBtn('hint-merksprueche'); event.stopPropagation()">
        <img src="__merkhilfe.svg" style="height: 10px;"> Merksprüche
      </button>
      <div dir="auto" id="merksprueche" class="hints" style="display: none;">{{edit:Merksprüche}}</div>
    </span>
    {{/Merksprüche}}

    {{#Klinik}}
    <span id="hint-klinik" class="hintBtn" data-name="Klinik" style="display: none;">
      <button id="button-klinik" class="button-general" onclick="toggleHintBtn('hint-klinik'); event.stopPropagation()">
        <img src="__stethoscope.svg" style="height: 10px;"> Klinik
      </button>
      <div dir="auto" id="klinik" class="hints" style="display: none;">{{edit:Klinik}}</div>
    </span>
    {{/Klinik}}

    {{#Präparat}}
    <span id="hint-praeparat-link" onclick="event.stopPropagation()" style="display: none;">
      <a href="{{text:Präparat}}">
        <button id="button-praeparat" class="button-general">
          <img src="__microscope.svg" style="height: 10px;"> Präparat
        </button>
      </a>
    </span>
    {{/Präparat}}

    {{#Virtuelle Mikroskopie}}
    <span id="hint-microscope-link" onclick="event.stopPropagation()" style="display: none;">
      <a href="{{text:Virtuelle Mikroskopie}}">
        <button id="button-microscope" class="button-general">
          <img src="__microscope.svg" style="height: 10px;"> Virtuelle Mikroskopie
        </button>
      </a>
    </span>
    {{/Virtuelle Mikroskopie}}

    {{#Smart Zoom}}
    <span id="hint-smartzoom-link" onclick="event.stopPropagation()" style="display: none;">
      <a href="{{text:Präparat}}">
        <button id="button-smartzoom" class="button-general">
          <img src="__microscope.svg" style="height: 10px;"> Smart Zoom
        </button>
      </a>
    </span>
    {{/Smart Zoom}}

    {{#Präparat}}
    <span id="hint-praeparat" class="hintBtn" data-name="Präparat" style="display: none;">
      <button id="button-praeparat" class="button-general"
        onclick="toggleHintBtn('hint-praeparat'); event.stopPropagation()">
        <img src="__microscope.svg" style="height: 10px;"> Präparat
      </button>
      <div dir="auto" id="praeparat" class="hints" style="display: none;">{{edit:Präparat}}</div>
    </span>
    {{/Präparat}}

    {{#Memes}}
    <span id="hint-memes" class="hintBtn" data-name="Memes" style="display: none;">
      <button id="button-memes" class="button-general" onclick="toggleHintBtn('hint-memes'); event.stopPropagation()">
        <img src="__sonstiges.svg" style="height: 10px;"> Memes
      </button>
      <div dir="auto" id="memes" class="hints" style="display: none;">{{edit:Memes}}</div>
    </span>
    {{/Memes}}

    <!-- LINEBREAKS IF BUTTONS EXIST -->
    <script>
      var array = [`{{Eigene Notizen & Bilder}}`, `{{Eigene Prüfungsfragen}}`, `{{Definitionen}}`, `{{Merksprüche}}`, `{{Klinik}}`, `{{Präparat}}`, `{{Memes}}`];
      var anyistrue = (element) => element;
      if (array.some(anyistrue)) {
        document.getElementById("linebreaksIfButtons").innerHTML = "<br>";
      }
    </script>
    <div id="linebreaksIfButtons"></div>

    <!-- Extra field -->
    {{#Extra}}
    <div id="extra" style="display: none;">
      <br>{{edit:Extra}}<br><br>
    </div>
    {{/Extra}}

    <!-- Image field -->
    {{#Bild}}
    <div id="image" style="display: none;">
      {{edit:Bild}}<br><br></div>
    {{/Bild}}
    {{^Bild}}
    <span id="image" style="display: none;"></span>
    {{/Bild}}
    {{#Bild}}
    <span id="hint-image" style="display: none;">
      <button id="button-image" class="button-general"
        onclick="var image = document.getElementById('image'); if (image.style.display == 'none') { image.style.display = 'block' } else { image.style.display = 'none' }; event.stopPropagation()">
        <img src="__image.svg" style="height: 10px;"> Abbildung
      </button>
    </span>
    {{/Bild}}

    <span id="hint-uafi" class="hintBtn" data-name="Ursprung, Ansatz, Verlauf, Funktion, Innervation, Äste"
      style="display: none;">
      <button id="button-uafi" class="button-general expanded-button"
        onclick="toggleHintBtn('hint-uafi'); event.stopPropagation()">
        <img src="__explanation.svg" style="height: 10px;"> Weitere Informationen
      </button>
      <div id="uafi" class="hints" style="display: block;">
        <table class="uncloze">
          {{#Ursprung}}
          <tr class="uafi-element" id="Ursprung">
            <td><i>Ursprung</i></td>
            <td>{{Ursprung}}</td>
          </tr>
          {{/Ursprung}}
          {{#Ansatz}}
          <tr class="uafi-element" id="Ansatz">
            <td><i>Ansatz</i></td>
            <td>{{Ansatz}}</td>
          </tr>
          {{/Ansatz}}
          {{#Verlauf}}
          <tr class="uafi-element" id="Verlauf">
            <td><i>Verlauf</i></td>
            <td>{{Verlauf}}</td>
          </tr>
          {{/Verlauf}}
          {{#Funktion}}
          <tr class="uafi-element" id="Funktion">
            <td><i>Funktion</i></td>
            <td>{{Funktion}}</td>
          </tr>
          {{/Funktion}}
          {{#Innervation}}
          <tr class="uafi-element" id="Innervation">
            <td><i>Innervation</i></td>
            <td>{{Innervation}}</td>
          </tr>
          {{/Innervation}}
          {{#Äste}}
          <tr class="uafi-element" id="Äste">
            <td><i>Äste</i></td>
            <td>{{Äste}}</td>
          </tr>
          {{/Äste}}
        </table>
      </div>

      <script>
        // iterate over all uafi-elements and hide only the one
        // that is equal to the card's answer (i.e., value of {{Card}})
        var uafiElements = document.getElementsByClassName("uafi-element");
        for (var i = 0; i < uafiElements.length; i++) {
          if ((("{{Card}}").startsWith(uafiElements[i].id))) {
            uafiElements[i].remove()
          }
        }
      </script>
    </span>

    {{#AMBOSS-Link}}
    <span id="hint-amboss" onclick="event.stopPropagation()" style="display: none;">
      <a href="{{text:AMBOSS-Link}}">
        <button id="button-amboss" class="button-general">
          <img src="__amboss.svg" style="height: 10px;"> AMBOSS&#8203;
        </button>
      </a>
    </span>
    {{/AMBOSS-Link}}

    {{#Thieme via medici-Link}}
    <span id="hint-thieme" onclick="event.stopPropagation()" style="display: none;">
      <a href="{{text:Thieme via medici-Link}}">
        <button id="button-thieme" class="button-general">
          <img id="button-thieme-img" src="__thieme-heart.svg" style="height: 10px;"> Thieme via medici
        </button>
      </a>
    </span>
    {{/Thieme via medici-Link}}

    {{#Meditricks}}
    <span id="hint-meditricks" class="hintBtn" data-name="Meditricks" style="display: none;">
      <button id="button-meditricks" class="button-general"
        onclick="toggleHintBtn('hint-meditricks'); event.stopPropagation()">
        <img src="__meditricks.svg" style="height: 10px;"> Meditricks
      </button>
      <div dir="auto" id="meditricks" class="hints" style="display: none;">{{edit:Meditricks}}</div>
    </span>
    {{/Meditricks}}

    {{#weitere Links}}
    <span id="hint-linkcontainer" class="hintBtn" data-name="linkContainer" style="display: none;">
      <button id="button-linkcontainer" class="button-general"
        onclick="toggleHintBtn('hint-linkcontainer'); event.stopPropagation()">
        <img src="__internet.svg" style="height: 10px;"> weitere Links
      </button>
      <div id="linkcontainer" class="hints" style="display: none;"></div>
      <span id="linkContainerLinks" style="display: none;">{{edit:weitere Links}}</span>
    </span>
    {{/weitere Links}}

  </div>
</div>

<!-- ##############  TEXT-TO-SPEECH ##############
replace the arrows/dashes from the statement below with double curly brackets-->
<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->

<!-- ####################################### -->
<!-- ##############  SCRIPTS  ############## -->
<!-- ####################################### -->

<!-- ############ DO NOT DELETE ############# -->
<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->

<!-- ############ DO NOT DELETE ############# -->

<script>
  /**
* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.
* 
* @param {String} text: The text to be rendered.
* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. "bold 14px verdana").
* 
* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393
*/
  function getTextWidth(text, font) {
    // re-use canvas object for better performance
    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement("canvas"));
    const context = canvas.getContext("2d");
    context.font = font;
    const metrics = context.measureText(text);
    return metrics.width;
  }

  function getCSSStyle(element, prop) {
    return window.getComputedStyle(element, null).getPropertyValue(prop);
  }

  function getCanvasFont(el = document.body) {
    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';
    const fontSize = getCSSStyle(el, 'font-size') || '16px';
    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';

    return `${fontWeight} ${fontSize} ${fontFamily}`;
  }

  /**
  * Iterates over a list of divs containing text to be indented
  *
  * @param {HTMLCollection} divs: The divs to be iterated over.
  */
  function indentText(divs) {
    // setup the indentation markers
    var numbers = "(" + "⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳".split("").join("|") + ")"
    var letters = "(" + "ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ".split("").join("|") + ")"
    var bulletP = "•"
    var minus = "– "
    var enter = "↳(?!( ↳|↳))"
    var arrow = "→"

    // heuristic indentation hierarchy
    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]

    // set up RegEx to analyze the provided divs
    // negative lookbehinds unfortunately do not work yet on iPad / Android
    var beginning = '(?<=<(br|td|td rowspan="\\d"|td colspan="\\d"|hr|div)>)(?<!cloze=")('
    var middle = ".*?)((?:<br>)(?=("
    var end = "))|(?=(<\/indent>|<\/div>|<\/td>|<br><br>|<img)))"

    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + "))|(?=<\/div>|<br><br>))", "g")
    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, "g")
    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, "g")
    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, "g")
    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, "g")
    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, "g")
    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, "g")

    // iterate over divs
    for (const div of divs) {
      // calculate indentation depths
      var canvasFont = getCanvasFont(div)
      var circledWidth = getTextWidth("① ", canvasFont).toString() + "px"
      var bulletPWidth = getTextWidth("• ", canvasFont).toString() + "px"
      var minusWidth = getTextWidth("– ", canvasFont).toString() + "px"
      var enterWidth = getTextWidth("↳ ", canvasFont).toString() + "px"
      var arrowWidth = getTextWidth("→ ", canvasFont).toString() + "px"

      var indentStart = '<indent style="margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;
      var indentEnd = ';">$2</indent>'

      // do the indentation
      divHTML = div.outerHTML
      divHTML = divHTML.replaceAll(/(\d|<sup>|<sub>)–(\d|<\/sup>|<\/sub>|&#8288;)/g, "$1‒$2").replaceAll("–&#8288;", "‒&#8288;")
      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)
      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)
      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)
      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)

      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)
      divHTML = divHTML.replaceAll("↳ ↳ ", "↳ ").replaceAll("↳↳ ", "↳ ")
      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)
      divHTML = divHTML.replaceAll("↳ ↳ ", "↳ ").replaceAll("↳↳ ", "↳ ")
      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)
      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)

      div.outerHTML = divHTML.replaceAll("<br></indent>", "</indent><br>").replaceAll("</indent><br><br>", "</indent><br>").replaceAll("</indent><br><img", "</indent><img")
    }
  }

  // do the indentation if wanted
  if (indentation) {
    indentText(document.getElementById("container-content").getElementsByTagName("div"));
    indentText(document.getElementById("container-buttons").getElementsByTagName("div"));
  }
</script>

<!-- NOT-PERSISTING EVENT LISTENER -->
<script>
  if (window.ankingEventListeners) {
    for (const listener of ankingEventListeners) {
      const type = listener[0]
      const handler = listener[1]
      document.removeEventListener(type, handler)
    }
  }
  window.ankingEventListeners = []

  window.ankingAddEventListener = function (type, handler) {
    document.addEventListener(type, handler)
    window.ankingEventListeners.push([type, handler])
  }
</script>

<!-- Shortcut Matcher Function -->
<script>
  var specialCharCodes = {
    "-": "minus",
    "=": "equal",
    "[": "bracketleft",
    "]": "bracketright",
    ";": "semicolon",
    "'": "quote",
    "`": "backquote",
    "\\": "backslash",
    ",": "comma",
    ".": "period",
    "/": "slash",
  };

  // Returns function that match keyboard event to see if it matches given shortcut.
  function shortcutMatcher(shortcut) {
    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())
    let mainKey = shortcutKeys[shortcutKeys.length - 1]
    if (mainKey.length === 1) {
      if (/\d/.test(mainKey)) {
        mainKey = "digit" + mainKey
      } else if (/[a-zA-Z]/.test(mainKey)) {
        mainKey = "key" + mainKey
      } else {
        let code = specialCharCodes[mainKey];
        if (code) {
          mainKey = code
        }
      }
    }
    let ctrl = shortcutKeys.includes("ctrl")
    let shift = shortcutKeys.includes("shift")
    let alt = shortcutKeys.includes("alt")

    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {
      if (mainKey !== event.code.toLowerCase()) return false
      if (ctrl !== (event.ctrlKey || event.metaKey)) return false
      if (shift !== event.shiftKey) return false
      if (alt !== event.altKey) return false
      return true
    }.bind(window, ctrl, shift, alt, mainKey)

    return matchShortcut
  }
</script>

<!-- IMAGE BLUR -->
<script>
  function makeImagesBlur() {
    for (const image of document.querySelectorAll(".blur")) {
      image.classList.add("tappable");
      image.addEventListener("click", () => {
        setTimeout(function () {
          image.classList.toggle("blur");
        }, 200);
      });
    }
  }

  makeImagesBlur();
</script>

<!-- CLICKABLE COLORFUL TAGS -->
{{#Tags}}
<script>
  var tagContainer = document.getElementById("tags-container")

  function formatTag(tag) {
    // remove unnecessary whitespace
    tag = tag.trim()

    // numTagLevelsToShow == 0 means the whole tag should be shown
    if (numTagLevelsToShow != 0) {
      tag = tag.split("::").slice(-numTagLevelsToShow).join("::");
    }

    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags
    if (((tag.split("::")[1] == "#UNIVERSITÄTEN") || (tag.split("::")[1] == "#Universitäten")) && (tag.split("::")[2] != tagUniversity)) return null;
    if (tag.split("::")[1] == "§NEW_CARDS") return null;
    if (tag.split("::")[1] == "§Projekt_Anki") return null;
    if (tag.split("::")[0] == "AnkiHub_Subdeck") return null;

    // improve legibility of tags
    // remove unnecessary prefixes
    tag = tag.replaceAll("#Ankizin_v1::", "").replaceAll("#Ankizin_v2::", "").replaceAll("#Ankizin_v3::", "").replaceAll("#Ankizin_vAnkihub::", "")
    tag = tag.replaceAll("#Ankiphil_Vorklinik_v4.3::", "").replaceAll("#Ankiphil_Klinik_v1.4::", "");
    // clean duplicated prefixes
    tag = tag.replaceAll("#AMBOSS::", "").replaceAll("Bibliothek-Vorklinik::", "").replaceAll("Bibliothek-Klinik::", "").replaceAll("#M2_M3_Klinik::", "Klinik::").replaceAll("#M1_Vorklinik_(work_in_progress)::", "Vorklinik::");
    // clean unncessarily long "Lernplan" tags
    tag = tag.replaceAll("M1-50-Tage-Lernplan_Intensiv", "M1_50_Tage_Intensiv").replaceAll("M1-30-Tage-Lernplan_Turbo", "M1_30_Tage_Turbo").replaceAll("M2-100-Tage-Lernplan", "M2_100_Tage").replaceAll("M3-Kenntnisprüfung", "M3");
    tag = tag.replaceAll("M1-30-T_", "").replaceAll("M1-50-I_", "").replaceAll("M2_Lerntag", "Lerntag")
    // change HTML symbols
    tag = tag.replaceAll("::", " →&nbsp;").replaceAll("-", "&#8209;").replaceAll("_", " ");

    return tag.trim();
  }

  if (tagContainer.childElementCount == 0) {
    var tagList = tagContainer.innerHTML.trim().split(" ");
    var kbdList = [];
    var newTagContent = document.createElement("div");

    for (var i = 0; i < tagList.length; i++) {
      var newTag = document.createElement("kbd");
      var tag = tagList[i];

      formattedTag = formatTag(tag);
      if (formattedTag == null) continue;

      newTag.innerHTML = formattedTag;
      newTagContent.append(newTag)
    }

    tagContainer.innerHTML = newTagContent.innerHTML;
    tagContainer.style.cursor = "default";
  }

  if (tagContainer.innerHTML.indexOf(tagID) != -1) {
    tagContainer.style.backgroundColor = "rgba(251,11,11,.15)";
  }

  function showtags() {
    var tagContainerShortcut = document.getElementById("tags-container");

    if (tagContainerShortcut.style.display === "none") {
      tagContainerShortcut.style.display = "inline";
    } else {
      tagContainerShortcut.style.display = "none";
    }
  }

  var isShortcut = shortcutMatcher(toggleTagsShortcut)

  ankingAddEventListener('keyup', function (e) {
    if (isShortcut(e)) {
      toggleHintBtn('hint-tags');
      showtags();
    }
  });

  var elements = document.getElementsByTagName('kbd');
  for (index = elements.length - 1; index >= 0; index--) {
    formattedTag = formatTag(elements[index].innerHTML);

    if (formattedTag == null) {
      elements[index].remove();
      continue;
    }

    elements[index].innerHTML = formattedTag;
  }
</script>
{{/Tags}}

<!-- HINT BUTTONS SETUP -->
<script>
  (function () {
    window.toggleHintBtn = function (containerId, noScrolling = false) {
      const container = document.getElementById(containerId)
      // const link = container.getElementsByTagName("a")[0]
      const button = container.getElementsByTagName("button")[0]
      const hint = container.getElementsByTagName("div")[0]

      if (hint.style.display == "none") {
        button.classList.add("expanded-button")
        hint.style.display = "block"
        // link.style.display = "none"
        if (ScrollToButton && !noScrolling) {
          hint.scrollIntoView({
            behavior: "smooth", // "auto" for instant scrolling
            block: "start",
            inline: "nearest"
          });
        }
      } else {
        button.classList.remove("expanded-button")
        hint.style.display = "none"
        // link.style.display = ""
      }
    }

    window.toggleNextButton = function () {
      // adapted from Hint Hotkey add-on
      var customEvent = document.createEvent('MouseEvents');
      customEvent.initEvent('click', false, true);
      var arr = document.getElementsByTagName('a');
      for (var i = 0; i < arr.length; i++) {
        var el = arr[i];
        if (
          window.getComputedStyle(el).display === 'none' ||
          window.getComputedStyle(el.parentElement).display === 'none'
        ) {
          continue;
        }
        if (el.classList.contains("hint")) {
          el.dispatchEvent(customEvent);
          break
        }
      }
    }

    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)
    ankingAddEventListener("keydown", (evt) => {
      if (evt.repeat) return
      if (isToggleNextShortcut(evt)) {
        toggleNextButton()
      }
    })

    const setupHintBtn = function (elem) {
      const containerId = elem.id
      const fieldName = elem.dataset.name
      const button = elem.getElementsByClassName("button")[0]
      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`
      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {
        toggleHintBtn(containerId, noScrolling = true)
      }

      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])
      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)
      ankingAddEventListener("keydown", (evt) => {
        if (evt.repeat) return
        if (isShortcut(evt) || isToggleAllShortcut(evt)) {
          toggleHintBtn(containerId)
        }
      })
    }

    const hints = document.getElementsByClassName("hintBtn")
    for (let i = 0; i < hints.length; i++) {
      setupHintBtn(hints[i])
    }
  })()
</script>

<script>
  try {
    for (const link of document.getElementById("linkContainerLinks").querySelectorAll("a")) {
      href = link.href
      text = link.innerText

      const el = document.createElement('a');
      el.setAttribute('href', link.href);

      const btn = document.createElement('button');
      btn.classList.add('button-general');
      btn.classList.add('expanded-button');

      domain = href.replace(/.+\/\/|(www|flexikon|register|de|next|com).|\..+/g, '');
      domainDict = {
        "amboss": "__amboss.svg",
        "wikipedia": "__wikipedia.svg",
        "doccheck": "__doccheck.png",
        "notfallguru": "__notfallguru.svg",
        "awmf": "__awmf.svg",
        "gelbe-liste": "__gelbe-liste.png",
        "embryotox": "__embryotox.svg",
        "radiopaedia": "__radiopaedia.png",
        "orphanet": "__orphanet.png",
      }
      if (domain in domainDict) {
        icon = domainDict[domain]
      } else {
        icon = "__internet.svg"
      }

      const img = document.createElement('img');
      img.setAttribute('src', icon);
      img.setAttribute('style', 'height: 10px;');

      btn.appendChild(img);
      btn.innerHTML = btn.innerHTML + " " + text;

      el.appendChild(btn);

      document.getElementById("linkcontainer").appendChild(el)
    }
  }
  catch (err) {
    console.log(err)
  }
</script>

<script>
  var buttonIds = ["extra", "image", "hint-zusatz", "hint-definition", "hint-hammer", "hint-klinik", "hint-praeparat", "hint-microscope", "hint-smartzoom", "hint-histotrainer", "hint-uafi", "hint-merksprueche", "hint-memes", "hint-image", "hint-amboss", "hint-thieme", "hint-meditricks", "hint-linkcontainer"]

  for (const button in buttonIds) {
    try {
      document.getElementById(buttonIds[button]).style.removeProperty("display")
    } catch (exception) {
      console.log(exception)
    }
  }
</script>

<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->

<script>
  if (typeof (window.Persistence) === 'undefined') {
    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';
    var _defaultKey = '_default';
    window.Persistence_sessionStorage = function () { // used in android, iOS, web
      var isAvailable = false;
      try {
        if (typeof (window.sessionStorage) === 'object') {
          isAvailable = true;
          this.clear = function () {
            for (var i = 0; i < sessionStorage.length; i++) {
              var k = sessionStorage.key(i);
              if (k.indexOf(_persistenceKey) == 0) {
                sessionStorage.removeItem(k);
                i--;
              }
            };
          };
          this.setItem = function (key, value) {
            if (value == undefined) {
              value = key;
              key = _defaultKey;
            }
            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));
          };
          this.getItem = function (key) {
            if (key == undefined) {
              key = _defaultKey;
            }
            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));
          };
          this.removeItem = function (key) {
            if (key == undefined) {
              key = _defaultKey;
            }
            sessionStorage.removeItem(_persistenceKey + key);
          };
          this.getAllKeys = function () {
            var keys = [];
            var prefixedKeys = Object.keys(sessionStorage);
            for (var i = 0; i < prefixedKeys.length; i++) {
              var k = prefixedKeys[i];
              if (k.indexOf(_persistenceKey) == 0) {
                keys.push(k.substring(_persistenceKey.length, k.length));
              }
            };
            return keys.sort()
          }
        }
      } catch (err) { }
      this.isAvailable = function () {
        return isAvailable;
      };
    };
    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac
      var obj = window[persistentKey];
      var isAvailable = false;
      if (typeof (obj) === 'object') {
        isAvailable = true;
        this.clear = function () {
          obj[_persistenceKey] = {};
        };
        this.setItem = function (key, value) {
          if (value == undefined) {
            value = key;
            key = _defaultKey;
          }
          obj[_persistenceKey][key] = value;
        };
        this.getItem = function (key) {
          if (key == undefined) {
            key = _defaultKey;
          }
          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];
        };
        this.removeItem = function (key) {
          if (key == undefined) {
            key = _defaultKey;
          }
          delete obj[_persistenceKey][key];
        };
        this.getAllKeys = function () {
          return Object.keys(obj[_persistenceKey]);
        }

        if (obj[_persistenceKey] == undefined) {
          this.clear();
        }
      }
      this.isAvailable = function () {
        return isAvailable;
      };
    };
    /*
     *   client  | sessionStorage | persistentKey | useful location |
     * ----------|----------------|---------------|-----------------|
     * web       |       YES      |       -       |       NO        |
     * windows   |       NO       |       py      |       NO        |
     * android   |       YES      |       -       |       NO        |
     * linux 2.0 |       NO       |       qt      |       YES       |
     * linux 2.1 |       NO       |       qt      |       YES       |
     * mac 2.0   |       NO       |       py      |       NO        |
     * mac 2.1   |       NO       |       qt      |       YES       |
     * iOS       |       YES      |       -       |       NO        |
     */
    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web
    if (!Persistence.isAvailable()) {
      window.Persistence = new Persistence_windowKey("py"); // windows, mac (2.0)
    }
    if (!Persistence.isAvailable()) {
      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful
      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);
      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {
        window.Persistence = new Persistence_windowKey("qt"); // linux, mac (2.1)
      }
    }
  }
</script>

<!-- AUTOFLIP BACK SCRIPT -->
<script>
  // autoflip hides card in front template
  document.getElementById("qa").style.removeProperty("display")
</script>

<!-- CLOZE ONE BY ONE SCRIPT -->
<style>
  .cloze-replacer:hover {
    cursor: pointer;
  }

  .cloze-hidden {
    display: none;
  }

  .cloze-replacer .hidden {
    display: none;
  }

  #extra.hidden {
    display: none;
  }
</style>

<!--
 Based on the AnKing Notetype, but expanded and modified by phyn.
 Credit to the original authors, except where modified or otherwise indicated.
-->

<script>
    (function () {
      // enables cloze one-by-one even when one-by-one field is empty
      // minNumberOfClozes is still considered in this case
      // overridden in importance by selectiveOneByOne
      var clozeOneByOneEnabled = true;

      // remove the clickAnywhere function from global scope
      document.documentElement.removeAttribute("onclick")

      // --- CHECK IF ONE BY ONE IS GENERALLY ENABLED FOR THIS NOTE ---
      var oneByOneFieldNotEmpty = "{{One by one}}" !== "";
      try {
        clozeOneByOneEnabled = alwaysOneByOne || oneByOneFieldNotEmpty;
      } catch (exception) {
        console.log(exception)
      }

      /**
   * helper functions to show / hide fields containing additional information
   */
      const showExtra = function () {
        try {
          document.getElementById("extra").style.removeProperty("display");
        } catch (exception) {
          console.log(exception);
        }
        try {
          document.getElementById("image").style.removeProperty("display");
        } catch (exception) {
          console.log(exception);
        }
      };

      const hideExtra = function () {
        try {
          document.getElementById("extra").style.display = "none";
        } catch (exception) {
          console.log(exception);
        }
        try {
          document.getElementById("image").style.display = "none";
        } catch (exception) {
          console.log(exception);
        }
      };

      const buttonIds = [
        "hint-zusatz",
        "hint-definition",
        "hint-hammer",
        "hint-klinik",
        "hint-praeparat",
        "hint-microscope",
        "hint-smartzoom",
        "hint-histotrainer",
        "hint-uafi",
        "hint-merksprueche",
        "hint-memes",
        "hint-image",
        "hint-amboss",
        "hint-thieme",
        "hint-meditricks",
        "hint-linkcontainer",
      ];

      const showExtraButtons = function () {
        for (const button in buttonIds) {
          try {
            document
              .getElementById(buttonIds[button])
              .style.removeProperty("display");
          } catch (exception) {
            console.log(exception);
          }
        }
      };

      const hideExtraButtons = function () {
        for (const button in buttonIds) {
          try {
            document.getElementById(buttonIds[button]).style.display = "none";
          } catch (exception) {
            console.log(exception);
          }
        }
      };


      // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---
      /**
       * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)
       */
      const getCardNumber = function () {
        clz = document.body.className;
        const regex = /card(\d+)/gm;

        let clz2;
        try {
          clz2 = document.getElementById("cloze").getAttribute("data-card");
        } catch (e) {
          clz2 = "";
        }
        const regex2 = /.*?Cloze(\d+)/gm;

        let m;

        if ((m = regex2.exec(clz2)) !== null) {
          return m[1];
        } else if ((m = regex.exec(clz)) !== null) {
          return m[1];
        } else {
          // Should only fire if card is not cloze
          console.error("Cannot find cardN class of body element!");
          return "0";
        }
      }

      var clozeType = "cloze"
      // parse the cloze numbers for which selectiveOneByOne is enabled
      var clozeNumbers = "{{One by one}}".split(',').filter(element => element).map(Number)
      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))

      var numClozesForNumber = 0;

      // Only count if minNumberOfClozes is set (truthy)
      if (minNumberOfClozes) {
        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists

        if (clozeFieldExists && clozeType == "cloze") { // If 'clozefield' exists, count '.cloze' elements within it
          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;
        } else if (clozeType == "cloze") {
          numClozesForNumber = document.querySelectorAll('.cloze').length;
        } else if (clozeType == "imageOcclusion") {
          numClozesForNumber = document.querySelectorAll(".cloze[data-ordinal='" + getCardNumber() + "']").length;
        } else if (clozeType == "imageOcclusionBack") {
          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;
        }
      }
      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0

      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |
      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|
      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |
      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |
      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |
      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |
      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F
      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F
      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F
      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F
      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|
      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |
      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |
      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M
      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M
      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |
      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |
      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M
      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M
      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|
      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |
      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |
      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |
      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C
      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F
      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F
      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F
      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F
      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|
      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S
      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S
      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S
      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S
      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S
      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S
      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S
      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S

      // Determine if OneByOne should be disabled based on the logic table.
      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),
      // corresponding to the rows where 'OneByOne' is FALSE in the table.
      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne
      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)

      if (
        // Case 1: !A && !S (Covers all rows where A=F, S=F)
        (!alwaysOneByOne && !selectiveOneByOne) ||

        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)
        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||

        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)
        (selectiveOneByOne && oneByOneFieldEmpty) ||

        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)
        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)
      ) {
        clozeOneByOneEnabled = false;
      }

      if (!clozeOneByOneEnabled) {
        showExtra()
        showExtraButtons()
        document.getElementById("onebyone-buttons").style.display = "none"
        document.getElementById("qa").style.removeProperty("display")
        return
      }

      // Needed for amboss to recognize first word in .cloze-hidden
      const CLOZE_REPLACER_SEP = "<span class='hidden'> </span>"

      const hideAllCloze = function (initial) {
        let clozes = document.getElementsByClassName("cloze")
        let count = 0 // hidden cloze count
        for (const cloze of clozes) {
          const existingHidden = cloze.getElementsByClassName("cloze-hidden")[0]
          if (existingHidden) {
            revealCloze(cloze);
          }
          if (cloze.offsetWidth === 0) {
            continue
          }
          const clozeReplacer = document.createElement("span")
          const clozeHidden = document.createElement("span")
          clozeReplacer.classList.add("cloze-replacer")
          clozeHidden.classList.add("cloze-hidden")
          while (cloze.childNodes.length > 0) {
            clozeHidden.appendChild(cloze.childNodes[0])
          }
          cloze.appendChild(clozeReplacer)
          cloze.appendChild(clozeHidden)

          var clozeHints = Persistence.getItem("clozeHints");
          if (clozeHints && clozeHints[count]) {
            clozeReplacer.classList.add("cloze-hint")
            clozeReplacer.innerHTML = clozeHints[count] + CLOZE_REPLACER_SEP
          } else {
            clozeReplacer.innerHTML = clozeHider(cloze) + CLOZE_REPLACER_SEP
          }
          count += 1
          document.getElementById("button-reveal-next").style.display = "inline-block";
          if (initial) {
            cloze.addEventListener("touchend", revealClozeClicked)
            cloze.addEventListener("click", revealClozeClicked)
            cloze.classList.add("one-by-one");
          }
        }

        // Hide #extra until all clozes are shown
        const extra = document.getElementById("extra");
        if (extra) {
          extra.classList.add("hidden");
        }

        hideExtra();
        hideExtraButtons();
        if (revealAnywhere) {
          document.documentElement.setAttribute("onclick", "revealNextCloze(); event.stopPropagation()")
        }


        // Also hide autoReveal fields
        for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {
          const container = document.querySelector(`[data-name="${field}"]`)
          if (container) {
            const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`
            if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {
              // const link = container.getElementsByTagName("a")[0]
              const button = container.getElementsByTagName("button")[0]
              const hint = container.getElementsByTagName("div")[0]
              button.classList.remove("expanded-button")
              hint.style.display = "none"
              // link.style.display = ""
            }
          }
        }
      }

      const revealCloze = function (cloze) {
        const clozeReplacer = cloze.getElementsByClassName("cloze-replacer")[0]
        const clozeHidden = cloze.getElementsByClassName("cloze-hidden")[0]
        if (!clozeReplacer || !clozeHidden) return;

        cloze.removeChild(clozeReplacer)
        cloze.removeChild(clozeHidden)
        while (clozeHidden.childNodes.length > 0) {
          cloze.appendChild(clozeHidden.childNodes[0])
        }
        maybeRevealExtraField()
      }

      const revealClozeWord = function (cloze) {
        const clozeReplacer = cloze.getElementsByClassName("cloze-replacer")[0]
        const clozeHidden = cloze.getElementsByClassName("cloze-hidden")[0]
        if (!clozeReplacer || !clozeHidden) return;

        let range = new Range()
        range.setStart(clozeHidden, 0)
        const foundSpace = setRangeEnd(range, clozeHidden, "beforeFirstSpace")
        if (!foundSpace) {
          range.setEnd(clozeHidden, clozeHidden.childNodes.length)
        }
        let fragment = range.extractContents()
        cloze.insertBefore(fragment, clozeReplacer)
        // Extract whitespaces after word
        range = new Range()
        range.setStart(clozeHidden, 0)
        const foundWord = setRangeEnd(range, clozeHidden, "beforeFirstChar")
        if (!foundWord) {
          range.setEnd(clozeHidden, clozeHidden.childNodes.length)
        }
        fragment = range.extractContents();
        cloze.insertBefore(fragment, clozeReplacer)
        if (!foundWord) {
          cloze.removeChild(clozeHidden)
          cloze.removeChild(clozeReplacer)
          maybeRevealExtraField()
          return
        }
        clozeReplacer.innerHTML = clozeHider(clozeHidden) + CLOZE_REPLACER_SEP
        if (clozeReplacer.classList.contains("cloze-hint")) [
          clozeReplacer.classList.remove("cloze-hint")
        ]
        maybeRevealExtraField()
      }

      const revealNextClozeOf = (type) => {
        const nextHidden = document.querySelectorAll(".cloze-hidden")
        const nextNextHidden = nextHidden.length > 1 ? true : false
        if (!nextNextHidden) {
          document.documentElement.removeAttribute("onclick")
          document.getElementById("button-reveal-next").style.display = "none";
        }
        if (!nextHidden) {
          return
        }
        const cloze = clozeElOfClozeHidden(nextHidden[0]);
        if (type === "word") {
          revealClozeWord(cloze)
        } else if (type === "cloze") {
          revealCloze(cloze)
        } else {
          console.error("Invalid type: " + type)
        }
      }

      const revealClozeClicked = function (ev) {
        let elem = ev.currentTarget
        if (!ev.altKey && (revealNextClozeMode !== "word")) {
          revealCloze(elem)
        } else {
          revealClozeWord(elem)
        }
        ev.stopPropagation()
        ev.preventDefault()
      }

      window.revealNextCloze = function () {
        revealNextClozeOf(revealNextClozeMode)
      }

      window.toggleAllCloze = function () {
        let elems = document.querySelectorAll(".cloze-hidden")
        if (elems.length > 0) {
          for (const elem of elems) {
            const cloze = clozeElOfClozeHidden(elem)
            revealCloze(cloze)
          }
          document.documentElement.removeAttribute("onclick")
          document.getElementById("button-reveal-next").style.display = "none"
        } else {
          hideAllCloze(initial = false)
        }
      }

      const clozeElOfClozeHidden = (cloze) => {
        while (!cloze.classList.contains("cloze")) {
          cloze = cloze.parentElement;
        }
        return cloze;
      }

      const maybeRevealExtraField = () => {
        let elems = document.querySelectorAll(".cloze-hidden")
        if (elems.length == 0) {
          const extra = document.getElementById("extra")
          if (extra) {
            extra.classList.remove("hidden")
          }

          showExtra();
          showExtraButtons();
          document.documentElement.removeAttribute("onclick")

          // Also reveal autoReveal fields
          for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {
            const container = document.querySelector(`[data-name="${field}"]`)
            if (container) {
              const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`
              if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {
                // const link = container.getElementsByTagName("a")[0]
                const button = container.getElementsByTagName("button")[0]
                const hint = container.getElementsByTagName("div")[0]
                button.classList.add("expanded-button")
                hint.style.display = "block"
                // link.style.display = "none"
              }
            }
          }
        }
      }

      /**
       * mode: 'beforeFirstSpace' or 'beforeFirstChar'
       * Return `true` if it exists and setEnd() was called, otherwise `false`
       */
      const setRangeEnd = function (range, node, mode) {
        if (node.nodeType === Node.TEXT_NODE) {
          const regex = mode === 'beforeFirstSpace' ? /\s/ : /\S/
          const match = node.textContent.match(regex)
          if (match) {
            if (match.index === 0) {
              while (node.previousSibling === null) {
                node = node.parentElement
              }
              range.setEndBefore(node)
            } else {
              range.setEnd(node, match.index);
            }
            return true;
          } else {
            return false;
          }
        } else if (mode === 'beforeFirstChar' && isCharNode(node)) {
          range.setEndBefore(node)
          return true
        } else if (!ignoreSpaceInNode(node)) {
          for (const child of node.childNodes) {
            if (setRangeEnd(range, child, mode)) {
              return true;
            }
          }
          return false;
        }
      }

      const ignoreSpaceInNode = function (node) {
        return node.tagName === "MJX-ASSISTIVE-MML"
      }

      const isCharNode = function (node) {
        return ["IMG", "MJX-CONTAINER"].includes(node.tagName)
      }

      hideAllCloze(initial = true)

      let isShowNextShortcut = shortcutMatcher(window.revealNextShortcut)
      let isShowWordShortcut = shortcutMatcher(window.revealNextWordShortcut)
      let isToggleAllShortcut = shortcutMatcher(window.toggleAllShortcut)
      ankingAddEventListener("keydown", (ev) => {
        let next = isShowNextShortcut(ev)
        let word = isShowWordShortcut(ev)
        let all = isToggleAllShortcut(ev)
        if (next) {
          revealNextClozeOf("cloze")
        } else if (word) {
          revealNextClozeOf("word")
        } else if (all) {
          toggleAllCloze()
        } else {
          return;
        }
        ev.stopPropagation()
        ev.preventDefault()
      });
    })()
</script>

<!-- COUNTDOWN TIMER -->
<script>
  function countdown(elementName, minutes, seconds) {
    var element, endTime, mins, msLeft, time;
    function twoDigits(n) {
      return (n <= 9 ? "0" + n : n);
    }
    function updateTimer() {
      msLeft = endTime - (+new Date);

      if (msLeft < 1000) {
        element.innerHTML = timeOverMsg;
      } else {
        time = new Date(msLeft);
        mins = time.getUTCMinutes();
        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());
        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);
      }
    }
    element = document.getElementById(elementName);
    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;
    updateTimer();
  }
  countdown("timer", minutes, seconds); //2nd value is the minute, 3rd is the seconds
</script>

<script>
  /*
    MODIFIED VERSION OF:
    * @name        replaceUsingDictionary
    * @author      Rob W http://stackoverflow.com/users/938089/rob-w
    * @description Replaces phrases in a string, based on keys in a given dictionary.
    *              Each key is used only once, and the replacements are case-insensitive
    * @param       Object dictionary  {key: phrase, ...}
    * @param       String content
    * @param       Function replacehandler
    * @returns     Modified string
  */
  function replaceUsingDictionary(dictionary, content, replacehandler) {
    if (typeof replacehandler != "function") {
      // Default replacehandler function.
      replacehandler = function (key, dictionary) {
        return dictionary[key];
      }
    }

    var patterns = [], // \b is used to mark boundaries "foo" doesn't match food
      patternHash = {},
      oldkey, key, index = 0,
      output = [];
    for (key in dictionary) {
      // Case-insensitivity:
      key = (oldkey = key).toLowerCase();
      dictionary[key] = dictionary[oldkey];

      // Sanitize the key, and push it in the list
      // patterns.push('\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\$1') + ')\\b');
      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\$1') + ')');

      // Add entry to hash variable, for an optimized backtracking at the next loop
      patternHash[key] = index++;
    }
    var pattern = new RegExp(patterns.join('|'), 'gi'),
      lastIndex = 0;

    // We should actually test using !== null, but for foolproofness,
    //  we also reject empty strings
    while (key = pattern.exec(content)) {
      // Case-insensitivity
      key = key[0].toLowerCase();

      // Add to output buffer
      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));
      // The next line is the actual replacement method
      output.push(replacehandler(key, dictionary));

      // Update lastIndex variable
      lastIndex = pattern.lastIndex;

      // Don't match again by removing the matched word, create new pattern
      // patterns[patternHash[key]] = '^';
      // pattern = new RegExp(patterns.join('|'), 'gi');

      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop
      pattern.lastIndex = lastIndex;
    }
    output.push(content.substring(lastIndex, content.length));
    return output.join('');
  }
</script>

<!-- DIVI FORMATTING -->
<script>
  var diviDict = {
    "Esketamin": "esKETAmin",
    "Ketamin": "KETAmin",
    "Clonazepam": "clonazePAM",
    "Lorazepam": "LORazepam",
    "Pancuronium": "PANcuronium",
    "Rocuronium": "ROCuronium",
    "Vecuronium": "VECuronium",
    "Fentanyl": "fentaNYL",
    "Hydromorphon": "HYDROmorphon",
    "Oxycodon": "oxyCODON",
    "Piritramid": "PIRItramid",
    "Sufentanil": "SUFentanil",
    "Tramadol": "traMADol",
    "Dopamin": "DOPamin",
    "Ephedrin": "ePHEDrin",
    "Epinephrin": "EPINEPHrin",
    "Clonidin": "cloNIDin",
    "Dihydralazin": "dihydrALAZIN",
    "Nifedipin": "NIFEdipin",
    "Nimodipin": "niMODipin",
    "Bupivacain": "BUPIvacain",
    "Ropivacain": "ROPIvacain",
    "Physostigmin": "pHYSostigmin",
    "Pyridostigmin": "pYRIDostigmin",
    "Dimenhydrinat": "dimenhyDRINAT",
    "Dolasetron": "DOLAsetron",
    "Granisetron": "GRANIsetron",
    "Ondansetron": "ONDANsetron",
    "Tropisetron": "TROPIsetron",
    "Adenosin": "aDENOsin",
    "Ajmalin": "aJMALin",
    "Amiodaron": "aMIOdaron",
    "Levetiracetam": "levETIRAcetam",
    "Desmopressin": "desmoPRESSIN",
    "Dexamethason": "DEXAmethason",
    "Levothyroxin": "LEVOthyroxin",
    "Liothyronin": "LIOthyronin",
    "Methylprednisolon": "methylPREDNISolon",
    "Prednisolon": "prednisoLON",
    "Octreotid": "ocTREOtid",
    "Oxytocin": "OXYTOcin",
    "Dobutamin": "DOBUTamin",
    "Dopexamin": "dOPEXamin",
    "Cimetidin": "cIMEtidin",
    "Clemastin": "cLEMAstin",
    "Furosemid": "fUROsemid",
    "Glyceroltrinitrat": "<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>",
    "Metoclopramid": "<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>",
    "Acetylsalicylsäure": "<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>",
    "4-Dimethylaminophenol": "4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>",
    "Tranexamsäure": "Tranexam<small>säure</small>",
    "Valproinsäure": "Valproin<small>säure</small>",
    "Calciumchlorid": "Calcium<small>chlorid</small>",
    "Calciumgluconat": "Calcium<small>gluconat</small>",
    "Glyceroldihydrogen-Phosphat": "<small>Glyceroldihydrogen</small>-Phosphat",
    "Magnesiumasparat": "Magnesium<small>asparat</small>",
    "Magnesiumsulfat": "Magnesium<small>sulfat</small>",
    "Na-Hydrogencarbonat": "<small>Na</small>&#8209;Hydrogencarbonat",
    "Na-Thiosulfat": "<small>Na</small>&#8209;Thiosulfat",
    "Na-Phosphat": "<small>Na</small>&#8209;Phosphat",
    "Ca-Folinat": "<small>Ca</small>&#8209;FOLINAT",
    "Nitroprussid-Na": "Nitroprussid&#8209;<small>Na</small>"
  }

  if (formattingDIVI) {
    document.getElementById("container").innerHTML = replaceUsingDictionary(
      diviDict,
      document.getElementById("container").innerHTML,
      function (key, dictionary) {
        return dictionary[key];
      }
    );
  }
</script>


<!-- CONFOUNDER FORMATTING -->
<script>
  var confounderDict = {
    "atypisch": '<emu>a</emu>typisch',
    "Atypisch": '<emu>A</emu>typisch',
    "Antagonist": '<emu>Ant</emu>agonist',
    "hyper": 'hyp<emu>er</emu>',
    "Hyper": 'Hyp<emu>er</emu>',
    "hypo": 'hyp<emu>o</emu>',
    "Hypo": 'Hyp<emu>o</emu>',
    "inter": 'int<emu>er</emu>',
    "Inter": 'Int<emu>er</emu>',
    "intra": 'int<emu>ra</emu>',
    "Intra": 'int<emu>ra</emu>',
    "post": '<emu>post</emu>',
    "Post": '<emu>Post</emu>',
    "pre": '<emu>pre</emu>',
    "Pre": '<emu>Pre</emu>',
    "ab": '<emu>ab</emu>',
    "Ab": '<emu>Ab</emu>',
    "ad": '<emu>ad</emu>',
    "Ad": '<emu>Ad</emu>',
    "Insuffizienz": '<emu>In</emu>suffizienz',
  }

  if (formattingConfounders) {
    document.getElementById("container").innerHTML = replaceUsingDictionary(
      confounderDict,
      document.getElementById("container").innerHTML,
      function (key, dictionary) {
        return dictionary[key];
      }
    );
  }
</script>


<script>
  /**
   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.
   * Full credit to the original authors, except where modified or otherwise indicated.
   */

  /**
   *
   * We try to respect that people use various note types
   * which may do 'weird' stuff.
   * Elements may have event listeners that can be removed if we just innerHTML stuff
   * <i> may be styled 'i { display: block }', etc.
   *
   * Another problem that complicate the design of this script is that
   * a word may not be cleanly separated by html tags.
   * e.g. "A<i>long</i>word"
   *
   */

  (function () {
    /**
     * @param {String} text
     * @returns {number}
     */
    function getBoldLength(text) {
      return Math.floor(text.length / 2);
    }

    // Ignore node if any of the filters return true
    const excludeFilters = [
      (elem) => elem.tagName === "SCRIPT",
      (elem) => elem.tagName === "STYLE",
      (elem) => elem.classList.contains("cloze"),
    ];

    function newBoldElement(text) {
      const elem = document.createElement("strong");
      elem.innerText = text;
      return elem;
    }

    function indexOfWhitespace(text, startPos) {
      const whitespaces = [
        " ",
        "\n",
        "\t",
        " ",
        "&nbsp;",
        "‑",
        "-",
        "/",
        "(",
        ")",
      ];
      let nextPos = text.length;
      for (const whitespace of whitespaces) {
        const next = text.indexOf(whitespace, startPos);
        if (next !== -1 && next < nextPos) {
          nextPos = next;
        }
      }
      if (nextPos === text.length) {
        nextPos = -1;
      }
      return nextPos;
    }

    // Bolds a line of words
    class BionicReaderBolder {
      constructor(nodes) {
        this.nodes = nodes;
        this.startNodeIndex = 0;
        this.startPos = 0;
        this.replaceNodes = [];
        while (!this.isFinished()) {
          this.runWithinNode();
          this.runInterNode();
        }
      }

      static run(nodes) {
        new BionicReaderBolder(nodes);
      }

      isFinished() {
        return this.startNodeIndex === this.nodes.length;
      }

      replaceNode() {
        const node = this.nodes[this.startNodeIndex];
        const parent = node.parentNode;
        for (let add of this.replaceNodes) {
          parent.insertBefore(add, node);
        }
        parent.removeChild(node);
        this.replaceNodes = [];
      }

      runWithinNode() {
        const textContent = this.nodes[this.startNodeIndex].textContent;
        let nextPos = indexOfWhitespace(textContent, this.startPos);
        while (nextPos !== -1) {
          const word = textContent.substring(this.startPos, nextPos);
          const boldLength = getBoldLength(word);
          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));
          this.replaceNodes.push(
            document.createTextNode(
              word.substring(boldLength, nextPos) + textContent[nextPos]
            )
          );
          this.startPos = nextPos + 1;
          nextPos = indexOfWhitespace(textContent, this.startPos);
        }
      }

      // after this, startPos is likely to be at whitespace char
      runInterNode() {
        let word = "";
        let endNodeIndex = this.startNodeIndex;
        let endPos = this.startPos; // last word char pos + 1

        // Find word boundary
        while (endNodeIndex < this.nodes.length) {
          const textContent = this.nodes[endNodeIndex].textContent;
          let nextPos = indexOfWhitespace(textContent, endPos);
          if (nextPos === -1) {
            word += textContent.substring(endPos);
            endNodeIndex += 1;
            endPos = 0;
          } else {
            word += textContent.substring(endPos, nextPos);
            endPos = nextPos;
            break;
          }
        }
        // Calculate bold length
        let remainingBoldLength = getBoldLength(word);

        // Bold part of word
        while (remainingBoldLength > 0) {
          const textContent = this.nodes[this.startNodeIndex].textContent;
          if (remainingBoldLength > textContent.length - this.startPos) {
            const wordPart = textContent.substring(this.startPos);
            remainingBoldLength -= wordPart.length;
            this.replaceNodes.push(newBoldElement(wordPart));
            this.replaceNode();
            this.startNodeIndex += 1;
            this.startPos = 0;
          } else {
            const wordPart = textContent.substring(
              this.startPos,
              this.startPos + remainingBoldLength
            );
            this.startPos += remainingBoldLength;
            this.replaceNodes.push(newBoldElement(wordPart));
            remainingBoldLength -= wordPart.length;
          }
        }

        // Add non-bolded part of words
        while (this.startNodeIndex < endNodeIndex) {
          const textContent = this.nodes[this.startNodeIndex].textContent;
          const wordPart = textContent.substring(this.startPos);
          if (wordPart.length > 0) {
            this.replaceNodes.push(document.createTextNode(wordPart));
          }
          this.replaceNode();
          this.startNodeIndex += 1;
          this.startPos = 0;
        }

        if (this.startPos < endPos) {
          const textContent = this.nodes[this.startNodeIndex].textContent;
          const wordPart = textContent.substring(this.startPos, endPos);
          if (wordPart.length > 0) {
            this.replaceNodes.push(document.createTextNode(wordPart));
          }
          this.startPos = endPos;
        }
      }
    }

    /**
     * Builds a list of (list of nodes that makes up one non-line-broken line)
     * @param {Node} elem
     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.
     * @returns {void}
     */
    function forTextNodesInTree(elem, nodes, exclude = false) {
      const children = elem.childNodes;
      for (const filter of excludeFilters) {
        if (filter(elem)) {
          exclude = true;
          break;
        }
      }
      for (const child of children) {
        if (child.nodeType === Node.ELEMENT_NODE) {
          const style = window.getComputedStyle(child);
          if (
            child.tagName !== "BR" &&
            (style === "inline" || style === "inline-block")
          ) {
            forTextNodesInTree(child, nodes, exclude);
          } else {
            if (nodes[nodes.length - 1].length > 0) {
              nodes.push([]);
            }
            forTextNodesInTree(child, nodes, exclude);
          }
        } else if (
          !exclude &&
          child.nodeType === Node.TEXT_NODE &&
          child.textContent.length > 0
        ) {
          nodes[nodes.length - 1].push(child);
        }
      }
    }

    function makeBionic() {
      const cardContainer = document.getElementById("container");
      cardContainer.normalize();

      let nodesLines = [[]];
      forTextNodesInTree(cardContainer, nodesLines);
      for (const nodes of nodesLines) {
        BionicReaderBolder.run(nodes);
      }

      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(
        "<strong></strong>",
        ""
      );
      cardContainer.normalize();
    }

    let start = performance.now();
    if (bionicReading) {
      makeBionic();
    }
    let end = performance.now();
    console.log(`Initialized bionic reading: ${end - start}ms`);
  })();
</script>


<!-- table div wrapper -->
<script>
  for (let table of document.querySelectorAll("table")) {
    let tableDiv = document.createElement("div");
    tableDiv.style.overflowY = "scroll";
    table.parentNode.insertBefore(tableDiv, table);
    tableDiv.appendChild(table);
  };
</script>

<!-- MEDITRICKS SNIPPETS DATA -->
<div id="meditricks-mtsp-values" style="display:none;">
  <div id="meditricks-mtsp-nfname">_meditricks_nf_v1000_ankizin</div>
  <div id="meditricks-mtsp-nid">{{Note ID}}</div>
</div>
<script src="_meditricks_mtsp_scripts_v1000_ankizin.js"></script>
<link href="_meditricks_mtsp_styles_v1000_ankizin.css" rel="stylesheet" />

<!-- include "_meditricks_mtsp_nf_v1000_ankizin.js" -->
<!-- include "_meditricks_mtsp_scripts_v1000_iframe.map" -->
<!-- include "_meditricks_mtsp_mtlogo.webp" -->
<!-- include "_meditricks_mtsp_mt-loading.png" -->
<!-- include "_meditricks_mtsp_mt-loading_night.png" -->

<!-- //MEDITRICKS SNIPPETS DATA -->

<!-- ANKIMOBILE USER ACTIONS -->
<script>
  var userJs1 = undefined
  var userJs2 = undefined
  var userJs3 = undefined
  var userJs4 = undefined
  var userJs5 = undefined
  var userJs6 = undefined
  var userJs7 = undefined
  var userJs8 = undefined
</script>