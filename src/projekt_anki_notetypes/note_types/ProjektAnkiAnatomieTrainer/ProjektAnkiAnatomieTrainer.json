{
  "id": 1600000011,
  "name": "ProjektAnkiAnatomieTrainer",
  "type": 0,
  "mod": 1600000000,
  "usn": -1,
  "sortf": 0,
  "did": 1,
  "tmpls": [
    {
      "name": "Ursprung",
      "ord": 0,
      "qfmt": "<!-- version f0935e4 -->\n{{#Ursprung}}\n{{^UrsprungCloze1}}{{^UrsprungCloze2}}{{^UrsprungCloze3}}\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n<div id=\"cloze\" data-card=\"{{Card}}\"></div>\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TIMER CONFIG  ##############\n  // Timer config (timer length, timer finished message)\n  var minutes = 0\n  var seconds = 15\n  var timeOverMsg = \"<span style='color:#CC5B5B'>!!!</span>\"\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  // Auto flip to back when One by one mode.\n  var autoflip = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Wo liegt der <i>Ursprung</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\"></div>\n\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<script>\n  //DONT FADE BETWEEN CARDS\n  qFade = 0;\n  if (typeof anki !== 'undefined') anki.qFade = qFade;\n</script>\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    if (!indentation) { return; }\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- CLOZE ONE BY ONE FRONT -->\n<div id=\"one-by-one\" style=\"display: none;\"></div>\n\n<script>\n  /**\n   * Based on the AnKing Notetype, but expanded and modified by phyn.\n   * Credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  Persistence.clear();\n\n  // check if OneByOne is generally enabled for this card\n  var oneByOneFieldEmpty = selectiveOneByOne ? \"{{One by one}}\" === \"\" : true;\n  var clozeOneByOneEnabled = alwaysOneByOne ? true : !oneByOneFieldEmpty;\n\n  // avoid flickering. Must unset this in the back.\n  document.getElementById(\"qa\").style.display = \"none\";\n  var clozeHints = [];\n\n  if (clozeOneByOneEnabled) {\n    // collect hints from front side (independent of whether or not OneByOne is enabled)\n    document.getElementById(\"qa\").classList.add('one-by-one');\n    // Save cloze hints to display in the back\n    var clozes = document.getElementsByClassName(\"cloze\")\n    for (var i = 0; i < clozes.length; i++) {\n      clozes[i].classList.add(\"one-by-one\");\n      if (clozes[i].innerHTML === \"[...]\") {\n        clozeHints.push(\"\")\n      } else {\n        clozeHints.push(clozes[i].innerHTML)\n      }\n    }\n\n    // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n    /**\n     * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n     */\n    const getCardNumber = function () {\n      clz = document.body.className;\n      const regex = /card(\\d+)/gm;\n\n      let clz2;\n      try {\n        clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n      } catch (e) {\n        clz2 = \"\";\n      }\n      const regex2 = /.*?Cloze(\\d+)/gm;\n\n      let m;\n\n      if ((m = regex2.exec(clz2)) !== null) {\n        return m[1];\n      } else if ((m = regex.exec(clz)) !== null) {\n        return m[1];\n      } else {\n        // Should only fire if card is not cloze\n        console.error(\"Cannot find cardN class of body element!\");\n        return \"0\";\n      }\n    }\n\n    var alreadyRendered = false;\n\n    function processSelective1b1() {\n      if (alreadyRendered) return;\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (autoflip && clozeOneByOneEnabled) {\n        if (window.pycmd || window.showAnswer) {\n          // avoid flickering. Must unset this in the back.\n          document.getElementById(\"qa\").style.display = \"none\";\n        }\n        if (window.pycmd) {\n          pycmd(\"ans\")\n        } else if (window.showAnswer) {\n          showAnswer()\n        }\n      } else {\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n      }\n      // AnkiMobile JS API doesn't have one for show answer.\n      // Best alternative is to use Taps/Swipes to show answer.\n\n      alreadyRendered = true;\n    }\n\n    function delayedProcessSelective1b1() {\n      if (window.requestAnimationFrame) window.requestAnimationFrame(processSelective1b1); // less flickering\n      else window.setTimeout(processSelective1b1, 0);\n    };\n\n    window.onload = delayedProcessSelective1b1;\n    if (document.readyState === \"complete\") {\n      delayedProcessSelective1b1();\n    }\n    else {\n      document.addEventListener(\"DOMContentLoaded\", delayedProcessSelective1b1);\n    }\n\n    // Observe document.body class changes to trigger re-rendering.\n    // This is useful, because Anki doesn’t always start with an up-to-date class list:\n    // https://forums.ankiweb.net/t/card-card-classes-only-injected-separately-now/27387.\n    const observer = new MutationObserver(function (mutationsList, observer) {\n      for (let mutation of mutationsList) {\n        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {\n          delayedProcessSelective1b1();\n        }\n      }\n    });\n    observer.observe(document.body, { attributes: true });\n  }\n  Persistence.setItem(\"clozeHints\", clozeHints);\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>\n\n\n{{/UrsprungCloze3}}{{/UrsprungCloze2}}{{/UrsprungCloze1}}\n{{/Ursprung}}",
      "afmt": "<!-- version f0935e4 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n<div id=\"back\"></div>\n<div id=\"cloze\" data-card=\"{{Card}}\"></div>\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Eigene Notizen & Bilder\": \"Alt + 1\",\n    \"Eigene Prüfungsfragen\": \"Alt + 2\",\n    \"Definitionen\": \"Alt + 3\",\n    \"Merksprüche\": \"Alt + 4\",\n    \"Klinik\": \"Alt + 5\",\n    \"Präparat\": \"Alt + 6\",\n    \"Memes\": \"Alt + 7\",\n    \"linkContainer\": \"Alt + L\",\n    \"Meditricks\": \"Alt + M\",\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Eigene Notizen & Bilder\": false,\n    \"Eigene Prüfungsfragen\": false,\n    \"Definitionen\": false,\n    \"Merksprüche\": false,\n    \"Klinik\": false,\n    \"Präparat\": false,\n    \"Memes\": false,\n    \"linkContainer\": true,\n    \"Meditricks\": false,\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  var revealNextShortcut = \"N\"\n  var revealNextWordShortcut = \"Shift + N\"\n  var toggleAllShortcut = \",\"\n\n  // Enables revealing of next Cloze by simply clicking / tapping anywhere on the card (except the buttons)\n  var revealAnywhere = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // Changes how \"Reveal Next\" and clicking behaves. Either \"cloze\" or \"word\".\n  // \"word\" reveals word by word. \n  var revealNextClozeMode = \"cloze\"\n\n  // Changes how fields with additional information are displayed.\n  // true displays fields with additional information only if all clozes are revealed.\n  var hideAdditional = true;\n  var hideAdditionalButtons = true;\n\n  // What cloze is hidden with\n  var clozeHider = (elem) => \"[&nbsp;_&nbsp;]\"\n  /*\n  You can replace the above line with below examples. '█' or '_' works well for hiding clozes.\n  \n  // Fixed length:\n  var clozeHider = (elem) => \"███\"\n  // Replace each character with \"█\":\n  var clozeHider = (elem) => \"█\".repeat(elem.textContent.length)\n  // Show whitespaces:\n  var clozeHider = (elem) => \"[\" + elem.textContent.split(\" \").map((t) => \"█\".repeat(t.length)).join(\" \") + \"]\"\n  // Color-filled box (doesn't hide images):\n  var clozeHider = (elem) => `<span style=\"background-color: red; color: transparent;\">${elem.innerHTML}</span>`\n  */\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Wo liegt der <i>Ursprung</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div class=\"cloze\"><br>{{Ursprung}}</div>\n\n    <!-- ClOZE ONE BY ONE BUTTONS -->\n    <div id=\"onebyone-buttons\" class=\"onebyone\">\n      <br>\n      <button id=\"button-reveal-next\" class=\"button-general button-one-by-one\"\n        onclick=\"revealNextCloze(); event.stopPropagation()\">Reveal Next</button>\n      <button id=\"button-toggle-all\" class=\"button-general button-one-by-one\"\n        onclick=\"toggleAllCloze(); event.stopPropagation()\">Toggle All</button>\n    </div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- BUTTON FIELDS -->\n    {{#Eigene Notizen & Bilder}}\n    <span id=\"hint-zusatz\" class=\"hintBtn\" data-name=\"Eigene Notizen & Bilder\" style=\"display: none;\">\n      <button id=\"button-zusatz\" class=\"button-general\" onclick=\"toggleHintBtn('hint-zusatz'); event.stopPropagation()\">\n        <img src=\"__zusatz.svg\" style=\"height: 10px;\"> Eigene Notizen & Bilder\n      </button>\n      <div dir=\"auto\" id=\"zusatz\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Notizen & Bilder}}</div>\n    </span>\n    {{/Eigene Notizen & Bilder}}\n\n    {{#Eigene Prüfungsfragen}}\n    <span id=\"hint-hammer\" class=\"hintBtn\" data-name=\"Eigene Prüfungsfragen\" style=\"display: none;\">\n      <button id=\"button-hammer\" class=\"button-general\" onclick=\"toggleHintBtn('hint-hammer'); event.stopPropagation()\">\n        <img src=\"__hammer.svg\" style=\"height: 10px;\"> Eigene Prüfungsfragen\n      </button>\n      <div dir=\"auto\" id=\"hammer\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Prüfungsfragen}}</div>\n    </span>\n    {{/Eigene Prüfungsfragen}}\n\n    {{#Definitionen}}\n    <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Definitionen\" style=\"display: none;\">\n      <button id=\"button-definition\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Definitionen\n      </button>\n      <div dir=\"auto\" id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Definitionen}}</div>\n    </span>\n    {{/Definitionen}}\n\n    {{#Merksprüche}}\n    <span id=\"hint-merksprueche\" class=\"hintBtn\" data-name=\"Merksprüche\" style=\"display: none;\">\n      <button id=\"button-merksprueche\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-merksprueche'); event.stopPropagation()\">\n        <img src=\"__merkhilfe.svg\" style=\"height: 10px;\"> Merksprüche\n      </button>\n      <div dir=\"auto\" id=\"merksprueche\" class=\"hints\" style=\"display: none;\">{{edit:Merksprüche}}</div>\n    </span>\n    {{/Merksprüche}}\n\n    {{#Klinik}}\n    <span id=\"hint-klinik\" class=\"hintBtn\" data-name=\"Klinik\" style=\"display: none;\">\n      <button id=\"button-klinik\" class=\"button-general\" onclick=\"toggleHintBtn('hint-klinik'); event.stopPropagation()\">\n        <img src=\"__stethoscope.svg\" style=\"height: 10px;\"> Klinik\n      </button>\n      <div dir=\"auto\" id=\"klinik\" class=\"hints\" style=\"display: none;\">{{edit:Klinik}}</div>\n    </span>\n    {{/Klinik}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-praeparat\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n        </button>\n      </a>\n    </span>\n    {{/Präparat}}\n\n    {{#Virtuelle Mikroskopie}}\n    <span id=\"hint-microscope-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Virtuelle Mikroskopie}}\">\n        <button id=\"button-microscope\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Virtuelle Mikroskopie\n        </button>\n      </a>\n    </span>\n    {{/Virtuelle Mikroskopie}}\n\n    {{#Smart Zoom}}\n    <span id=\"hint-smartzoom-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-smartzoom\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Smart Zoom\n        </button>\n      </a>\n    </span>\n    {{/Smart Zoom}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat\" class=\"hintBtn\" data-name=\"Präparat\" style=\"display: none;\">\n      <button id=\"button-praeparat\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-praeparat'); event.stopPropagation()\">\n        <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n      </button>\n      <div dir=\"auto\" id=\"praeparat\" class=\"hints\" style=\"display: none;\">{{edit:Präparat}}</div>\n    </span>\n    {{/Präparat}}\n\n    {{#Memes}}\n    <span id=\"hint-memes\" class=\"hintBtn\" data-name=\"Memes\" style=\"display: none;\">\n      <button id=\"button-memes\" class=\"button-general\" onclick=\"toggleHintBtn('hint-memes'); event.stopPropagation()\">\n        <img src=\"__sonstiges.svg\" style=\"height: 10px;\"> Memes\n      </button>\n      <div dir=\"auto\" id=\"memes\" class=\"hints\" style=\"display: none;\">{{edit:Memes}}</div>\n    </span>\n    {{/Memes}}\n\n    <!-- LINEBREAKS IF BUTTONS EXIST -->\n    <script>\n      var array = [`{{Eigene Notizen & Bilder}}`, `{{Eigene Prüfungsfragen}}`, `{{Definitionen}}`, `{{Merksprüche}}`, `{{Klinik}}`, `{{Präparat}}`, `{{Memes}}`];\n      var anyistrue = (element) => element;\n      if (array.some(anyistrue)) {\n        document.getElementById(\"linebreaksIfButtons\").innerHTML = \"<br>\";\n      }\n    </script>\n    <div id=\"linebreaksIfButtons\"></div>\n\n    <!-- Extra field -->\n    {{#Extra}}\n    <div id=\"extra\" style=\"display: none;\">\n      <br>{{edit:Extra}}<br><br>\n    </div>\n    {{/Extra}}\n\n    <!-- Image field -->\n    {{#Bild}}\n    <div id=\"image\" style=\"display: none;\">\n      {{edit:Bild}}<br><br></div>\n    {{/Bild}}\n    {{^Bild}}\n    <span id=\"image\" style=\"display: none;\"></span>\n    {{/Bild}}\n    {{#Bild}}\n    <span id=\"hint-image\" style=\"display: none;\">\n      <button id=\"button-image\" class=\"button-general\"\n        onclick=\"var image = document.getElementById('image'); if (image.style.display == 'none') { image.style.display = 'block' } else { image.style.display = 'none' }; event.stopPropagation()\">\n        <img src=\"__image.svg\" style=\"height: 10px;\"> Abbildung\n      </button>\n    </span>\n    {{/Bild}}\n\n    <span id=\"hint-uafi\" class=\"hintBtn\" data-name=\"Ursprung, Ansatz, Verlauf, Funktion, Innervation, Äste\"\n      style=\"display: none;\">\n      <button id=\"button-uafi\" class=\"button-general expanded-button\"\n        onclick=\"toggleHintBtn('hint-uafi'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Weitere Informationen\n      </button>\n      <div id=\"uafi\" class=\"hints\" style=\"display: block;\">\n        <table class=\"uncloze\">\n          {{#Ursprung}}\n          <tr class=\"uafi-element\" id=\"Ursprung\">\n            <td><i>Ursprung</i></td>\n            <td>{{Ursprung}}</td>\n          </tr>\n          {{/Ursprung}}\n          {{#Ansatz}}\n          <tr class=\"uafi-element\" id=\"Ansatz\">\n            <td><i>Ansatz</i></td>\n            <td>{{Ansatz}}</td>\n          </tr>\n          {{/Ansatz}}\n          {{#Verlauf}}\n          <tr class=\"uafi-element\" id=\"Verlauf\">\n            <td><i>Verlauf</i></td>\n            <td>{{Verlauf}}</td>\n          </tr>\n          {{/Verlauf}}\n          {{#Funktion}}\n          <tr class=\"uafi-element\" id=\"Funktion\">\n            <td><i>Funktion</i></td>\n            <td>{{Funktion}}</td>\n          </tr>\n          {{/Funktion}}\n          {{#Innervation}}\n          <tr class=\"uafi-element\" id=\"Innervation\">\n            <td><i>Innervation</i></td>\n            <td>{{Innervation}}</td>\n          </tr>\n          {{/Innervation}}\n          {{#Äste}}\n          <tr class=\"uafi-element\" id=\"Äste\">\n            <td><i>Äste</i></td>\n            <td>{{Äste}}</td>\n          </tr>\n          {{/Äste}}\n        </table>\n      </div>\n\n      <script>\n        // iterate over all uafi-elements and hide only the one\n        // that is equal to the card's answer (i.e., value of {{Card}})\n        var uafiElements = document.getElementsByClassName(\"uafi-element\");\n        for (var i = 0; i < uafiElements.length; i++) {\n          if (((\"{{Card}}\").startsWith(uafiElements[i].id))) {\n            uafiElements[i].remove()\n          }\n        }\n      </script>\n    </span>\n\n    {{#AMBOSS-Link}}\n    <span id=\"hint-amboss\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:AMBOSS-Link}}\">\n        <button id=\"button-amboss\" class=\"button-general\">\n          <img src=\"__amboss.svg\" style=\"height: 10px;\"> AMBOSS&#8203;\n        </button>\n      </a>\n    </span>\n    {{/AMBOSS-Link}}\n\n    {{#Thieme via medici-Link}}\n    <span id=\"hint-thieme\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Thieme via medici-Link}}\">\n        <button id=\"button-thieme\" class=\"button-general\">\n          <img id=\"button-thieme-img\" src=\"__thieme-heart.svg\" style=\"height: 10px;\"> Thieme via medici\n        </button>\n      </a>\n    </span>\n    {{/Thieme via medici-Link}}\n\n    {{#Meditricks}}\n    <span id=\"hint-meditricks\" class=\"hintBtn\" data-name=\"Meditricks\" style=\"display: none;\">\n      <button id=\"button-meditricks\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-meditricks'); event.stopPropagation()\">\n        <img src=\"__meditricks.svg\" style=\"height: 10px;\"> Meditricks\n      </button>\n      <div dir=\"auto\" id=\"meditricks\" class=\"hints\" style=\"display: none;\">{{edit:Meditricks}}</div>\n    </span>\n    {{/Meditricks}}\n\n    {{#weitere Links}}\n    <span id=\"hint-linkcontainer\" class=\"hintBtn\" data-name=\"linkContainer\" style=\"display: none;\">\n      <button id=\"button-linkcontainer\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-linkcontainer'); event.stopPropagation()\">\n        <img src=\"__internet.svg\" style=\"height: 10px;\"> weitere Links\n      </button>\n      <div id=\"linkcontainer\" class=\"hints\" style=\"display: none;\"></div>\n      <span id=\"linkContainerLinks\" style=\"display: none;\">{{edit:weitere Links}}</span>\n    </span>\n    {{/weitere Links}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n  try {\n    for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n      href = link.href\n      text = link.innerText\n\n      const el = document.createElement('a');\n      el.setAttribute('href', link.href);\n\n      const btn = document.createElement('button');\n      btn.classList.add('button-general');\n      btn.classList.add('expanded-button');\n\n      domain = href.replace(/.+\\/\\/|(www|flexikon|register|de|next|com).|\\..+/g, '');\n      domainDict = {\n        \"amboss\": \"__amboss.svg\",\n        \"wikipedia\": \"__wikipedia.svg\",\n        \"doccheck\": \"__doccheck.png\",\n        \"notfallguru\": \"__notfallguru.svg\",\n        \"awmf\": \"__awmf.svg\",\n        \"gelbe-liste\": \"__gelbe-liste.png\",\n        \"embryotox\": \"__embryotox.svg\",\n        \"radiopaedia\": \"__radiopaedia.png\",\n        \"orphanet\": \"__orphanet.png\",\n      }\n      if (domain in domainDict) {\n        icon = domainDict[domain]\n      } else {\n        icon = \"__internet.svg\"\n      }\n\n      const img = document.createElement('img');\n      img.setAttribute('src', icon);\n      img.setAttribute('style', 'height: 10px;');\n\n      btn.appendChild(img);\n      btn.innerHTML = btn.innerHTML + \" \" + text;\n\n      el.appendChild(btn);\n\n      document.getElementById(\"linkcontainer\").appendChild(el)\n    }\n  }\n  catch (err) {\n    console.log(err)\n  }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-uafi\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- AUTOFLIP BACK SCRIPT -->\n<script>\n  // autoflip hides card in front template\n  document.getElementById(\"qa\").style.removeProperty(\"display\")\n</script>\n\n<!-- CLOZE ONE BY ONE SCRIPT -->\n<style>\n  .cloze-replacer:hover {\n    cursor: pointer;\n  }\n\n  .cloze-hidden {\n    display: none;\n  }\n\n  .cloze-replacer .hidden {\n    display: none;\n  }\n\n  #extra.hidden {\n    display: none;\n  }\n</style>\n\n<!--\n Based on the AnKing Notetype, but expanded and modified by phyn.\n Credit to the original authors, except where modified or otherwise indicated.\n-->\n\n<script>\n    (function () {\n      // enables cloze one-by-one even when one-by-one field is empty\n      // minNumberOfClozes is still considered in this case\n      // overridden in importance by selectiveOneByOne\n      var clozeOneByOneEnabled = true;\n\n      // remove the clickAnywhere function from global scope\n      document.documentElement.removeAttribute(\"onclick\")\n\n      // --- CHECK IF ONE BY ONE IS GENERALLY ENABLED FOR THIS NOTE ---\n      var oneByOneFieldNotEmpty = \"{{One by one}}\" !== \"\";\n      try {\n        clozeOneByOneEnabled = alwaysOneByOne || oneByOneFieldNotEmpty;\n      } catch (exception) {\n        console.log(exception)\n      }\n\n      /**\n   * helper functions to show / hide fields containing additional information\n   */\n      const showExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const hideExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const buttonIds = [\n        \"hint-zusatz\",\n        \"hint-definition\",\n        \"hint-hammer\",\n        \"hint-klinik\",\n        \"hint-praeparat\",\n        \"hint-microscope\",\n        \"hint-smartzoom\",\n        \"hint-histotrainer\",\n        \"hint-uafi\",\n        \"hint-merksprueche\",\n        \"hint-memes\",\n        \"hint-image\",\n        \"hint-amboss\",\n        \"hint-thieme\",\n        \"hint-meditricks\",\n        \"hint-linkcontainer\",\n      ];\n\n      const showExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document\n              .getElementById(buttonIds[button])\n              .style.removeProperty(\"display\");\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n      const hideExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document.getElementById(buttonIds[button]).style.display = \"none\";\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n\n      // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n      /**\n       * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n       */\n      const getCardNumber = function () {\n        clz = document.body.className;\n        const regex = /card(\\d+)/gm;\n\n        let clz2;\n        try {\n          clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n        } catch (e) {\n          clz2 = \"\";\n        }\n        const regex2 = /.*?Cloze(\\d+)/gm;\n\n        let m;\n\n        if ((m = regex2.exec(clz2)) !== null) {\n          return m[1];\n        } else if ((m = regex.exec(clz)) !== null) {\n          return m[1];\n        } else {\n          // Should only fire if card is not cloze\n          console.error(\"Cannot find cardN class of body element!\");\n          return \"0\";\n        }\n      }\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (!clozeOneByOneEnabled) {\n        showExtra()\n        showExtraButtons()\n        document.getElementById(\"onebyone-buttons\").style.display = \"none\"\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n        return\n      }\n\n      // Needed for amboss to recognize first word in .cloze-hidden\n      const CLOZE_REPLACER_SEP = \"<span class='hidden'> </span>\"\n\n      const hideAllCloze = function (initial) {\n        let clozes = document.getElementsByClassName(\"cloze\")\n        let count = 0 // hidden cloze count\n        for (const cloze of clozes) {\n          const existingHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n          if (existingHidden) {\n            revealCloze(cloze);\n          }\n          if (cloze.offsetWidth === 0) {\n            continue\n          }\n          const clozeReplacer = document.createElement(\"span\")\n          const clozeHidden = document.createElement(\"span\")\n          clozeReplacer.classList.add(\"cloze-replacer\")\n          clozeHidden.classList.add(\"cloze-hidden\")\n          while (cloze.childNodes.length > 0) {\n            clozeHidden.appendChild(cloze.childNodes[0])\n          }\n          cloze.appendChild(clozeReplacer)\n          cloze.appendChild(clozeHidden)\n\n          var clozeHints = Persistence.getItem(\"clozeHints\");\n          if (clozeHints && clozeHints[count]) {\n            clozeReplacer.classList.add(\"cloze-hint\")\n            clozeReplacer.innerHTML = clozeHints[count] + CLOZE_REPLACER_SEP\n          } else {\n            clozeReplacer.innerHTML = clozeHider(cloze) + CLOZE_REPLACER_SEP\n          }\n          count += 1\n          document.getElementById(\"button-reveal-next\").style.display = \"inline-block\";\n          if (initial) {\n            cloze.addEventListener(\"touchend\", revealClozeClicked)\n            cloze.addEventListener(\"click\", revealClozeClicked)\n            cloze.classList.add(\"one-by-one\");\n          }\n        }\n\n        // Hide #extra until all clozes are shown\n        const extra = document.getElementById(\"extra\");\n        if (extra) {\n          extra.classList.add(\"hidden\");\n        }\n\n        hideExtra();\n        hideExtraButtons();\n        if (revealAnywhere) {\n          document.documentElement.setAttribute(\"onclick\", \"revealNextCloze(); event.stopPropagation()\")\n        }\n\n\n        // Also hide autoReveal fields\n        for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n          const container = document.querySelector(`[data-name=\"${field}\"]`)\n          if (container) {\n            const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n            if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n              // const link = container.getElementsByTagName(\"a\")[0]\n              const button = container.getElementsByTagName(\"button\")[0]\n              const hint = container.getElementsByTagName(\"div\")[0]\n              button.classList.remove(\"expanded-button\")\n              hint.style.display = \"none\"\n              // link.style.display = \"\"\n            }\n          }\n        }\n      }\n\n      const revealCloze = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        cloze.removeChild(clozeReplacer)\n        cloze.removeChild(clozeHidden)\n        while (clozeHidden.childNodes.length > 0) {\n          cloze.appendChild(clozeHidden.childNodes[0])\n        }\n        maybeRevealExtraField()\n      }\n\n      const revealClozeWord = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        let range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundSpace = setRangeEnd(range, clozeHidden, \"beforeFirstSpace\")\n        if (!foundSpace) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        let fragment = range.extractContents()\n        cloze.insertBefore(fragment, clozeReplacer)\n        // Extract whitespaces after word\n        range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundWord = setRangeEnd(range, clozeHidden, \"beforeFirstChar\")\n        if (!foundWord) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        fragment = range.extractContents();\n        cloze.insertBefore(fragment, clozeReplacer)\n        if (!foundWord) {\n          cloze.removeChild(clozeHidden)\n          cloze.removeChild(clozeReplacer)\n          maybeRevealExtraField()\n          return\n        }\n        clozeReplacer.innerHTML = clozeHider(clozeHidden) + CLOZE_REPLACER_SEP\n        if (clozeReplacer.classList.contains(\"cloze-hint\")) [\n          clozeReplacer.classList.remove(\"cloze-hint\")\n        ]\n        maybeRevealExtraField()\n      }\n\n      const revealNextClozeOf = (type) => {\n        const nextHidden = document.querySelectorAll(\".cloze-hidden\")\n        const nextNextHidden = nextHidden.length > 1 ? true : false\n        if (!nextNextHidden) {\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\";\n        }\n        if (!nextHidden) {\n          return\n        }\n        const cloze = clozeElOfClozeHidden(nextHidden[0]);\n        if (type === \"word\") {\n          revealClozeWord(cloze)\n        } else if (type === \"cloze\") {\n          revealCloze(cloze)\n        } else {\n          console.error(\"Invalid type: \" + type)\n        }\n      }\n\n      const revealClozeClicked = function (ev) {\n        let elem = ev.currentTarget\n        if (!ev.altKey && (revealNextClozeMode !== \"word\")) {\n          revealCloze(elem)\n        } else {\n          revealClozeWord(elem)\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      }\n\n      window.revealNextCloze = function () {\n        revealNextClozeOf(revealNextClozeMode)\n      }\n\n      window.toggleAllCloze = function () {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length > 0) {\n          for (const elem of elems) {\n            const cloze = clozeElOfClozeHidden(elem)\n            revealCloze(cloze)\n          }\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\"\n        } else {\n          hideAllCloze(initial = false)\n        }\n      }\n\n      const clozeElOfClozeHidden = (cloze) => {\n        while (!cloze.classList.contains(\"cloze\")) {\n          cloze = cloze.parentElement;\n        }\n        return cloze;\n      }\n\n      const maybeRevealExtraField = () => {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length == 0) {\n          const extra = document.getElementById(\"extra\")\n          if (extra) {\n            extra.classList.remove(\"hidden\")\n          }\n\n          showExtra();\n          showExtraButtons();\n          document.documentElement.removeAttribute(\"onclick\")\n\n          // Also reveal autoReveal fields\n          for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n            const container = document.querySelector(`[data-name=\"${field}\"]`)\n            if (container) {\n              const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n              if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n                // const link = container.getElementsByTagName(\"a\")[0]\n                const button = container.getElementsByTagName(\"button\")[0]\n                const hint = container.getElementsByTagName(\"div\")[0]\n                button.classList.add(\"expanded-button\")\n                hint.style.display = \"block\"\n                // link.style.display = \"none\"\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * mode: 'beforeFirstSpace' or 'beforeFirstChar'\n       * Return `true` if it exists and setEnd() was called, otherwise `false`\n       */\n      const setRangeEnd = function (range, node, mode) {\n        if (node.nodeType === Node.TEXT_NODE) {\n          const regex = mode === 'beforeFirstSpace' ? /\\s/ : /\\S/\n          const match = node.textContent.match(regex)\n          if (match) {\n            if (match.index === 0) {\n              while (node.previousSibling === null) {\n                node = node.parentElement\n              }\n              range.setEndBefore(node)\n            } else {\n              range.setEnd(node, match.index);\n            }\n            return true;\n          } else {\n            return false;\n          }\n        } else if (mode === 'beforeFirstChar' && isCharNode(node)) {\n          range.setEndBefore(node)\n          return true\n        } else if (!ignoreSpaceInNode(node)) {\n          for (const child of node.childNodes) {\n            if (setRangeEnd(range, child, mode)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }\n\n      const ignoreSpaceInNode = function (node) {\n        return node.tagName === \"MJX-ASSISTIVE-MML\"\n      }\n\n      const isCharNode = function (node) {\n        return [\"IMG\", \"MJX-CONTAINER\"].includes(node.tagName)\n      }\n\n      hideAllCloze(initial = true)\n\n      let isShowNextShortcut = shortcutMatcher(window.revealNextShortcut)\n      let isShowWordShortcut = shortcutMatcher(window.revealNextWordShortcut)\n      let isToggleAllShortcut = shortcutMatcher(window.toggleAllShortcut)\n      ankingAddEventListener(\"keydown\", (ev) => {\n        let next = isShowNextShortcut(ev)\n        let word = isShowWordShortcut(ev)\n        let all = isToggleAllShortcut(ev)\n        if (next) {\n          revealNextClozeOf(\"cloze\")\n        } else if (word) {\n          revealNextClozeOf(\"word\")\n        } else if (all) {\n          toggleAllCloze()\n        } else {\n          return;\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      });\n    })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- MEDITRICKS SNIPPETS DATA -->\n<div id=\"meditricks-mtsp-values\" style=\"display:none;\">\n  <div id=\"meditricks-mtsp-nfname\">_meditricks_nf_v1000_ankizin</div>\n  <div id=\"meditricks-mtsp-nid\">{{Note ID}}</div>\n</div>\n<script src=\"_meditricks_mtsp_scripts_v1000_ankizin.js\"></script>\n<link href=\"_meditricks_mtsp_styles_v1000_ankizin.css\" rel=\"stylesheet\" />\n\n<!-- include \"_meditricks_mtsp_nf_v1000_ankizin.js\" -->\n<!-- include \"_meditricks_mtsp_scripts_v1000_iframe.map\" -->\n<!-- include \"_meditricks_mtsp_mtlogo.webp\" -->\n<!-- include \"_meditricks_mtsp_mt-loading.png\" -->\n<!-- include \"_meditricks_mtsp_mt-loading_night.png\" -->\n\n<!-- //MEDITRICKS SNIPPETS DATA -->\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>",
      "bqfmt": "{{Muskel / Leitungsbahn}}",
      "bafmt": "{{Ursprung}}",
      "did": null,
      "bfont": "Helvetica",
      "bsize": 12
    },
    {
      "name": "Ansatz",
      "ord": 1,
      "qfmt": "<!-- version f0935e4 -->\n{{#Ansatz}}\n{{^AnsatzCloze1}}{{^AnsatzCloze2}}{{^AnsatzCloze3}}\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n<div id=\"cloze\" data-card=\"{{Card}}\"></div>\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TIMER CONFIG  ##############\n  // Timer config (timer length, timer finished message)\n  var minutes = 0\n  var seconds = 15\n  var timeOverMsg = \"<span style='color:#CC5B5B'>!!!</span>\"\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  // Auto flip to back when One by one mode.\n  var autoflip = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Wo liegt der <i>Ansatz</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\"></div>\n\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<script>\n  //DONT FADE BETWEEN CARDS\n  qFade = 0;\n  if (typeof anki !== 'undefined') anki.qFade = qFade;\n</script>\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    if (!indentation) { return; }\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- CLOZE ONE BY ONE FRONT -->\n<div id=\"one-by-one\" style=\"display: none;\"></div>\n\n<script>\n  /**\n   * Based on the AnKing Notetype, but expanded and modified by phyn.\n   * Credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  Persistence.clear();\n\n  // check if OneByOne is generally enabled for this card\n  var oneByOneFieldEmpty = selectiveOneByOne ? \"{{One by one}}\" === \"\" : true;\n  var clozeOneByOneEnabled = alwaysOneByOne ? true : !oneByOneFieldEmpty;\n\n  // avoid flickering. Must unset this in the back.\n  document.getElementById(\"qa\").style.display = \"none\";\n  var clozeHints = [];\n\n  if (clozeOneByOneEnabled) {\n    // collect hints from front side (independent of whether or not OneByOne is enabled)\n    document.getElementById(\"qa\").classList.add('one-by-one');\n    // Save cloze hints to display in the back\n    var clozes = document.getElementsByClassName(\"cloze\")\n    for (var i = 0; i < clozes.length; i++) {\n      clozes[i].classList.add(\"one-by-one\");\n      if (clozes[i].innerHTML === \"[...]\") {\n        clozeHints.push(\"\")\n      } else {\n        clozeHints.push(clozes[i].innerHTML)\n      }\n    }\n\n    // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n    /**\n     * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n     */\n    const getCardNumber = function () {\n      clz = document.body.className;\n      const regex = /card(\\d+)/gm;\n\n      let clz2;\n      try {\n        clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n      } catch (e) {\n        clz2 = \"\";\n      }\n      const regex2 = /.*?Cloze(\\d+)/gm;\n\n      let m;\n\n      if ((m = regex2.exec(clz2)) !== null) {\n        return m[1];\n      } else if ((m = regex.exec(clz)) !== null) {\n        return m[1];\n      } else {\n        // Should only fire if card is not cloze\n        console.error(\"Cannot find cardN class of body element!\");\n        return \"0\";\n      }\n    }\n\n    var alreadyRendered = false;\n\n    function processSelective1b1() {\n      if (alreadyRendered) return;\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (autoflip && clozeOneByOneEnabled) {\n        if (window.pycmd || window.showAnswer) {\n          // avoid flickering. Must unset this in the back.\n          document.getElementById(\"qa\").style.display = \"none\";\n        }\n        if (window.pycmd) {\n          pycmd(\"ans\")\n        } else if (window.showAnswer) {\n          showAnswer()\n        }\n      } else {\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n      }\n      // AnkiMobile JS API doesn't have one for show answer.\n      // Best alternative is to use Taps/Swipes to show answer.\n\n      alreadyRendered = true;\n    }\n\n    function delayedProcessSelective1b1() {\n      if (window.requestAnimationFrame) window.requestAnimationFrame(processSelective1b1); // less flickering\n      else window.setTimeout(processSelective1b1, 0);\n    };\n\n    window.onload = delayedProcessSelective1b1;\n    if (document.readyState === \"complete\") {\n      delayedProcessSelective1b1();\n    }\n    else {\n      document.addEventListener(\"DOMContentLoaded\", delayedProcessSelective1b1);\n    }\n\n    // Observe document.body class changes to trigger re-rendering.\n    // This is useful, because Anki doesn’t always start with an up-to-date class list:\n    // https://forums.ankiweb.net/t/card-card-classes-only-injected-separately-now/27387.\n    const observer = new MutationObserver(function (mutationsList, observer) {\n      for (let mutation of mutationsList) {\n        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {\n          delayedProcessSelective1b1();\n        }\n      }\n    });\n    observer.observe(document.body, { attributes: true });\n  }\n  Persistence.setItem(\"clozeHints\", clozeHints);\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>\n\n\n{{/AnsatzCloze3}}{{/AnsatzCloze2}}{{/AnsatzCloze1}}\n{{/Ansatz}}",
      "afmt": "<!-- version f0935e4 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n<div id=\"back\"></div>\n<div id=\"cloze\" data-card=\"{{Card}}\"></div>\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Eigene Notizen & Bilder\": \"Alt + 1\",\n    \"Eigene Prüfungsfragen\": \"Alt + 2\",\n    \"Definitionen\": \"Alt + 3\",\n    \"Merksprüche\": \"Alt + 4\",\n    \"Klinik\": \"Alt + 5\",\n    \"Präparat\": \"Alt + 6\",\n    \"Memes\": \"Alt + 7\",\n    \"linkContainer\": \"Alt + L\",\n    \"Meditricks\": \"Alt + M\",\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Eigene Notizen & Bilder\": false,\n    \"Eigene Prüfungsfragen\": false,\n    \"Definitionen\": false,\n    \"Merksprüche\": false,\n    \"Klinik\": false,\n    \"Präparat\": false,\n    \"Memes\": false,\n    \"linkContainer\": true,\n    \"Meditricks\": false,\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  var revealNextShortcut = \"N\"\n  var revealNextWordShortcut = \"Shift + N\"\n  var toggleAllShortcut = \",\"\n\n  // Enables revealing of next Cloze by simply clicking / tapping anywhere on the card (except the buttons)\n  var revealAnywhere = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // Changes how \"Reveal Next\" and clicking behaves. Either \"cloze\" or \"word\".\n  // \"word\" reveals word by word. \n  var revealNextClozeMode = \"cloze\"\n\n  // Changes how fields with additional information are displayed.\n  // true displays fields with additional information only if all clozes are revealed.\n  var hideAdditional = true;\n  var hideAdditionalButtons = true;\n\n  // What cloze is hidden with\n  var clozeHider = (elem) => \"[&nbsp;_&nbsp;]\"\n  /*\n  You can replace the above line with below examples. '█' or '_' works well for hiding clozes.\n  \n  // Fixed length:\n  var clozeHider = (elem) => \"███\"\n  // Replace each character with \"█\":\n  var clozeHider = (elem) => \"█\".repeat(elem.textContent.length)\n  // Show whitespaces:\n  var clozeHider = (elem) => \"[\" + elem.textContent.split(\" \").map((t) => \"█\".repeat(t.length)).join(\" \") + \"]\"\n  // Color-filled box (doesn't hide images):\n  var clozeHider = (elem) => `<span style=\"background-color: red; color: transparent;\">${elem.innerHTML}</span>`\n  */\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Wo liegt der <i>Ansatz</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div class=\"cloze\"><br>{{Ansatz}}</div>\n\n    <!-- ClOZE ONE BY ONE BUTTONS -->\n    <div id=\"onebyone-buttons\" class=\"onebyone\">\n      <br>\n      <button id=\"button-reveal-next\" class=\"button-general button-one-by-one\"\n        onclick=\"revealNextCloze(); event.stopPropagation()\">Reveal Next</button>\n      <button id=\"button-toggle-all\" class=\"button-general button-one-by-one\"\n        onclick=\"toggleAllCloze(); event.stopPropagation()\">Toggle All</button>\n    </div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- BUTTON FIELDS -->\n    {{#Eigene Notizen & Bilder}}\n    <span id=\"hint-zusatz\" class=\"hintBtn\" data-name=\"Eigene Notizen & Bilder\" style=\"display: none;\">\n      <button id=\"button-zusatz\" class=\"button-general\" onclick=\"toggleHintBtn('hint-zusatz'); event.stopPropagation()\">\n        <img src=\"__zusatz.svg\" style=\"height: 10px;\"> Eigene Notizen & Bilder\n      </button>\n      <div dir=\"auto\" id=\"zusatz\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Notizen & Bilder}}</div>\n    </span>\n    {{/Eigene Notizen & Bilder}}\n\n    {{#Eigene Prüfungsfragen}}\n    <span id=\"hint-hammer\" class=\"hintBtn\" data-name=\"Eigene Prüfungsfragen\" style=\"display: none;\">\n      <button id=\"button-hammer\" class=\"button-general\" onclick=\"toggleHintBtn('hint-hammer'); event.stopPropagation()\">\n        <img src=\"__hammer.svg\" style=\"height: 10px;\"> Eigene Prüfungsfragen\n      </button>\n      <div dir=\"auto\" id=\"hammer\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Prüfungsfragen}}</div>\n    </span>\n    {{/Eigene Prüfungsfragen}}\n\n    {{#Definitionen}}\n    <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Definitionen\" style=\"display: none;\">\n      <button id=\"button-definition\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Definitionen\n      </button>\n      <div dir=\"auto\" id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Definitionen}}</div>\n    </span>\n    {{/Definitionen}}\n\n    {{#Merksprüche}}\n    <span id=\"hint-merksprueche\" class=\"hintBtn\" data-name=\"Merksprüche\" style=\"display: none;\">\n      <button id=\"button-merksprueche\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-merksprueche'); event.stopPropagation()\">\n        <img src=\"__merkhilfe.svg\" style=\"height: 10px;\"> Merksprüche\n      </button>\n      <div dir=\"auto\" id=\"merksprueche\" class=\"hints\" style=\"display: none;\">{{edit:Merksprüche}}</div>\n    </span>\n    {{/Merksprüche}}\n\n    {{#Klinik}}\n    <span id=\"hint-klinik\" class=\"hintBtn\" data-name=\"Klinik\" style=\"display: none;\">\n      <button id=\"button-klinik\" class=\"button-general\" onclick=\"toggleHintBtn('hint-klinik'); event.stopPropagation()\">\n        <img src=\"__stethoscope.svg\" style=\"height: 10px;\"> Klinik\n      </button>\n      <div dir=\"auto\" id=\"klinik\" class=\"hints\" style=\"display: none;\">{{edit:Klinik}}</div>\n    </span>\n    {{/Klinik}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-praeparat\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n        </button>\n      </a>\n    </span>\n    {{/Präparat}}\n\n    {{#Virtuelle Mikroskopie}}\n    <span id=\"hint-microscope-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Virtuelle Mikroskopie}}\">\n        <button id=\"button-microscope\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Virtuelle Mikroskopie\n        </button>\n      </a>\n    </span>\n    {{/Virtuelle Mikroskopie}}\n\n    {{#Smart Zoom}}\n    <span id=\"hint-smartzoom-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-smartzoom\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Smart Zoom\n        </button>\n      </a>\n    </span>\n    {{/Smart Zoom}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat\" class=\"hintBtn\" data-name=\"Präparat\" style=\"display: none;\">\n      <button id=\"button-praeparat\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-praeparat'); event.stopPropagation()\">\n        <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n      </button>\n      <div dir=\"auto\" id=\"praeparat\" class=\"hints\" style=\"display: none;\">{{edit:Präparat}}</div>\n    </span>\n    {{/Präparat}}\n\n    {{#Memes}}\n    <span id=\"hint-memes\" class=\"hintBtn\" data-name=\"Memes\" style=\"display: none;\">\n      <button id=\"button-memes\" class=\"button-general\" onclick=\"toggleHintBtn('hint-memes'); event.stopPropagation()\">\n        <img src=\"__sonstiges.svg\" style=\"height: 10px;\"> Memes\n      </button>\n      <div dir=\"auto\" id=\"memes\" class=\"hints\" style=\"display: none;\">{{edit:Memes}}</div>\n    </span>\n    {{/Memes}}\n\n    <!-- LINEBREAKS IF BUTTONS EXIST -->\n    <script>\n      var array = [`{{Eigene Notizen & Bilder}}`, `{{Eigene Prüfungsfragen}}`, `{{Definitionen}}`, `{{Merksprüche}}`, `{{Klinik}}`, `{{Präparat}}`, `{{Memes}}`];\n      var anyistrue = (element) => element;\n      if (array.some(anyistrue)) {\n        document.getElementById(\"linebreaksIfButtons\").innerHTML = \"<br>\";\n      }\n    </script>\n    <div id=\"linebreaksIfButtons\"></div>\n\n    <!-- Extra field -->\n    {{#Extra}}\n    <div id=\"extra\" style=\"display: none;\">\n      <br>{{edit:Extra}}<br><br>\n    </div>\n    {{/Extra}}\n\n    <!-- Image field -->\n    {{#Bild}}\n    <div id=\"image\" style=\"display: none;\">\n      {{edit:Bild}}<br><br></div>\n    {{/Bild}}\n    {{^Bild}}\n    <span id=\"image\" style=\"display: none;\"></span>\n    {{/Bild}}\n    {{#Bild}}\n    <span id=\"hint-image\" style=\"display: none;\">\n      <button id=\"button-image\" class=\"button-general\"\n        onclick=\"var image = document.getElementById('image'); if (image.style.display == 'none') { image.style.display = 'block' } else { image.style.display = 'none' }; event.stopPropagation()\">\n        <img src=\"__image.svg\" style=\"height: 10px;\"> Abbildung\n      </button>\n    </span>\n    {{/Bild}}\n\n    <span id=\"hint-uafi\" class=\"hintBtn\" data-name=\"Ursprung, Ansatz, Verlauf, Funktion, Innervation, Äste\"\n      style=\"display: none;\">\n      <button id=\"button-uafi\" class=\"button-general expanded-button\"\n        onclick=\"toggleHintBtn('hint-uafi'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Weitere Informationen\n      </button>\n      <div id=\"uafi\" class=\"hints\" style=\"display: block;\">\n        <table class=\"uncloze\">\n          {{#Ursprung}}\n          <tr class=\"uafi-element\" id=\"Ursprung\">\n            <td><i>Ursprung</i></td>\n            <td>{{Ursprung}}</td>\n          </tr>\n          {{/Ursprung}}\n          {{#Ansatz}}\n          <tr class=\"uafi-element\" id=\"Ansatz\">\n            <td><i>Ansatz</i></td>\n            <td>{{Ansatz}}</td>\n          </tr>\n          {{/Ansatz}}\n          {{#Verlauf}}\n          <tr class=\"uafi-element\" id=\"Verlauf\">\n            <td><i>Verlauf</i></td>\n            <td>{{Verlauf}}</td>\n          </tr>\n          {{/Verlauf}}\n          {{#Funktion}}\n          <tr class=\"uafi-element\" id=\"Funktion\">\n            <td><i>Funktion</i></td>\n            <td>{{Funktion}}</td>\n          </tr>\n          {{/Funktion}}\n          {{#Innervation}}\n          <tr class=\"uafi-element\" id=\"Innervation\">\n            <td><i>Innervation</i></td>\n            <td>{{Innervation}}</td>\n          </tr>\n          {{/Innervation}}\n          {{#Äste}}\n          <tr class=\"uafi-element\" id=\"Äste\">\n            <td><i>Äste</i></td>\n            <td>{{Äste}}</td>\n          </tr>\n          {{/Äste}}\n        </table>\n      </div>\n\n      <script>\n        // iterate over all uafi-elements and hide only the one\n        // that is equal to the card's answer (i.e., value of {{Card}})\n        var uafiElements = document.getElementsByClassName(\"uafi-element\");\n        for (var i = 0; i < uafiElements.length; i++) {\n          if (((\"{{Card}}\").startsWith(uafiElements[i].id))) {\n            uafiElements[i].remove()\n          }\n        }\n      </script>\n    </span>\n\n    {{#AMBOSS-Link}}\n    <span id=\"hint-amboss\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:AMBOSS-Link}}\">\n        <button id=\"button-amboss\" class=\"button-general\">\n          <img src=\"__amboss.svg\" style=\"height: 10px;\"> AMBOSS&#8203;\n        </button>\n      </a>\n    </span>\n    {{/AMBOSS-Link}}\n\n    {{#Thieme via medici-Link}}\n    <span id=\"hint-thieme\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Thieme via medici-Link}}\">\n        <button id=\"button-thieme\" class=\"button-general\">\n          <img id=\"button-thieme-img\" src=\"__thieme-heart.svg\" style=\"height: 10px;\"> Thieme via medici\n        </button>\n      </a>\n    </span>\n    {{/Thieme via medici-Link}}\n\n    {{#Meditricks}}\n    <span id=\"hint-meditricks\" class=\"hintBtn\" data-name=\"Meditricks\" style=\"display: none;\">\n      <button id=\"button-meditricks\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-meditricks'); event.stopPropagation()\">\n        <img src=\"__meditricks.svg\" style=\"height: 10px;\"> Meditricks\n      </button>\n      <div dir=\"auto\" id=\"meditricks\" class=\"hints\" style=\"display: none;\">{{edit:Meditricks}}</div>\n    </span>\n    {{/Meditricks}}\n\n    {{#weitere Links}}\n    <span id=\"hint-linkcontainer\" class=\"hintBtn\" data-name=\"linkContainer\" style=\"display: none;\">\n      <button id=\"button-linkcontainer\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-linkcontainer'); event.stopPropagation()\">\n        <img src=\"__internet.svg\" style=\"height: 10px;\"> weitere Links\n      </button>\n      <div id=\"linkcontainer\" class=\"hints\" style=\"display: none;\"></div>\n      <span id=\"linkContainerLinks\" style=\"display: none;\">{{edit:weitere Links}}</span>\n    </span>\n    {{/weitere Links}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n  try {\n    for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n      href = link.href\n      text = link.innerText\n\n      const el = document.createElement('a');\n      el.setAttribute('href', link.href);\n\n      const btn = document.createElement('button');\n      btn.classList.add('button-general');\n      btn.classList.add('expanded-button');\n\n      domain = href.replace(/.+\\/\\/|(www|flexikon|register|de|next|com).|\\..+/g, '');\n      domainDict = {\n        \"amboss\": \"__amboss.svg\",\n        \"wikipedia\": \"__wikipedia.svg\",\n        \"doccheck\": \"__doccheck.png\",\n        \"notfallguru\": \"__notfallguru.svg\",\n        \"awmf\": \"__awmf.svg\",\n        \"gelbe-liste\": \"__gelbe-liste.png\",\n        \"embryotox\": \"__embryotox.svg\",\n        \"radiopaedia\": \"__radiopaedia.png\",\n        \"orphanet\": \"__orphanet.png\",\n      }\n      if (domain in domainDict) {\n        icon = domainDict[domain]\n      } else {\n        icon = \"__internet.svg\"\n      }\n\n      const img = document.createElement('img');\n      img.setAttribute('src', icon);\n      img.setAttribute('style', 'height: 10px;');\n\n      btn.appendChild(img);\n      btn.innerHTML = btn.innerHTML + \" \" + text;\n\n      el.appendChild(btn);\n\n      document.getElementById(\"linkcontainer\").appendChild(el)\n    }\n  }\n  catch (err) {\n    console.log(err)\n  }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-uafi\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- AUTOFLIP BACK SCRIPT -->\n<script>\n  // autoflip hides card in front template\n  document.getElementById(\"qa\").style.removeProperty(\"display\")\n</script>\n\n<!-- CLOZE ONE BY ONE SCRIPT -->\n<style>\n  .cloze-replacer:hover {\n    cursor: pointer;\n  }\n\n  .cloze-hidden {\n    display: none;\n  }\n\n  .cloze-replacer .hidden {\n    display: none;\n  }\n\n  #extra.hidden {\n    display: none;\n  }\n</style>\n\n<!--\n Based on the AnKing Notetype, but expanded and modified by phyn.\n Credit to the original authors, except where modified or otherwise indicated.\n-->\n\n<script>\n    (function () {\n      // enables cloze one-by-one even when one-by-one field is empty\n      // minNumberOfClozes is still considered in this case\n      // overridden in importance by selectiveOneByOne\n      var clozeOneByOneEnabled = true;\n\n      // remove the clickAnywhere function from global scope\n      document.documentElement.removeAttribute(\"onclick\")\n\n      // --- CHECK IF ONE BY ONE IS GENERALLY ENABLED FOR THIS NOTE ---\n      var oneByOneFieldNotEmpty = \"{{One by one}}\" !== \"\";\n      try {\n        clozeOneByOneEnabled = alwaysOneByOne || oneByOneFieldNotEmpty;\n      } catch (exception) {\n        console.log(exception)\n      }\n\n      /**\n   * helper functions to show / hide fields containing additional information\n   */\n      const showExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const hideExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const buttonIds = [\n        \"hint-zusatz\",\n        \"hint-definition\",\n        \"hint-hammer\",\n        \"hint-klinik\",\n        \"hint-praeparat\",\n        \"hint-microscope\",\n        \"hint-smartzoom\",\n        \"hint-histotrainer\",\n        \"hint-uafi\",\n        \"hint-merksprueche\",\n        \"hint-memes\",\n        \"hint-image\",\n        \"hint-amboss\",\n        \"hint-thieme\",\n        \"hint-meditricks\",\n        \"hint-linkcontainer\",\n      ];\n\n      const showExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document\n              .getElementById(buttonIds[button])\n              .style.removeProperty(\"display\");\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n      const hideExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document.getElementById(buttonIds[button]).style.display = \"none\";\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n\n      // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n      /**\n       * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n       */\n      const getCardNumber = function () {\n        clz = document.body.className;\n        const regex = /card(\\d+)/gm;\n\n        let clz2;\n        try {\n          clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n        } catch (e) {\n          clz2 = \"\";\n        }\n        const regex2 = /.*?Cloze(\\d+)/gm;\n\n        let m;\n\n        if ((m = regex2.exec(clz2)) !== null) {\n          return m[1];\n        } else if ((m = regex.exec(clz)) !== null) {\n          return m[1];\n        } else {\n          // Should only fire if card is not cloze\n          console.error(\"Cannot find cardN class of body element!\");\n          return \"0\";\n        }\n      }\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (!clozeOneByOneEnabled) {\n        showExtra()\n        showExtraButtons()\n        document.getElementById(\"onebyone-buttons\").style.display = \"none\"\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n        return\n      }\n\n      // Needed for amboss to recognize first word in .cloze-hidden\n      const CLOZE_REPLACER_SEP = \"<span class='hidden'> </span>\"\n\n      const hideAllCloze = function (initial) {\n        let clozes = document.getElementsByClassName(\"cloze\")\n        let count = 0 // hidden cloze count\n        for (const cloze of clozes) {\n          const existingHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n          if (existingHidden) {\n            revealCloze(cloze);\n          }\n          if (cloze.offsetWidth === 0) {\n            continue\n          }\n          const clozeReplacer = document.createElement(\"span\")\n          const clozeHidden = document.createElement(\"span\")\n          clozeReplacer.classList.add(\"cloze-replacer\")\n          clozeHidden.classList.add(\"cloze-hidden\")\n          while (cloze.childNodes.length > 0) {\n            clozeHidden.appendChild(cloze.childNodes[0])\n          }\n          cloze.appendChild(clozeReplacer)\n          cloze.appendChild(clozeHidden)\n\n          var clozeHints = Persistence.getItem(\"clozeHints\");\n          if (clozeHints && clozeHints[count]) {\n            clozeReplacer.classList.add(\"cloze-hint\")\n            clozeReplacer.innerHTML = clozeHints[count] + CLOZE_REPLACER_SEP\n          } else {\n            clozeReplacer.innerHTML = clozeHider(cloze) + CLOZE_REPLACER_SEP\n          }\n          count += 1\n          document.getElementById(\"button-reveal-next\").style.display = \"inline-block\";\n          if (initial) {\n            cloze.addEventListener(\"touchend\", revealClozeClicked)\n            cloze.addEventListener(\"click\", revealClozeClicked)\n            cloze.classList.add(\"one-by-one\");\n          }\n        }\n\n        // Hide #extra until all clozes are shown\n        const extra = document.getElementById(\"extra\");\n        if (extra) {\n          extra.classList.add(\"hidden\");\n        }\n\n        hideExtra();\n        hideExtraButtons();\n        if (revealAnywhere) {\n          document.documentElement.setAttribute(\"onclick\", \"revealNextCloze(); event.stopPropagation()\")\n        }\n\n\n        // Also hide autoReveal fields\n        for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n          const container = document.querySelector(`[data-name=\"${field}\"]`)\n          if (container) {\n            const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n            if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n              // const link = container.getElementsByTagName(\"a\")[0]\n              const button = container.getElementsByTagName(\"button\")[0]\n              const hint = container.getElementsByTagName(\"div\")[0]\n              button.classList.remove(\"expanded-button\")\n              hint.style.display = \"none\"\n              // link.style.display = \"\"\n            }\n          }\n        }\n      }\n\n      const revealCloze = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        cloze.removeChild(clozeReplacer)\n        cloze.removeChild(clozeHidden)\n        while (clozeHidden.childNodes.length > 0) {\n          cloze.appendChild(clozeHidden.childNodes[0])\n        }\n        maybeRevealExtraField()\n      }\n\n      const revealClozeWord = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        let range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundSpace = setRangeEnd(range, clozeHidden, \"beforeFirstSpace\")\n        if (!foundSpace) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        let fragment = range.extractContents()\n        cloze.insertBefore(fragment, clozeReplacer)\n        // Extract whitespaces after word\n        range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundWord = setRangeEnd(range, clozeHidden, \"beforeFirstChar\")\n        if (!foundWord) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        fragment = range.extractContents();\n        cloze.insertBefore(fragment, clozeReplacer)\n        if (!foundWord) {\n          cloze.removeChild(clozeHidden)\n          cloze.removeChild(clozeReplacer)\n          maybeRevealExtraField()\n          return\n        }\n        clozeReplacer.innerHTML = clozeHider(clozeHidden) + CLOZE_REPLACER_SEP\n        if (clozeReplacer.classList.contains(\"cloze-hint\")) [\n          clozeReplacer.classList.remove(\"cloze-hint\")\n        ]\n        maybeRevealExtraField()\n      }\n\n      const revealNextClozeOf = (type) => {\n        const nextHidden = document.querySelectorAll(\".cloze-hidden\")\n        const nextNextHidden = nextHidden.length > 1 ? true : false\n        if (!nextNextHidden) {\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\";\n        }\n        if (!nextHidden) {\n          return\n        }\n        const cloze = clozeElOfClozeHidden(nextHidden[0]);\n        if (type === \"word\") {\n          revealClozeWord(cloze)\n        } else if (type === \"cloze\") {\n          revealCloze(cloze)\n        } else {\n          console.error(\"Invalid type: \" + type)\n        }\n      }\n\n      const revealClozeClicked = function (ev) {\n        let elem = ev.currentTarget\n        if (!ev.altKey && (revealNextClozeMode !== \"word\")) {\n          revealCloze(elem)\n        } else {\n          revealClozeWord(elem)\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      }\n\n      window.revealNextCloze = function () {\n        revealNextClozeOf(revealNextClozeMode)\n      }\n\n      window.toggleAllCloze = function () {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length > 0) {\n          for (const elem of elems) {\n            const cloze = clozeElOfClozeHidden(elem)\n            revealCloze(cloze)\n          }\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\"\n        } else {\n          hideAllCloze(initial = false)\n        }\n      }\n\n      const clozeElOfClozeHidden = (cloze) => {\n        while (!cloze.classList.contains(\"cloze\")) {\n          cloze = cloze.parentElement;\n        }\n        return cloze;\n      }\n\n      const maybeRevealExtraField = () => {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length == 0) {\n          const extra = document.getElementById(\"extra\")\n          if (extra) {\n            extra.classList.remove(\"hidden\")\n          }\n\n          showExtra();\n          showExtraButtons();\n          document.documentElement.removeAttribute(\"onclick\")\n\n          // Also reveal autoReveal fields\n          for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n            const container = document.querySelector(`[data-name=\"${field}\"]`)\n            if (container) {\n              const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n              if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n                // const link = container.getElementsByTagName(\"a\")[0]\n                const button = container.getElementsByTagName(\"button\")[0]\n                const hint = container.getElementsByTagName(\"div\")[0]\n                button.classList.add(\"expanded-button\")\n                hint.style.display = \"block\"\n                // link.style.display = \"none\"\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * mode: 'beforeFirstSpace' or 'beforeFirstChar'\n       * Return `true` if it exists and setEnd() was called, otherwise `false`\n       */\n      const setRangeEnd = function (range, node, mode) {\n        if (node.nodeType === Node.TEXT_NODE) {\n          const regex = mode === 'beforeFirstSpace' ? /\\s/ : /\\S/\n          const match = node.textContent.match(regex)\n          if (match) {\n            if (match.index === 0) {\n              while (node.previousSibling === null) {\n                node = node.parentElement\n              }\n              range.setEndBefore(node)\n            } else {\n              range.setEnd(node, match.index);\n            }\n            return true;\n          } else {\n            return false;\n          }\n        } else if (mode === 'beforeFirstChar' && isCharNode(node)) {\n          range.setEndBefore(node)\n          return true\n        } else if (!ignoreSpaceInNode(node)) {\n          for (const child of node.childNodes) {\n            if (setRangeEnd(range, child, mode)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }\n\n      const ignoreSpaceInNode = function (node) {\n        return node.tagName === \"MJX-ASSISTIVE-MML\"\n      }\n\n      const isCharNode = function (node) {\n        return [\"IMG\", \"MJX-CONTAINER\"].includes(node.tagName)\n      }\n\n      hideAllCloze(initial = true)\n\n      let isShowNextShortcut = shortcutMatcher(window.revealNextShortcut)\n      let isShowWordShortcut = shortcutMatcher(window.revealNextWordShortcut)\n      let isToggleAllShortcut = shortcutMatcher(window.toggleAllShortcut)\n      ankingAddEventListener(\"keydown\", (ev) => {\n        let next = isShowNextShortcut(ev)\n        let word = isShowWordShortcut(ev)\n        let all = isToggleAllShortcut(ev)\n        if (next) {\n          revealNextClozeOf(\"cloze\")\n        } else if (word) {\n          revealNextClozeOf(\"word\")\n        } else if (all) {\n          toggleAllCloze()\n        } else {\n          return;\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      });\n    })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- MEDITRICKS SNIPPETS DATA -->\n<div id=\"meditricks-mtsp-values\" style=\"display:none;\">\n  <div id=\"meditricks-mtsp-nfname\">_meditricks_nf_v1000_ankizin</div>\n  <div id=\"meditricks-mtsp-nid\">{{Note ID}}</div>\n</div>\n<script src=\"_meditricks_mtsp_scripts_v1000_ankizin.js\"></script>\n<link href=\"_meditricks_mtsp_styles_v1000_ankizin.css\" rel=\"stylesheet\" />\n\n<!-- include \"_meditricks_mtsp_nf_v1000_ankizin.js\" -->\n<!-- include \"_meditricks_mtsp_scripts_v1000_iframe.map\" -->\n<!-- include \"_meditricks_mtsp_mtlogo.webp\" -->\n<!-- include \"_meditricks_mtsp_mt-loading.png\" -->\n<!-- include \"_meditricks_mtsp_mt-loading_night.png\" -->\n\n<!-- //MEDITRICKS SNIPPETS DATA -->\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>",
      "bqfmt": "{{Muskel / Leitungsbahn}}",
      "bafmt": "{{Ansatz}}",
      "did": null,
      "bfont": "Helvetica",
      "bsize": 12
    },
    {
      "name": "Verlauf",
      "ord": 2,
      "qfmt": "<!-- version f0935e4 -->\n{{#Verlauf}}\n{{^VerlaufCloze1}}{{^VerlaufCloze2}}{{^VerlaufCloze3}}\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n<div id=\"cloze\" data-card=\"{{Card}}\"></div>\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TIMER CONFIG  ##############\n  // Timer config (timer length, timer finished message)\n  var minutes = 0\n  var seconds = 15\n  var timeOverMsg = \"<span style='color:#CC5B5B'>!!!</span>\"\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  // Auto flip to back when One by one mode.\n  var autoflip = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Wie ist der <i>Verlauf</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\"></div>\n\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<script>\n  //DONT FADE BETWEEN CARDS\n  qFade = 0;\n  if (typeof anki !== 'undefined') anki.qFade = qFade;\n</script>\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    if (!indentation) { return; }\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- CLOZE ONE BY ONE FRONT -->\n<div id=\"one-by-one\" style=\"display: none;\"></div>\n\n<script>\n  /**\n   * Based on the AnKing Notetype, but expanded and modified by phyn.\n   * Credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  Persistence.clear();\n\n  // check if OneByOne is generally enabled for this card\n  var oneByOneFieldEmpty = selectiveOneByOne ? \"{{One by one}}\" === \"\" : true;\n  var clozeOneByOneEnabled = alwaysOneByOne ? true : !oneByOneFieldEmpty;\n\n  // avoid flickering. Must unset this in the back.\n  document.getElementById(\"qa\").style.display = \"none\";\n  var clozeHints = [];\n\n  if (clozeOneByOneEnabled) {\n    // collect hints from front side (independent of whether or not OneByOne is enabled)\n    document.getElementById(\"qa\").classList.add('one-by-one');\n    // Save cloze hints to display in the back\n    var clozes = document.getElementsByClassName(\"cloze\")\n    for (var i = 0; i < clozes.length; i++) {\n      clozes[i].classList.add(\"one-by-one\");\n      if (clozes[i].innerHTML === \"[...]\") {\n        clozeHints.push(\"\")\n      } else {\n        clozeHints.push(clozes[i].innerHTML)\n      }\n    }\n\n    // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n    /**\n     * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n     */\n    const getCardNumber = function () {\n      clz = document.body.className;\n      const regex = /card(\\d+)/gm;\n\n      let clz2;\n      try {\n        clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n      } catch (e) {\n        clz2 = \"\";\n      }\n      const regex2 = /.*?Cloze(\\d+)/gm;\n\n      let m;\n\n      if ((m = regex2.exec(clz2)) !== null) {\n        return m[1];\n      } else if ((m = regex.exec(clz)) !== null) {\n        return m[1];\n      } else {\n        // Should only fire if card is not cloze\n        console.error(\"Cannot find cardN class of body element!\");\n        return \"0\";\n      }\n    }\n\n    var alreadyRendered = false;\n\n    function processSelective1b1() {\n      if (alreadyRendered) return;\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (autoflip && clozeOneByOneEnabled) {\n        if (window.pycmd || window.showAnswer) {\n          // avoid flickering. Must unset this in the back.\n          document.getElementById(\"qa\").style.display = \"none\";\n        }\n        if (window.pycmd) {\n          pycmd(\"ans\")\n        } else if (window.showAnswer) {\n          showAnswer()\n        }\n      } else {\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n      }\n      // AnkiMobile JS API doesn't have one for show answer.\n      // Best alternative is to use Taps/Swipes to show answer.\n\n      alreadyRendered = true;\n    }\n\n    function delayedProcessSelective1b1() {\n      if (window.requestAnimationFrame) window.requestAnimationFrame(processSelective1b1); // less flickering\n      else window.setTimeout(processSelective1b1, 0);\n    };\n\n    window.onload = delayedProcessSelective1b1;\n    if (document.readyState === \"complete\") {\n      delayedProcessSelective1b1();\n    }\n    else {\n      document.addEventListener(\"DOMContentLoaded\", delayedProcessSelective1b1);\n    }\n\n    // Observe document.body class changes to trigger re-rendering.\n    // This is useful, because Anki doesn’t always start with an up-to-date class list:\n    // https://forums.ankiweb.net/t/card-card-classes-only-injected-separately-now/27387.\n    const observer = new MutationObserver(function (mutationsList, observer) {\n      for (let mutation of mutationsList) {\n        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {\n          delayedProcessSelective1b1();\n        }\n      }\n    });\n    observer.observe(document.body, { attributes: true });\n  }\n  Persistence.setItem(\"clozeHints\", clozeHints);\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>\n\n\n{{/VerlaufCloze3}}{{/VerlaufCloze2}}{{/VerlaufCloze1}}\n{{/Verlauf}}",
      "afmt": "<!-- version f0935e4 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n<div id=\"back\"></div>\n<div id=\"cloze\" data-card=\"{{Card}}\"></div>\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Eigene Notizen & Bilder\": \"Alt + 1\",\n    \"Eigene Prüfungsfragen\": \"Alt + 2\",\n    \"Definitionen\": \"Alt + 3\",\n    \"Merksprüche\": \"Alt + 4\",\n    \"Klinik\": \"Alt + 5\",\n    \"Präparat\": \"Alt + 6\",\n    \"Memes\": \"Alt + 7\",\n    \"linkContainer\": \"Alt + L\",\n    \"Meditricks\": \"Alt + M\",\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Eigene Notizen & Bilder\": false,\n    \"Eigene Prüfungsfragen\": false,\n    \"Definitionen\": false,\n    \"Merksprüche\": false,\n    \"Klinik\": false,\n    \"Präparat\": false,\n    \"Memes\": false,\n    \"linkContainer\": true,\n    \"Meditricks\": false,\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  var revealNextShortcut = \"N\"\n  var revealNextWordShortcut = \"Shift + N\"\n  var toggleAllShortcut = \",\"\n\n  // Enables revealing of next Cloze by simply clicking / tapping anywhere on the card (except the buttons)\n  var revealAnywhere = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // Changes how \"Reveal Next\" and clicking behaves. Either \"cloze\" or \"word\".\n  // \"word\" reveals word by word. \n  var revealNextClozeMode = \"cloze\"\n\n  // Changes how fields with additional information are displayed.\n  // true displays fields with additional information only if all clozes are revealed.\n  var hideAdditional = true;\n  var hideAdditionalButtons = true;\n\n  // What cloze is hidden with\n  var clozeHider = (elem) => \"[&nbsp;_&nbsp;]\"\n  /*\n  You can replace the above line with below examples. '█' or '_' works well for hiding clozes.\n  \n  // Fixed length:\n  var clozeHider = (elem) => \"███\"\n  // Replace each character with \"█\":\n  var clozeHider = (elem) => \"█\".repeat(elem.textContent.length)\n  // Show whitespaces:\n  var clozeHider = (elem) => \"[\" + elem.textContent.split(\" \").map((t) => \"█\".repeat(t.length)).join(\" \") + \"]\"\n  // Color-filled box (doesn't hide images):\n  var clozeHider = (elem) => `<span style=\"background-color: red; color: transparent;\">${elem.innerHTML}</span>`\n  */\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Wie ist der <i>Verlauf</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div class=\"cloze\"><br>{{Verlauf}}</div>\n\n    <!-- ClOZE ONE BY ONE BUTTONS -->\n    <div id=\"onebyone-buttons\" class=\"onebyone\">\n      <br>\n      <button id=\"button-reveal-next\" class=\"button-general button-one-by-one\"\n        onclick=\"revealNextCloze(); event.stopPropagation()\">Reveal Next</button>\n      <button id=\"button-toggle-all\" class=\"button-general button-one-by-one\"\n        onclick=\"toggleAllCloze(); event.stopPropagation()\">Toggle All</button>\n    </div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- BUTTON FIELDS -->\n    {{#Eigene Notizen & Bilder}}\n    <span id=\"hint-zusatz\" class=\"hintBtn\" data-name=\"Eigene Notizen & Bilder\" style=\"display: none;\">\n      <button id=\"button-zusatz\" class=\"button-general\" onclick=\"toggleHintBtn('hint-zusatz'); event.stopPropagation()\">\n        <img src=\"__zusatz.svg\" style=\"height: 10px;\"> Eigene Notizen & Bilder\n      </button>\n      <div dir=\"auto\" id=\"zusatz\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Notizen & Bilder}}</div>\n    </span>\n    {{/Eigene Notizen & Bilder}}\n\n    {{#Eigene Prüfungsfragen}}\n    <span id=\"hint-hammer\" class=\"hintBtn\" data-name=\"Eigene Prüfungsfragen\" style=\"display: none;\">\n      <button id=\"button-hammer\" class=\"button-general\" onclick=\"toggleHintBtn('hint-hammer'); event.stopPropagation()\">\n        <img src=\"__hammer.svg\" style=\"height: 10px;\"> Eigene Prüfungsfragen\n      </button>\n      <div dir=\"auto\" id=\"hammer\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Prüfungsfragen}}</div>\n    </span>\n    {{/Eigene Prüfungsfragen}}\n\n    {{#Definitionen}}\n    <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Definitionen\" style=\"display: none;\">\n      <button id=\"button-definition\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Definitionen\n      </button>\n      <div dir=\"auto\" id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Definitionen}}</div>\n    </span>\n    {{/Definitionen}}\n\n    {{#Merksprüche}}\n    <span id=\"hint-merksprueche\" class=\"hintBtn\" data-name=\"Merksprüche\" style=\"display: none;\">\n      <button id=\"button-merksprueche\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-merksprueche'); event.stopPropagation()\">\n        <img src=\"__merkhilfe.svg\" style=\"height: 10px;\"> Merksprüche\n      </button>\n      <div dir=\"auto\" id=\"merksprueche\" class=\"hints\" style=\"display: none;\">{{edit:Merksprüche}}</div>\n    </span>\n    {{/Merksprüche}}\n\n    {{#Klinik}}\n    <span id=\"hint-klinik\" class=\"hintBtn\" data-name=\"Klinik\" style=\"display: none;\">\n      <button id=\"button-klinik\" class=\"button-general\" onclick=\"toggleHintBtn('hint-klinik'); event.stopPropagation()\">\n        <img src=\"__stethoscope.svg\" style=\"height: 10px;\"> Klinik\n      </button>\n      <div dir=\"auto\" id=\"klinik\" class=\"hints\" style=\"display: none;\">{{edit:Klinik}}</div>\n    </span>\n    {{/Klinik}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-praeparat\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n        </button>\n      </a>\n    </span>\n    {{/Präparat}}\n\n    {{#Virtuelle Mikroskopie}}\n    <span id=\"hint-microscope-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Virtuelle Mikroskopie}}\">\n        <button id=\"button-microscope\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Virtuelle Mikroskopie\n        </button>\n      </a>\n    </span>\n    {{/Virtuelle Mikroskopie}}\n\n    {{#Smart Zoom}}\n    <span id=\"hint-smartzoom-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-smartzoom\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Smart Zoom\n        </button>\n      </a>\n    </span>\n    {{/Smart Zoom}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat\" class=\"hintBtn\" data-name=\"Präparat\" style=\"display: none;\">\n      <button id=\"button-praeparat\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-praeparat'); event.stopPropagation()\">\n        <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n      </button>\n      <div dir=\"auto\" id=\"praeparat\" class=\"hints\" style=\"display: none;\">{{edit:Präparat}}</div>\n    </span>\n    {{/Präparat}}\n\n    {{#Memes}}\n    <span id=\"hint-memes\" class=\"hintBtn\" data-name=\"Memes\" style=\"display: none;\">\n      <button id=\"button-memes\" class=\"button-general\" onclick=\"toggleHintBtn('hint-memes'); event.stopPropagation()\">\n        <img src=\"__sonstiges.svg\" style=\"height: 10px;\"> Memes\n      </button>\n      <div dir=\"auto\" id=\"memes\" class=\"hints\" style=\"display: none;\">{{edit:Memes}}</div>\n    </span>\n    {{/Memes}}\n\n    <!-- LINEBREAKS IF BUTTONS EXIST -->\n    <script>\n      var array = [`{{Eigene Notizen & Bilder}}`, `{{Eigene Prüfungsfragen}}`, `{{Definitionen}}`, `{{Merksprüche}}`, `{{Klinik}}`, `{{Präparat}}`, `{{Memes}}`];\n      var anyistrue = (element) => element;\n      if (array.some(anyistrue)) {\n        document.getElementById(\"linebreaksIfButtons\").innerHTML = \"<br>\";\n      }\n    </script>\n    <div id=\"linebreaksIfButtons\"></div>\n\n    <!-- Extra field -->\n    {{#Extra}}\n    <div id=\"extra\" style=\"display: none;\">\n      <br>{{edit:Extra}}<br><br>\n    </div>\n    {{/Extra}}\n\n    <!-- Image field -->\n    {{#Bild}}\n    <div id=\"image\" style=\"display: none;\">\n      {{edit:Bild}}<br><br></div>\n    {{/Bild}}\n    {{^Bild}}\n    <span id=\"image\" style=\"display: none;\"></span>\n    {{/Bild}}\n    {{#Bild}}\n    <span id=\"hint-image\" style=\"display: none;\">\n      <button id=\"button-image\" class=\"button-general\"\n        onclick=\"var image = document.getElementById('image'); if (image.style.display == 'none') { image.style.display = 'block' } else { image.style.display = 'none' }; event.stopPropagation()\">\n        <img src=\"__image.svg\" style=\"height: 10px;\"> Abbildung\n      </button>\n    </span>\n    {{/Bild}}\n\n    <span id=\"hint-uafi\" class=\"hintBtn\" data-name=\"Ursprung, Ansatz, Verlauf, Funktion, Innervation, Äste\"\n      style=\"display: none;\">\n      <button id=\"button-uafi\" class=\"button-general expanded-button\"\n        onclick=\"toggleHintBtn('hint-uafi'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Weitere Informationen\n      </button>\n      <div id=\"uafi\" class=\"hints\" style=\"display: block;\">\n        <table class=\"uncloze\">\n          {{#Ursprung}}\n          <tr class=\"uafi-element\" id=\"Ursprung\">\n            <td><i>Ursprung</i></td>\n            <td>{{Ursprung}}</td>\n          </tr>\n          {{/Ursprung}}\n          {{#Ansatz}}\n          <tr class=\"uafi-element\" id=\"Ansatz\">\n            <td><i>Ansatz</i></td>\n            <td>{{Ansatz}}</td>\n          </tr>\n          {{/Ansatz}}\n          {{#Verlauf}}\n          <tr class=\"uafi-element\" id=\"Verlauf\">\n            <td><i>Verlauf</i></td>\n            <td>{{Verlauf}}</td>\n          </tr>\n          {{/Verlauf}}\n          {{#Funktion}}\n          <tr class=\"uafi-element\" id=\"Funktion\">\n            <td><i>Funktion</i></td>\n            <td>{{Funktion}}</td>\n          </tr>\n          {{/Funktion}}\n          {{#Innervation}}\n          <tr class=\"uafi-element\" id=\"Innervation\">\n            <td><i>Innervation</i></td>\n            <td>{{Innervation}}</td>\n          </tr>\n          {{/Innervation}}\n          {{#Äste}}\n          <tr class=\"uafi-element\" id=\"Äste\">\n            <td><i>Äste</i></td>\n            <td>{{Äste}}</td>\n          </tr>\n          {{/Äste}}\n        </table>\n      </div>\n\n      <script>\n        // iterate over all uafi-elements and hide only the one\n        // that is equal to the card's answer (i.e., value of {{Card}})\n        var uafiElements = document.getElementsByClassName(\"uafi-element\");\n        for (var i = 0; i < uafiElements.length; i++) {\n          if (((\"{{Card}}\").startsWith(uafiElements[i].id))) {\n            uafiElements[i].remove()\n          }\n        }\n      </script>\n    </span>\n\n    {{#AMBOSS-Link}}\n    <span id=\"hint-amboss\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:AMBOSS-Link}}\">\n        <button id=\"button-amboss\" class=\"button-general\">\n          <img src=\"__amboss.svg\" style=\"height: 10px;\"> AMBOSS&#8203;\n        </button>\n      </a>\n    </span>\n    {{/AMBOSS-Link}}\n\n    {{#Thieme via medici-Link}}\n    <span id=\"hint-thieme\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Thieme via medici-Link}}\">\n        <button id=\"button-thieme\" class=\"button-general\">\n          <img id=\"button-thieme-img\" src=\"__thieme-heart.svg\" style=\"height: 10px;\"> Thieme via medici\n        </button>\n      </a>\n    </span>\n    {{/Thieme via medici-Link}}\n\n    {{#Meditricks}}\n    <span id=\"hint-meditricks\" class=\"hintBtn\" data-name=\"Meditricks\" style=\"display: none;\">\n      <button id=\"button-meditricks\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-meditricks'); event.stopPropagation()\">\n        <img src=\"__meditricks.svg\" style=\"height: 10px;\"> Meditricks\n      </button>\n      <div dir=\"auto\" id=\"meditricks\" class=\"hints\" style=\"display: none;\">{{edit:Meditricks}}</div>\n    </span>\n    {{/Meditricks}}\n\n    {{#weitere Links}}\n    <span id=\"hint-linkcontainer\" class=\"hintBtn\" data-name=\"linkContainer\" style=\"display: none;\">\n      <button id=\"button-linkcontainer\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-linkcontainer'); event.stopPropagation()\">\n        <img src=\"__internet.svg\" style=\"height: 10px;\"> weitere Links\n      </button>\n      <div id=\"linkcontainer\" class=\"hints\" style=\"display: none;\"></div>\n      <span id=\"linkContainerLinks\" style=\"display: none;\">{{edit:weitere Links}}</span>\n    </span>\n    {{/weitere Links}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n  try {\n    for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n      href = link.href\n      text = link.innerText\n\n      const el = document.createElement('a');\n      el.setAttribute('href', link.href);\n\n      const btn = document.createElement('button');\n      btn.classList.add('button-general');\n      btn.classList.add('expanded-button');\n\n      domain = href.replace(/.+\\/\\/|(www|flexikon|register|de|next|com).|\\..+/g, '');\n      domainDict = {\n        \"amboss\": \"__amboss.svg\",\n        \"wikipedia\": \"__wikipedia.svg\",\n        \"doccheck\": \"__doccheck.png\",\n        \"notfallguru\": \"__notfallguru.svg\",\n        \"awmf\": \"__awmf.svg\",\n        \"gelbe-liste\": \"__gelbe-liste.png\",\n        \"embryotox\": \"__embryotox.svg\",\n        \"radiopaedia\": \"__radiopaedia.png\",\n        \"orphanet\": \"__orphanet.png\",\n      }\n      if (domain in domainDict) {\n        icon = domainDict[domain]\n      } else {\n        icon = \"__internet.svg\"\n      }\n\n      const img = document.createElement('img');\n      img.setAttribute('src', icon);\n      img.setAttribute('style', 'height: 10px;');\n\n      btn.appendChild(img);\n      btn.innerHTML = btn.innerHTML + \" \" + text;\n\n      el.appendChild(btn);\n\n      document.getElementById(\"linkcontainer\").appendChild(el)\n    }\n  }\n  catch (err) {\n    console.log(err)\n  }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-uafi\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- AUTOFLIP BACK SCRIPT -->\n<script>\n  // autoflip hides card in front template\n  document.getElementById(\"qa\").style.removeProperty(\"display\")\n</script>\n\n<!-- CLOZE ONE BY ONE SCRIPT -->\n<style>\n  .cloze-replacer:hover {\n    cursor: pointer;\n  }\n\n  .cloze-hidden {\n    display: none;\n  }\n\n  .cloze-replacer .hidden {\n    display: none;\n  }\n\n  #extra.hidden {\n    display: none;\n  }\n</style>\n\n<!--\n Based on the AnKing Notetype, but expanded and modified by phyn.\n Credit to the original authors, except where modified or otherwise indicated.\n-->\n\n<script>\n    (function () {\n      // enables cloze one-by-one even when one-by-one field is empty\n      // minNumberOfClozes is still considered in this case\n      // overridden in importance by selectiveOneByOne\n      var clozeOneByOneEnabled = true;\n\n      // remove the clickAnywhere function from global scope\n      document.documentElement.removeAttribute(\"onclick\")\n\n      // --- CHECK IF ONE BY ONE IS GENERALLY ENABLED FOR THIS NOTE ---\n      var oneByOneFieldNotEmpty = \"{{One by one}}\" !== \"\";\n      try {\n        clozeOneByOneEnabled = alwaysOneByOne || oneByOneFieldNotEmpty;\n      } catch (exception) {\n        console.log(exception)\n      }\n\n      /**\n   * helper functions to show / hide fields containing additional information\n   */\n      const showExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const hideExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const buttonIds = [\n        \"hint-zusatz\",\n        \"hint-definition\",\n        \"hint-hammer\",\n        \"hint-klinik\",\n        \"hint-praeparat\",\n        \"hint-microscope\",\n        \"hint-smartzoom\",\n        \"hint-histotrainer\",\n        \"hint-uafi\",\n        \"hint-merksprueche\",\n        \"hint-memes\",\n        \"hint-image\",\n        \"hint-amboss\",\n        \"hint-thieme\",\n        \"hint-meditricks\",\n        \"hint-linkcontainer\",\n      ];\n\n      const showExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document\n              .getElementById(buttonIds[button])\n              .style.removeProperty(\"display\");\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n      const hideExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document.getElementById(buttonIds[button]).style.display = \"none\";\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n\n      // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n      /**\n       * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n       */\n      const getCardNumber = function () {\n        clz = document.body.className;\n        const regex = /card(\\d+)/gm;\n\n        let clz2;\n        try {\n          clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n        } catch (e) {\n          clz2 = \"\";\n        }\n        const regex2 = /.*?Cloze(\\d+)/gm;\n\n        let m;\n\n        if ((m = regex2.exec(clz2)) !== null) {\n          return m[1];\n        } else if ((m = regex.exec(clz)) !== null) {\n          return m[1];\n        } else {\n          // Should only fire if card is not cloze\n          console.error(\"Cannot find cardN class of body element!\");\n          return \"0\";\n        }\n      }\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (!clozeOneByOneEnabled) {\n        showExtra()\n        showExtraButtons()\n        document.getElementById(\"onebyone-buttons\").style.display = \"none\"\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n        return\n      }\n\n      // Needed for amboss to recognize first word in .cloze-hidden\n      const CLOZE_REPLACER_SEP = \"<span class='hidden'> </span>\"\n\n      const hideAllCloze = function (initial) {\n        let clozes = document.getElementsByClassName(\"cloze\")\n        let count = 0 // hidden cloze count\n        for (const cloze of clozes) {\n          const existingHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n          if (existingHidden) {\n            revealCloze(cloze);\n          }\n          if (cloze.offsetWidth === 0) {\n            continue\n          }\n          const clozeReplacer = document.createElement(\"span\")\n          const clozeHidden = document.createElement(\"span\")\n          clozeReplacer.classList.add(\"cloze-replacer\")\n          clozeHidden.classList.add(\"cloze-hidden\")\n          while (cloze.childNodes.length > 0) {\n            clozeHidden.appendChild(cloze.childNodes[0])\n          }\n          cloze.appendChild(clozeReplacer)\n          cloze.appendChild(clozeHidden)\n\n          var clozeHints = Persistence.getItem(\"clozeHints\");\n          if (clozeHints && clozeHints[count]) {\n            clozeReplacer.classList.add(\"cloze-hint\")\n            clozeReplacer.innerHTML = clozeHints[count] + CLOZE_REPLACER_SEP\n          } else {\n            clozeReplacer.innerHTML = clozeHider(cloze) + CLOZE_REPLACER_SEP\n          }\n          count += 1\n          document.getElementById(\"button-reveal-next\").style.display = \"inline-block\";\n          if (initial) {\n            cloze.addEventListener(\"touchend\", revealClozeClicked)\n            cloze.addEventListener(\"click\", revealClozeClicked)\n            cloze.classList.add(\"one-by-one\");\n          }\n        }\n\n        // Hide #extra until all clozes are shown\n        const extra = document.getElementById(\"extra\");\n        if (extra) {\n          extra.classList.add(\"hidden\");\n        }\n\n        hideExtra();\n        hideExtraButtons();\n        if (revealAnywhere) {\n          document.documentElement.setAttribute(\"onclick\", \"revealNextCloze(); event.stopPropagation()\")\n        }\n\n\n        // Also hide autoReveal fields\n        for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n          const container = document.querySelector(`[data-name=\"${field}\"]`)\n          if (container) {\n            const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n            if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n              // const link = container.getElementsByTagName(\"a\")[0]\n              const button = container.getElementsByTagName(\"button\")[0]\n              const hint = container.getElementsByTagName(\"div\")[0]\n              button.classList.remove(\"expanded-button\")\n              hint.style.display = \"none\"\n              // link.style.display = \"\"\n            }\n          }\n        }\n      }\n\n      const revealCloze = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        cloze.removeChild(clozeReplacer)\n        cloze.removeChild(clozeHidden)\n        while (clozeHidden.childNodes.length > 0) {\n          cloze.appendChild(clozeHidden.childNodes[0])\n        }\n        maybeRevealExtraField()\n      }\n\n      const revealClozeWord = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        let range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundSpace = setRangeEnd(range, clozeHidden, \"beforeFirstSpace\")\n        if (!foundSpace) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        let fragment = range.extractContents()\n        cloze.insertBefore(fragment, clozeReplacer)\n        // Extract whitespaces after word\n        range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundWord = setRangeEnd(range, clozeHidden, \"beforeFirstChar\")\n        if (!foundWord) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        fragment = range.extractContents();\n        cloze.insertBefore(fragment, clozeReplacer)\n        if (!foundWord) {\n          cloze.removeChild(clozeHidden)\n          cloze.removeChild(clozeReplacer)\n          maybeRevealExtraField()\n          return\n        }\n        clozeReplacer.innerHTML = clozeHider(clozeHidden) + CLOZE_REPLACER_SEP\n        if (clozeReplacer.classList.contains(\"cloze-hint\")) [\n          clozeReplacer.classList.remove(\"cloze-hint\")\n        ]\n        maybeRevealExtraField()\n      }\n\n      const revealNextClozeOf = (type) => {\n        const nextHidden = document.querySelectorAll(\".cloze-hidden\")\n        const nextNextHidden = nextHidden.length > 1 ? true : false\n        if (!nextNextHidden) {\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\";\n        }\n        if (!nextHidden) {\n          return\n        }\n        const cloze = clozeElOfClozeHidden(nextHidden[0]);\n        if (type === \"word\") {\n          revealClozeWord(cloze)\n        } else if (type === \"cloze\") {\n          revealCloze(cloze)\n        } else {\n          console.error(\"Invalid type: \" + type)\n        }\n      }\n\n      const revealClozeClicked = function (ev) {\n        let elem = ev.currentTarget\n        if (!ev.altKey && (revealNextClozeMode !== \"word\")) {\n          revealCloze(elem)\n        } else {\n          revealClozeWord(elem)\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      }\n\n      window.revealNextCloze = function () {\n        revealNextClozeOf(revealNextClozeMode)\n      }\n\n      window.toggleAllCloze = function () {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length > 0) {\n          for (const elem of elems) {\n            const cloze = clozeElOfClozeHidden(elem)\n            revealCloze(cloze)\n          }\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\"\n        } else {\n          hideAllCloze(initial = false)\n        }\n      }\n\n      const clozeElOfClozeHidden = (cloze) => {\n        while (!cloze.classList.contains(\"cloze\")) {\n          cloze = cloze.parentElement;\n        }\n        return cloze;\n      }\n\n      const maybeRevealExtraField = () => {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length == 0) {\n          const extra = document.getElementById(\"extra\")\n          if (extra) {\n            extra.classList.remove(\"hidden\")\n          }\n\n          showExtra();\n          showExtraButtons();\n          document.documentElement.removeAttribute(\"onclick\")\n\n          // Also reveal autoReveal fields\n          for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n            const container = document.querySelector(`[data-name=\"${field}\"]`)\n            if (container) {\n              const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n              if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n                // const link = container.getElementsByTagName(\"a\")[0]\n                const button = container.getElementsByTagName(\"button\")[0]\n                const hint = container.getElementsByTagName(\"div\")[0]\n                button.classList.add(\"expanded-button\")\n                hint.style.display = \"block\"\n                // link.style.display = \"none\"\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * mode: 'beforeFirstSpace' or 'beforeFirstChar'\n       * Return `true` if it exists and setEnd() was called, otherwise `false`\n       */\n      const setRangeEnd = function (range, node, mode) {\n        if (node.nodeType === Node.TEXT_NODE) {\n          const regex = mode === 'beforeFirstSpace' ? /\\s/ : /\\S/\n          const match = node.textContent.match(regex)\n          if (match) {\n            if (match.index === 0) {\n              while (node.previousSibling === null) {\n                node = node.parentElement\n              }\n              range.setEndBefore(node)\n            } else {\n              range.setEnd(node, match.index);\n            }\n            return true;\n          } else {\n            return false;\n          }\n        } else if (mode === 'beforeFirstChar' && isCharNode(node)) {\n          range.setEndBefore(node)\n          return true\n        } else if (!ignoreSpaceInNode(node)) {\n          for (const child of node.childNodes) {\n            if (setRangeEnd(range, child, mode)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }\n\n      const ignoreSpaceInNode = function (node) {\n        return node.tagName === \"MJX-ASSISTIVE-MML\"\n      }\n\n      const isCharNode = function (node) {\n        return [\"IMG\", \"MJX-CONTAINER\"].includes(node.tagName)\n      }\n\n      hideAllCloze(initial = true)\n\n      let isShowNextShortcut = shortcutMatcher(window.revealNextShortcut)\n      let isShowWordShortcut = shortcutMatcher(window.revealNextWordShortcut)\n      let isToggleAllShortcut = shortcutMatcher(window.toggleAllShortcut)\n      ankingAddEventListener(\"keydown\", (ev) => {\n        let next = isShowNextShortcut(ev)\n        let word = isShowWordShortcut(ev)\n        let all = isToggleAllShortcut(ev)\n        if (next) {\n          revealNextClozeOf(\"cloze\")\n        } else if (word) {\n          revealNextClozeOf(\"word\")\n        } else if (all) {\n          toggleAllCloze()\n        } else {\n          return;\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      });\n    })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- MEDITRICKS SNIPPETS DATA -->\n<div id=\"meditricks-mtsp-values\" style=\"display:none;\">\n  <div id=\"meditricks-mtsp-nfname\">_meditricks_nf_v1000_ankizin</div>\n  <div id=\"meditricks-mtsp-nid\">{{Note ID}}</div>\n</div>\n<script src=\"_meditricks_mtsp_scripts_v1000_ankizin.js\"></script>\n<link href=\"_meditricks_mtsp_styles_v1000_ankizin.css\" rel=\"stylesheet\" />\n\n<!-- include \"_meditricks_mtsp_nf_v1000_ankizin.js\" -->\n<!-- include \"_meditricks_mtsp_scripts_v1000_iframe.map\" -->\n<!-- include \"_meditricks_mtsp_mtlogo.webp\" -->\n<!-- include \"_meditricks_mtsp_mt-loading.png\" -->\n<!-- include \"_meditricks_mtsp_mt-loading_night.png\" -->\n\n<!-- //MEDITRICKS SNIPPETS DATA -->\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>",
      "bqfmt": "{{Muskel / Leitungsbahn}}",
      "bafmt": "{{Verlauf}}",
      "did": null,
      "bfont": "Helvetica",
      "bsize": 12
    },
    {
      "name": "Funktion",
      "ord": 3,
      "qfmt": "<!-- version f0935e4 -->\n{{#Funktion}}\n{{^FunktionCloze1}}{{^FunktionCloze2}}{{^FunktionCloze3}}\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n<div id=\"cloze\" data-card=\"{{Card}}\"></div>\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TIMER CONFIG  ##############\n  // Timer config (timer length, timer finished message)\n  var minutes = 0\n  var seconds = 15\n  var timeOverMsg = \"<span style='color:#CC5B5B'>!!!</span>\"\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  // Auto flip to back when One by one mode.\n  var autoflip = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Was ist die <i>Funktion</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\"></div>\n\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<script>\n  //DONT FADE BETWEEN CARDS\n  qFade = 0;\n  if (typeof anki !== 'undefined') anki.qFade = qFade;\n</script>\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    if (!indentation) { return; }\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- CLOZE ONE BY ONE FRONT -->\n<div id=\"one-by-one\" style=\"display: none;\"></div>\n\n<script>\n  /**\n   * Based on the AnKing Notetype, but expanded and modified by phyn.\n   * Credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  Persistence.clear();\n\n  // check if OneByOne is generally enabled for this card\n  var oneByOneFieldEmpty = selectiveOneByOne ? \"{{One by one}}\" === \"\" : true;\n  var clozeOneByOneEnabled = alwaysOneByOne ? true : !oneByOneFieldEmpty;\n\n  // avoid flickering. Must unset this in the back.\n  document.getElementById(\"qa\").style.display = \"none\";\n  var clozeHints = [];\n\n  if (clozeOneByOneEnabled) {\n    // collect hints from front side (independent of whether or not OneByOne is enabled)\n    document.getElementById(\"qa\").classList.add('one-by-one');\n    // Save cloze hints to display in the back\n    var clozes = document.getElementsByClassName(\"cloze\")\n    for (var i = 0; i < clozes.length; i++) {\n      clozes[i].classList.add(\"one-by-one\");\n      if (clozes[i].innerHTML === \"[...]\") {\n        clozeHints.push(\"\")\n      } else {\n        clozeHints.push(clozes[i].innerHTML)\n      }\n    }\n\n    // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n    /**\n     * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n     */\n    const getCardNumber = function () {\n      clz = document.body.className;\n      const regex = /card(\\d+)/gm;\n\n      let clz2;\n      try {\n        clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n      } catch (e) {\n        clz2 = \"\";\n      }\n      const regex2 = /.*?Cloze(\\d+)/gm;\n\n      let m;\n\n      if ((m = regex2.exec(clz2)) !== null) {\n        return m[1];\n      } else if ((m = regex.exec(clz)) !== null) {\n        return m[1];\n      } else {\n        // Should only fire if card is not cloze\n        console.error(\"Cannot find cardN class of body element!\");\n        return \"0\";\n      }\n    }\n\n    var alreadyRendered = false;\n\n    function processSelective1b1() {\n      if (alreadyRendered) return;\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (autoflip && clozeOneByOneEnabled) {\n        if (window.pycmd || window.showAnswer) {\n          // avoid flickering. Must unset this in the back.\n          document.getElementById(\"qa\").style.display = \"none\";\n        }\n        if (window.pycmd) {\n          pycmd(\"ans\")\n        } else if (window.showAnswer) {\n          showAnswer()\n        }\n      } else {\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n      }\n      // AnkiMobile JS API doesn't have one for show answer.\n      // Best alternative is to use Taps/Swipes to show answer.\n\n      alreadyRendered = true;\n    }\n\n    function delayedProcessSelective1b1() {\n      if (window.requestAnimationFrame) window.requestAnimationFrame(processSelective1b1); // less flickering\n      else window.setTimeout(processSelective1b1, 0);\n    };\n\n    window.onload = delayedProcessSelective1b1;\n    if (document.readyState === \"complete\") {\n      delayedProcessSelective1b1();\n    }\n    else {\n      document.addEventListener(\"DOMContentLoaded\", delayedProcessSelective1b1);\n    }\n\n    // Observe document.body class changes to trigger re-rendering.\n    // This is useful, because Anki doesn’t always start with an up-to-date class list:\n    // https://forums.ankiweb.net/t/card-card-classes-only-injected-separately-now/27387.\n    const observer = new MutationObserver(function (mutationsList, observer) {\n      for (let mutation of mutationsList) {\n        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {\n          delayedProcessSelective1b1();\n        }\n      }\n    });\n    observer.observe(document.body, { attributes: true });\n  }\n  Persistence.setItem(\"clozeHints\", clozeHints);\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>\n\n\n{{/FunktionCloze3}}{{/FunktionCloze2}}{{/FunktionCloze1}}\n{{/Funktion}}",
      "afmt": "<!-- version f0935e4 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n<div id=\"back\"></div>\n<div id=\"cloze\" data-card=\"{{Card}}\"></div>\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Eigene Notizen & Bilder\": \"Alt + 1\",\n    \"Eigene Prüfungsfragen\": \"Alt + 2\",\n    \"Definitionen\": \"Alt + 3\",\n    \"Merksprüche\": \"Alt + 4\",\n    \"Klinik\": \"Alt + 5\",\n    \"Präparat\": \"Alt + 6\",\n    \"Memes\": \"Alt + 7\",\n    \"linkContainer\": \"Alt + L\",\n    \"Meditricks\": \"Alt + M\",\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Eigene Notizen & Bilder\": false,\n    \"Eigene Prüfungsfragen\": false,\n    \"Definitionen\": false,\n    \"Merksprüche\": false,\n    \"Klinik\": false,\n    \"Präparat\": false,\n    \"Memes\": false,\n    \"linkContainer\": true,\n    \"Meditricks\": false,\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  var revealNextShortcut = \"N\"\n  var revealNextWordShortcut = \"Shift + N\"\n  var toggleAllShortcut = \",\"\n\n  // Enables revealing of next Cloze by simply clicking / tapping anywhere on the card (except the buttons)\n  var revealAnywhere = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // Changes how \"Reveal Next\" and clicking behaves. Either \"cloze\" or \"word\".\n  // \"word\" reveals word by word. \n  var revealNextClozeMode = \"cloze\"\n\n  // Changes how fields with additional information are displayed.\n  // true displays fields with additional information only if all clozes are revealed.\n  var hideAdditional = true;\n  var hideAdditionalButtons = true;\n\n  // What cloze is hidden with\n  var clozeHider = (elem) => \"[&nbsp;_&nbsp;]\"\n  /*\n  You can replace the above line with below examples. '█' or '_' works well for hiding clozes.\n  \n  // Fixed length:\n  var clozeHider = (elem) => \"███\"\n  // Replace each character with \"█\":\n  var clozeHider = (elem) => \"█\".repeat(elem.textContent.length)\n  // Show whitespaces:\n  var clozeHider = (elem) => \"[\" + elem.textContent.split(\" \").map((t) => \"█\".repeat(t.length)).join(\" \") + \"]\"\n  // Color-filled box (doesn't hide images):\n  var clozeHider = (elem) => `<span style=\"background-color: red; color: transparent;\">${elem.innerHTML}</span>`\n  */\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Was ist die <i>Funktion</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div class=\"cloze\"><br>{{Funktion}}</div>\n\n    <!-- ClOZE ONE BY ONE BUTTONS -->\n    <div id=\"onebyone-buttons\" class=\"onebyone\">\n      <br>\n      <button id=\"button-reveal-next\" class=\"button-general button-one-by-one\"\n        onclick=\"revealNextCloze(); event.stopPropagation()\">Reveal Next</button>\n      <button id=\"button-toggle-all\" class=\"button-general button-one-by-one\"\n        onclick=\"toggleAllCloze(); event.stopPropagation()\">Toggle All</button>\n    </div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- BUTTON FIELDS -->\n    {{#Eigene Notizen & Bilder}}\n    <span id=\"hint-zusatz\" class=\"hintBtn\" data-name=\"Eigene Notizen & Bilder\" style=\"display: none;\">\n      <button id=\"button-zusatz\" class=\"button-general\" onclick=\"toggleHintBtn('hint-zusatz'); event.stopPropagation()\">\n        <img src=\"__zusatz.svg\" style=\"height: 10px;\"> Eigene Notizen & Bilder\n      </button>\n      <div dir=\"auto\" id=\"zusatz\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Notizen & Bilder}}</div>\n    </span>\n    {{/Eigene Notizen & Bilder}}\n\n    {{#Eigene Prüfungsfragen}}\n    <span id=\"hint-hammer\" class=\"hintBtn\" data-name=\"Eigene Prüfungsfragen\" style=\"display: none;\">\n      <button id=\"button-hammer\" class=\"button-general\" onclick=\"toggleHintBtn('hint-hammer'); event.stopPropagation()\">\n        <img src=\"__hammer.svg\" style=\"height: 10px;\"> Eigene Prüfungsfragen\n      </button>\n      <div dir=\"auto\" id=\"hammer\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Prüfungsfragen}}</div>\n    </span>\n    {{/Eigene Prüfungsfragen}}\n\n    {{#Definitionen}}\n    <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Definitionen\" style=\"display: none;\">\n      <button id=\"button-definition\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Definitionen\n      </button>\n      <div dir=\"auto\" id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Definitionen}}</div>\n    </span>\n    {{/Definitionen}}\n\n    {{#Merksprüche}}\n    <span id=\"hint-merksprueche\" class=\"hintBtn\" data-name=\"Merksprüche\" style=\"display: none;\">\n      <button id=\"button-merksprueche\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-merksprueche'); event.stopPropagation()\">\n        <img src=\"__merkhilfe.svg\" style=\"height: 10px;\"> Merksprüche\n      </button>\n      <div dir=\"auto\" id=\"merksprueche\" class=\"hints\" style=\"display: none;\">{{edit:Merksprüche}}</div>\n    </span>\n    {{/Merksprüche}}\n\n    {{#Klinik}}\n    <span id=\"hint-klinik\" class=\"hintBtn\" data-name=\"Klinik\" style=\"display: none;\">\n      <button id=\"button-klinik\" class=\"button-general\" onclick=\"toggleHintBtn('hint-klinik'); event.stopPropagation()\">\n        <img src=\"__stethoscope.svg\" style=\"height: 10px;\"> Klinik\n      </button>\n      <div dir=\"auto\" id=\"klinik\" class=\"hints\" style=\"display: none;\">{{edit:Klinik}}</div>\n    </span>\n    {{/Klinik}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-praeparat\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n        </button>\n      </a>\n    </span>\n    {{/Präparat}}\n\n    {{#Virtuelle Mikroskopie}}\n    <span id=\"hint-microscope-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Virtuelle Mikroskopie}}\">\n        <button id=\"button-microscope\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Virtuelle Mikroskopie\n        </button>\n      </a>\n    </span>\n    {{/Virtuelle Mikroskopie}}\n\n    {{#Smart Zoom}}\n    <span id=\"hint-smartzoom-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-smartzoom\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Smart Zoom\n        </button>\n      </a>\n    </span>\n    {{/Smart Zoom}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat\" class=\"hintBtn\" data-name=\"Präparat\" style=\"display: none;\">\n      <button id=\"button-praeparat\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-praeparat'); event.stopPropagation()\">\n        <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n      </button>\n      <div dir=\"auto\" id=\"praeparat\" class=\"hints\" style=\"display: none;\">{{edit:Präparat}}</div>\n    </span>\n    {{/Präparat}}\n\n    {{#Memes}}\n    <span id=\"hint-memes\" class=\"hintBtn\" data-name=\"Memes\" style=\"display: none;\">\n      <button id=\"button-memes\" class=\"button-general\" onclick=\"toggleHintBtn('hint-memes'); event.stopPropagation()\">\n        <img src=\"__sonstiges.svg\" style=\"height: 10px;\"> Memes\n      </button>\n      <div dir=\"auto\" id=\"memes\" class=\"hints\" style=\"display: none;\">{{edit:Memes}}</div>\n    </span>\n    {{/Memes}}\n\n    <!-- LINEBREAKS IF BUTTONS EXIST -->\n    <script>\n      var array = [`{{Eigene Notizen & Bilder}}`, `{{Eigene Prüfungsfragen}}`, `{{Definitionen}}`, `{{Merksprüche}}`, `{{Klinik}}`, `{{Präparat}}`, `{{Memes}}`];\n      var anyistrue = (element) => element;\n      if (array.some(anyistrue)) {\n        document.getElementById(\"linebreaksIfButtons\").innerHTML = \"<br>\";\n      }\n    </script>\n    <div id=\"linebreaksIfButtons\"></div>\n\n    <!-- Extra field -->\n    {{#Extra}}\n    <div id=\"extra\" style=\"display: none;\">\n      <br>{{edit:Extra}}<br><br>\n    </div>\n    {{/Extra}}\n\n    <!-- Image field -->\n    {{#Bild}}\n    <div id=\"image\" style=\"display: none;\">\n      {{edit:Bild}}<br><br></div>\n    {{/Bild}}\n    {{^Bild}}\n    <span id=\"image\" style=\"display: none;\"></span>\n    {{/Bild}}\n    {{#Bild}}\n    <span id=\"hint-image\" style=\"display: none;\">\n      <button id=\"button-image\" class=\"button-general\"\n        onclick=\"var image = document.getElementById('image'); if (image.style.display == 'none') { image.style.display = 'block' } else { image.style.display = 'none' }; event.stopPropagation()\">\n        <img src=\"__image.svg\" style=\"height: 10px;\"> Abbildung\n      </button>\n    </span>\n    {{/Bild}}\n\n    <span id=\"hint-uafi\" class=\"hintBtn\" data-name=\"Ursprung, Ansatz, Verlauf, Funktion, Innervation, Äste\"\n      style=\"display: none;\">\n      <button id=\"button-uafi\" class=\"button-general expanded-button\"\n        onclick=\"toggleHintBtn('hint-uafi'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Weitere Informationen\n      </button>\n      <div id=\"uafi\" class=\"hints\" style=\"display: block;\">\n        <table class=\"uncloze\">\n          {{#Ursprung}}\n          <tr class=\"uafi-element\" id=\"Ursprung\">\n            <td><i>Ursprung</i></td>\n            <td>{{Ursprung}}</td>\n          </tr>\n          {{/Ursprung}}\n          {{#Ansatz}}\n          <tr class=\"uafi-element\" id=\"Ansatz\">\n            <td><i>Ansatz</i></td>\n            <td>{{Ansatz}}</td>\n          </tr>\n          {{/Ansatz}}\n          {{#Verlauf}}\n          <tr class=\"uafi-element\" id=\"Verlauf\">\n            <td><i>Verlauf</i></td>\n            <td>{{Verlauf}}</td>\n          </tr>\n          {{/Verlauf}}\n          {{#Funktion}}\n          <tr class=\"uafi-element\" id=\"Funktion\">\n            <td><i>Funktion</i></td>\n            <td>{{Funktion}}</td>\n          </tr>\n          {{/Funktion}}\n          {{#Innervation}}\n          <tr class=\"uafi-element\" id=\"Innervation\">\n            <td><i>Innervation</i></td>\n            <td>{{Innervation}}</td>\n          </tr>\n          {{/Innervation}}\n          {{#Äste}}\n          <tr class=\"uafi-element\" id=\"Äste\">\n            <td><i>Äste</i></td>\n            <td>{{Äste}}</td>\n          </tr>\n          {{/Äste}}\n        </table>\n      </div>\n\n      <script>\n        // iterate over all uafi-elements and hide only the one\n        // that is equal to the card's answer (i.e., value of {{Card}})\n        var uafiElements = document.getElementsByClassName(\"uafi-element\");\n        for (var i = 0; i < uafiElements.length; i++) {\n          if (((\"{{Card}}\").startsWith(uafiElements[i].id))) {\n            uafiElements[i].remove()\n          }\n        }\n      </script>\n    </span>\n\n    {{#AMBOSS-Link}}\n    <span id=\"hint-amboss\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:AMBOSS-Link}}\">\n        <button id=\"button-amboss\" class=\"button-general\">\n          <img src=\"__amboss.svg\" style=\"height: 10px;\"> AMBOSS&#8203;\n        </button>\n      </a>\n    </span>\n    {{/AMBOSS-Link}}\n\n    {{#Thieme via medici-Link}}\n    <span id=\"hint-thieme\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Thieme via medici-Link}}\">\n        <button id=\"button-thieme\" class=\"button-general\">\n          <img id=\"button-thieme-img\" src=\"__thieme-heart.svg\" style=\"height: 10px;\"> Thieme via medici\n        </button>\n      </a>\n    </span>\n    {{/Thieme via medici-Link}}\n\n    {{#Meditricks}}\n    <span id=\"hint-meditricks\" class=\"hintBtn\" data-name=\"Meditricks\" style=\"display: none;\">\n      <button id=\"button-meditricks\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-meditricks'); event.stopPropagation()\">\n        <img src=\"__meditricks.svg\" style=\"height: 10px;\"> Meditricks\n      </button>\n      <div dir=\"auto\" id=\"meditricks\" class=\"hints\" style=\"display: none;\">{{edit:Meditricks}}</div>\n    </span>\n    {{/Meditricks}}\n\n    {{#weitere Links}}\n    <span id=\"hint-linkcontainer\" class=\"hintBtn\" data-name=\"linkContainer\" style=\"display: none;\">\n      <button id=\"button-linkcontainer\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-linkcontainer'); event.stopPropagation()\">\n        <img src=\"__internet.svg\" style=\"height: 10px;\"> weitere Links\n      </button>\n      <div id=\"linkcontainer\" class=\"hints\" style=\"display: none;\"></div>\n      <span id=\"linkContainerLinks\" style=\"display: none;\">{{edit:weitere Links}}</span>\n    </span>\n    {{/weitere Links}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n  try {\n    for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n      href = link.href\n      text = link.innerText\n\n      const el = document.createElement('a');\n      el.setAttribute('href', link.href);\n\n      const btn = document.createElement('button');\n      btn.classList.add('button-general');\n      btn.classList.add('expanded-button');\n\n      domain = href.replace(/.+\\/\\/|(www|flexikon|register|de|next|com).|\\..+/g, '');\n      domainDict = {\n        \"amboss\": \"__amboss.svg\",\n        \"wikipedia\": \"__wikipedia.svg\",\n        \"doccheck\": \"__doccheck.png\",\n        \"notfallguru\": \"__notfallguru.svg\",\n        \"awmf\": \"__awmf.svg\",\n        \"gelbe-liste\": \"__gelbe-liste.png\",\n        \"embryotox\": \"__embryotox.svg\",\n        \"radiopaedia\": \"__radiopaedia.png\",\n        \"orphanet\": \"__orphanet.png\",\n      }\n      if (domain in domainDict) {\n        icon = domainDict[domain]\n      } else {\n        icon = \"__internet.svg\"\n      }\n\n      const img = document.createElement('img');\n      img.setAttribute('src', icon);\n      img.setAttribute('style', 'height: 10px;');\n\n      btn.appendChild(img);\n      btn.innerHTML = btn.innerHTML + \" \" + text;\n\n      el.appendChild(btn);\n\n      document.getElementById(\"linkcontainer\").appendChild(el)\n    }\n  }\n  catch (err) {\n    console.log(err)\n  }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-uafi\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- AUTOFLIP BACK SCRIPT -->\n<script>\n  // autoflip hides card in front template\n  document.getElementById(\"qa\").style.removeProperty(\"display\")\n</script>\n\n<!-- CLOZE ONE BY ONE SCRIPT -->\n<style>\n  .cloze-replacer:hover {\n    cursor: pointer;\n  }\n\n  .cloze-hidden {\n    display: none;\n  }\n\n  .cloze-replacer .hidden {\n    display: none;\n  }\n\n  #extra.hidden {\n    display: none;\n  }\n</style>\n\n<!--\n Based on the AnKing Notetype, but expanded and modified by phyn.\n Credit to the original authors, except where modified or otherwise indicated.\n-->\n\n<script>\n    (function () {\n      // enables cloze one-by-one even when one-by-one field is empty\n      // minNumberOfClozes is still considered in this case\n      // overridden in importance by selectiveOneByOne\n      var clozeOneByOneEnabled = true;\n\n      // remove the clickAnywhere function from global scope\n      document.documentElement.removeAttribute(\"onclick\")\n\n      // --- CHECK IF ONE BY ONE IS GENERALLY ENABLED FOR THIS NOTE ---\n      var oneByOneFieldNotEmpty = \"{{One by one}}\" !== \"\";\n      try {\n        clozeOneByOneEnabled = alwaysOneByOne || oneByOneFieldNotEmpty;\n      } catch (exception) {\n        console.log(exception)\n      }\n\n      /**\n   * helper functions to show / hide fields containing additional information\n   */\n      const showExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const hideExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const buttonIds = [\n        \"hint-zusatz\",\n        \"hint-definition\",\n        \"hint-hammer\",\n        \"hint-klinik\",\n        \"hint-praeparat\",\n        \"hint-microscope\",\n        \"hint-smartzoom\",\n        \"hint-histotrainer\",\n        \"hint-uafi\",\n        \"hint-merksprueche\",\n        \"hint-memes\",\n        \"hint-image\",\n        \"hint-amboss\",\n        \"hint-thieme\",\n        \"hint-meditricks\",\n        \"hint-linkcontainer\",\n      ];\n\n      const showExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document\n              .getElementById(buttonIds[button])\n              .style.removeProperty(\"display\");\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n      const hideExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document.getElementById(buttonIds[button]).style.display = \"none\";\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n\n      // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n      /**\n       * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n       */\n      const getCardNumber = function () {\n        clz = document.body.className;\n        const regex = /card(\\d+)/gm;\n\n        let clz2;\n        try {\n          clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n        } catch (e) {\n          clz2 = \"\";\n        }\n        const regex2 = /.*?Cloze(\\d+)/gm;\n\n        let m;\n\n        if ((m = regex2.exec(clz2)) !== null) {\n          return m[1];\n        } else if ((m = regex.exec(clz)) !== null) {\n          return m[1];\n        } else {\n          // Should only fire if card is not cloze\n          console.error(\"Cannot find cardN class of body element!\");\n          return \"0\";\n        }\n      }\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (!clozeOneByOneEnabled) {\n        showExtra()\n        showExtraButtons()\n        document.getElementById(\"onebyone-buttons\").style.display = \"none\"\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n        return\n      }\n\n      // Needed for amboss to recognize first word in .cloze-hidden\n      const CLOZE_REPLACER_SEP = \"<span class='hidden'> </span>\"\n\n      const hideAllCloze = function (initial) {\n        let clozes = document.getElementsByClassName(\"cloze\")\n        let count = 0 // hidden cloze count\n        for (const cloze of clozes) {\n          const existingHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n          if (existingHidden) {\n            revealCloze(cloze);\n          }\n          if (cloze.offsetWidth === 0) {\n            continue\n          }\n          const clozeReplacer = document.createElement(\"span\")\n          const clozeHidden = document.createElement(\"span\")\n          clozeReplacer.classList.add(\"cloze-replacer\")\n          clozeHidden.classList.add(\"cloze-hidden\")\n          while (cloze.childNodes.length > 0) {\n            clozeHidden.appendChild(cloze.childNodes[0])\n          }\n          cloze.appendChild(clozeReplacer)\n          cloze.appendChild(clozeHidden)\n\n          var clozeHints = Persistence.getItem(\"clozeHints\");\n          if (clozeHints && clozeHints[count]) {\n            clozeReplacer.classList.add(\"cloze-hint\")\n            clozeReplacer.innerHTML = clozeHints[count] + CLOZE_REPLACER_SEP\n          } else {\n            clozeReplacer.innerHTML = clozeHider(cloze) + CLOZE_REPLACER_SEP\n          }\n          count += 1\n          document.getElementById(\"button-reveal-next\").style.display = \"inline-block\";\n          if (initial) {\n            cloze.addEventListener(\"touchend\", revealClozeClicked)\n            cloze.addEventListener(\"click\", revealClozeClicked)\n            cloze.classList.add(\"one-by-one\");\n          }\n        }\n\n        // Hide #extra until all clozes are shown\n        const extra = document.getElementById(\"extra\");\n        if (extra) {\n          extra.classList.add(\"hidden\");\n        }\n\n        hideExtra();\n        hideExtraButtons();\n        if (revealAnywhere) {\n          document.documentElement.setAttribute(\"onclick\", \"revealNextCloze(); event.stopPropagation()\")\n        }\n\n\n        // Also hide autoReveal fields\n        for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n          const container = document.querySelector(`[data-name=\"${field}\"]`)\n          if (container) {\n            const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n            if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n              // const link = container.getElementsByTagName(\"a\")[0]\n              const button = container.getElementsByTagName(\"button\")[0]\n              const hint = container.getElementsByTagName(\"div\")[0]\n              button.classList.remove(\"expanded-button\")\n              hint.style.display = \"none\"\n              // link.style.display = \"\"\n            }\n          }\n        }\n      }\n\n      const revealCloze = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        cloze.removeChild(clozeReplacer)\n        cloze.removeChild(clozeHidden)\n        while (clozeHidden.childNodes.length > 0) {\n          cloze.appendChild(clozeHidden.childNodes[0])\n        }\n        maybeRevealExtraField()\n      }\n\n      const revealClozeWord = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        let range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundSpace = setRangeEnd(range, clozeHidden, \"beforeFirstSpace\")\n        if (!foundSpace) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        let fragment = range.extractContents()\n        cloze.insertBefore(fragment, clozeReplacer)\n        // Extract whitespaces after word\n        range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundWord = setRangeEnd(range, clozeHidden, \"beforeFirstChar\")\n        if (!foundWord) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        fragment = range.extractContents();\n        cloze.insertBefore(fragment, clozeReplacer)\n        if (!foundWord) {\n          cloze.removeChild(clozeHidden)\n          cloze.removeChild(clozeReplacer)\n          maybeRevealExtraField()\n          return\n        }\n        clozeReplacer.innerHTML = clozeHider(clozeHidden) + CLOZE_REPLACER_SEP\n        if (clozeReplacer.classList.contains(\"cloze-hint\")) [\n          clozeReplacer.classList.remove(\"cloze-hint\")\n        ]\n        maybeRevealExtraField()\n      }\n\n      const revealNextClozeOf = (type) => {\n        const nextHidden = document.querySelectorAll(\".cloze-hidden\")\n        const nextNextHidden = nextHidden.length > 1 ? true : false\n        if (!nextNextHidden) {\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\";\n        }\n        if (!nextHidden) {\n          return\n        }\n        const cloze = clozeElOfClozeHidden(nextHidden[0]);\n        if (type === \"word\") {\n          revealClozeWord(cloze)\n        } else if (type === \"cloze\") {\n          revealCloze(cloze)\n        } else {\n          console.error(\"Invalid type: \" + type)\n        }\n      }\n\n      const revealClozeClicked = function (ev) {\n        let elem = ev.currentTarget\n        if (!ev.altKey && (revealNextClozeMode !== \"word\")) {\n          revealCloze(elem)\n        } else {\n          revealClozeWord(elem)\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      }\n\n      window.revealNextCloze = function () {\n        revealNextClozeOf(revealNextClozeMode)\n      }\n\n      window.toggleAllCloze = function () {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length > 0) {\n          for (const elem of elems) {\n            const cloze = clozeElOfClozeHidden(elem)\n            revealCloze(cloze)\n          }\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\"\n        } else {\n          hideAllCloze(initial = false)\n        }\n      }\n\n      const clozeElOfClozeHidden = (cloze) => {\n        while (!cloze.classList.contains(\"cloze\")) {\n          cloze = cloze.parentElement;\n        }\n        return cloze;\n      }\n\n      const maybeRevealExtraField = () => {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length == 0) {\n          const extra = document.getElementById(\"extra\")\n          if (extra) {\n            extra.classList.remove(\"hidden\")\n          }\n\n          showExtra();\n          showExtraButtons();\n          document.documentElement.removeAttribute(\"onclick\")\n\n          // Also reveal autoReveal fields\n          for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n            const container = document.querySelector(`[data-name=\"${field}\"]`)\n            if (container) {\n              const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n              if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n                // const link = container.getElementsByTagName(\"a\")[0]\n                const button = container.getElementsByTagName(\"button\")[0]\n                const hint = container.getElementsByTagName(\"div\")[0]\n                button.classList.add(\"expanded-button\")\n                hint.style.display = \"block\"\n                // link.style.display = \"none\"\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * mode: 'beforeFirstSpace' or 'beforeFirstChar'\n       * Return `true` if it exists and setEnd() was called, otherwise `false`\n       */\n      const setRangeEnd = function (range, node, mode) {\n        if (node.nodeType === Node.TEXT_NODE) {\n          const regex = mode === 'beforeFirstSpace' ? /\\s/ : /\\S/\n          const match = node.textContent.match(regex)\n          if (match) {\n            if (match.index === 0) {\n              while (node.previousSibling === null) {\n                node = node.parentElement\n              }\n              range.setEndBefore(node)\n            } else {\n              range.setEnd(node, match.index);\n            }\n            return true;\n          } else {\n            return false;\n          }\n        } else if (mode === 'beforeFirstChar' && isCharNode(node)) {\n          range.setEndBefore(node)\n          return true\n        } else if (!ignoreSpaceInNode(node)) {\n          for (const child of node.childNodes) {\n            if (setRangeEnd(range, child, mode)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }\n\n      const ignoreSpaceInNode = function (node) {\n        return node.tagName === \"MJX-ASSISTIVE-MML\"\n      }\n\n      const isCharNode = function (node) {\n        return [\"IMG\", \"MJX-CONTAINER\"].includes(node.tagName)\n      }\n\n      hideAllCloze(initial = true)\n\n      let isShowNextShortcut = shortcutMatcher(window.revealNextShortcut)\n      let isShowWordShortcut = shortcutMatcher(window.revealNextWordShortcut)\n      let isToggleAllShortcut = shortcutMatcher(window.toggleAllShortcut)\n      ankingAddEventListener(\"keydown\", (ev) => {\n        let next = isShowNextShortcut(ev)\n        let word = isShowWordShortcut(ev)\n        let all = isToggleAllShortcut(ev)\n        if (next) {\n          revealNextClozeOf(\"cloze\")\n        } else if (word) {\n          revealNextClozeOf(\"word\")\n        } else if (all) {\n          toggleAllCloze()\n        } else {\n          return;\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      });\n    })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- MEDITRICKS SNIPPETS DATA -->\n<div id=\"meditricks-mtsp-values\" style=\"display:none;\">\n  <div id=\"meditricks-mtsp-nfname\">_meditricks_nf_v1000_ankizin</div>\n  <div id=\"meditricks-mtsp-nid\">{{Note ID}}</div>\n</div>\n<script src=\"_meditricks_mtsp_scripts_v1000_ankizin.js\"></script>\n<link href=\"_meditricks_mtsp_styles_v1000_ankizin.css\" rel=\"stylesheet\" />\n\n<!-- include \"_meditricks_mtsp_nf_v1000_ankizin.js\" -->\n<!-- include \"_meditricks_mtsp_scripts_v1000_iframe.map\" -->\n<!-- include \"_meditricks_mtsp_mtlogo.webp\" -->\n<!-- include \"_meditricks_mtsp_mt-loading.png\" -->\n<!-- include \"_meditricks_mtsp_mt-loading_night.png\" -->\n\n<!-- //MEDITRICKS SNIPPETS DATA -->\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>",
      "bqfmt": "{{Muskel / Leitungsbahn}}",
      "bafmt": "{{Funktion}}",
      "did": null,
      "bfont": "Helvetica",
      "bsize": 12
    },
    {
      "name": "Innervation",
      "ord": 4,
      "qfmt": "<!-- version f0935e4 -->\n{{#Innervation}}\n{{^InnervationCloze1}}{{^InnervationCloze2}}{{^InnervationCloze3}}\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n<div id=\"cloze\" data-card=\"{{Card}}\"></div>\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TIMER CONFIG  ##############\n  // Timer config (timer length, timer finished message)\n  var minutes = 0\n  var seconds = 15\n  var timeOverMsg = \"<span style='color:#CC5B5B'>!!!</span>\"\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  // Auto flip to back when One by one mode.\n  var autoflip = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Was ist die <i>Innervation</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\"></div>\n\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<script>\n  //DONT FADE BETWEEN CARDS\n  qFade = 0;\n  if (typeof anki !== 'undefined') anki.qFade = qFade;\n</script>\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    if (!indentation) { return; }\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- CLOZE ONE BY ONE FRONT -->\n<div id=\"one-by-one\" style=\"display: none;\"></div>\n\n<script>\n  /**\n   * Based on the AnKing Notetype, but expanded and modified by phyn.\n   * Credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  Persistence.clear();\n\n  // check if OneByOne is generally enabled for this card\n  var oneByOneFieldEmpty = selectiveOneByOne ? \"{{One by one}}\" === \"\" : true;\n  var clozeOneByOneEnabled = alwaysOneByOne ? true : !oneByOneFieldEmpty;\n\n  // avoid flickering. Must unset this in the back.\n  document.getElementById(\"qa\").style.display = \"none\";\n  var clozeHints = [];\n\n  if (clozeOneByOneEnabled) {\n    // collect hints from front side (independent of whether or not OneByOne is enabled)\n    document.getElementById(\"qa\").classList.add('one-by-one');\n    // Save cloze hints to display in the back\n    var clozes = document.getElementsByClassName(\"cloze\")\n    for (var i = 0; i < clozes.length; i++) {\n      clozes[i].classList.add(\"one-by-one\");\n      if (clozes[i].innerHTML === \"[...]\") {\n        clozeHints.push(\"\")\n      } else {\n        clozeHints.push(clozes[i].innerHTML)\n      }\n    }\n\n    // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n    /**\n     * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n     */\n    const getCardNumber = function () {\n      clz = document.body.className;\n      const regex = /card(\\d+)/gm;\n\n      let clz2;\n      try {\n        clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n      } catch (e) {\n        clz2 = \"\";\n      }\n      const regex2 = /.*?Cloze(\\d+)/gm;\n\n      let m;\n\n      if ((m = regex2.exec(clz2)) !== null) {\n        return m[1];\n      } else if ((m = regex.exec(clz)) !== null) {\n        return m[1];\n      } else {\n        // Should only fire if card is not cloze\n        console.error(\"Cannot find cardN class of body element!\");\n        return \"0\";\n      }\n    }\n\n    var alreadyRendered = false;\n\n    function processSelective1b1() {\n      if (alreadyRendered) return;\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (autoflip && clozeOneByOneEnabled) {\n        if (window.pycmd || window.showAnswer) {\n          // avoid flickering. Must unset this in the back.\n          document.getElementById(\"qa\").style.display = \"none\";\n        }\n        if (window.pycmd) {\n          pycmd(\"ans\")\n        } else if (window.showAnswer) {\n          showAnswer()\n        }\n      } else {\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n      }\n      // AnkiMobile JS API doesn't have one for show answer.\n      // Best alternative is to use Taps/Swipes to show answer.\n\n      alreadyRendered = true;\n    }\n\n    function delayedProcessSelective1b1() {\n      if (window.requestAnimationFrame) window.requestAnimationFrame(processSelective1b1); // less flickering\n      else window.setTimeout(processSelective1b1, 0);\n    };\n\n    window.onload = delayedProcessSelective1b1;\n    if (document.readyState === \"complete\") {\n      delayedProcessSelective1b1();\n    }\n    else {\n      document.addEventListener(\"DOMContentLoaded\", delayedProcessSelective1b1);\n    }\n\n    // Observe document.body class changes to trigger re-rendering.\n    // This is useful, because Anki doesn’t always start with an up-to-date class list:\n    // https://forums.ankiweb.net/t/card-card-classes-only-injected-separately-now/27387.\n    const observer = new MutationObserver(function (mutationsList, observer) {\n      for (let mutation of mutationsList) {\n        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {\n          delayedProcessSelective1b1();\n        }\n      }\n    });\n    observer.observe(document.body, { attributes: true });\n  }\n  Persistence.setItem(\"clozeHints\", clozeHints);\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>\n\n\n{{/InnervationCloze3}}{{/InnervationCloze2}}{{/InnervationCloze1}}\n{{/Innervation}}",
      "afmt": "<!-- version f0935e4 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n<div id=\"back\"></div>\n<div id=\"cloze\" data-card=\"{{Card}}\"></div>\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Eigene Notizen & Bilder\": \"Alt + 1\",\n    \"Eigene Prüfungsfragen\": \"Alt + 2\",\n    \"Definitionen\": \"Alt + 3\",\n    \"Merksprüche\": \"Alt + 4\",\n    \"Klinik\": \"Alt + 5\",\n    \"Präparat\": \"Alt + 6\",\n    \"Memes\": \"Alt + 7\",\n    \"linkContainer\": \"Alt + L\",\n    \"Meditricks\": \"Alt + M\",\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Eigene Notizen & Bilder\": false,\n    \"Eigene Prüfungsfragen\": false,\n    \"Definitionen\": false,\n    \"Merksprüche\": false,\n    \"Klinik\": false,\n    \"Präparat\": false,\n    \"Memes\": false,\n    \"linkContainer\": true,\n    \"Meditricks\": false,\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  var revealNextShortcut = \"N\"\n  var revealNextWordShortcut = \"Shift + N\"\n  var toggleAllShortcut = \",\"\n\n  // Enables revealing of next Cloze by simply clicking / tapping anywhere on the card (except the buttons)\n  var revealAnywhere = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // Changes how \"Reveal Next\" and clicking behaves. Either \"cloze\" or \"word\".\n  // \"word\" reveals word by word. \n  var revealNextClozeMode = \"cloze\"\n\n  // Changes how fields with additional information are displayed.\n  // true displays fields with additional information only if all clozes are revealed.\n  var hideAdditional = true;\n  var hideAdditionalButtons = true;\n\n  // What cloze is hidden with\n  var clozeHider = (elem) => \"[&nbsp;_&nbsp;]\"\n  /*\n  You can replace the above line with below examples. '█' or '_' works well for hiding clozes.\n  \n  // Fixed length:\n  var clozeHider = (elem) => \"███\"\n  // Replace each character with \"█\":\n  var clozeHider = (elem) => \"█\".repeat(elem.textContent.length)\n  // Show whitespaces:\n  var clozeHider = (elem) => \"[\" + elem.textContent.split(\" \").map((t) => \"█\".repeat(t.length)).join(\" \") + \"]\"\n  // Color-filled box (doesn't hide images):\n  var clozeHider = (elem) => `<span style=\"background-color: red; color: transparent;\">${elem.innerHTML}</span>`\n  */\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Was ist die <i>Innervation</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div class=\"cloze\"><br>{{Innervation}}</div>\n\n    <!-- ClOZE ONE BY ONE BUTTONS -->\n    <div id=\"onebyone-buttons\" class=\"onebyone\">\n      <br>\n      <button id=\"button-reveal-next\" class=\"button-general button-one-by-one\"\n        onclick=\"revealNextCloze(); event.stopPropagation()\">Reveal Next</button>\n      <button id=\"button-toggle-all\" class=\"button-general button-one-by-one\"\n        onclick=\"toggleAllCloze(); event.stopPropagation()\">Toggle All</button>\n    </div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- BUTTON FIELDS -->\n    {{#Eigene Notizen & Bilder}}\n    <span id=\"hint-zusatz\" class=\"hintBtn\" data-name=\"Eigene Notizen & Bilder\" style=\"display: none;\">\n      <button id=\"button-zusatz\" class=\"button-general\" onclick=\"toggleHintBtn('hint-zusatz'); event.stopPropagation()\">\n        <img src=\"__zusatz.svg\" style=\"height: 10px;\"> Eigene Notizen & Bilder\n      </button>\n      <div dir=\"auto\" id=\"zusatz\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Notizen & Bilder}}</div>\n    </span>\n    {{/Eigene Notizen & Bilder}}\n\n    {{#Eigene Prüfungsfragen}}\n    <span id=\"hint-hammer\" class=\"hintBtn\" data-name=\"Eigene Prüfungsfragen\" style=\"display: none;\">\n      <button id=\"button-hammer\" class=\"button-general\" onclick=\"toggleHintBtn('hint-hammer'); event.stopPropagation()\">\n        <img src=\"__hammer.svg\" style=\"height: 10px;\"> Eigene Prüfungsfragen\n      </button>\n      <div dir=\"auto\" id=\"hammer\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Prüfungsfragen}}</div>\n    </span>\n    {{/Eigene Prüfungsfragen}}\n\n    {{#Definitionen}}\n    <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Definitionen\" style=\"display: none;\">\n      <button id=\"button-definition\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Definitionen\n      </button>\n      <div dir=\"auto\" id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Definitionen}}</div>\n    </span>\n    {{/Definitionen}}\n\n    {{#Merksprüche}}\n    <span id=\"hint-merksprueche\" class=\"hintBtn\" data-name=\"Merksprüche\" style=\"display: none;\">\n      <button id=\"button-merksprueche\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-merksprueche'); event.stopPropagation()\">\n        <img src=\"__merkhilfe.svg\" style=\"height: 10px;\"> Merksprüche\n      </button>\n      <div dir=\"auto\" id=\"merksprueche\" class=\"hints\" style=\"display: none;\">{{edit:Merksprüche}}</div>\n    </span>\n    {{/Merksprüche}}\n\n    {{#Klinik}}\n    <span id=\"hint-klinik\" class=\"hintBtn\" data-name=\"Klinik\" style=\"display: none;\">\n      <button id=\"button-klinik\" class=\"button-general\" onclick=\"toggleHintBtn('hint-klinik'); event.stopPropagation()\">\n        <img src=\"__stethoscope.svg\" style=\"height: 10px;\"> Klinik\n      </button>\n      <div dir=\"auto\" id=\"klinik\" class=\"hints\" style=\"display: none;\">{{edit:Klinik}}</div>\n    </span>\n    {{/Klinik}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-praeparat\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n        </button>\n      </a>\n    </span>\n    {{/Präparat}}\n\n    {{#Virtuelle Mikroskopie}}\n    <span id=\"hint-microscope-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Virtuelle Mikroskopie}}\">\n        <button id=\"button-microscope\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Virtuelle Mikroskopie\n        </button>\n      </a>\n    </span>\n    {{/Virtuelle Mikroskopie}}\n\n    {{#Smart Zoom}}\n    <span id=\"hint-smartzoom-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-smartzoom\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Smart Zoom\n        </button>\n      </a>\n    </span>\n    {{/Smart Zoom}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat\" class=\"hintBtn\" data-name=\"Präparat\" style=\"display: none;\">\n      <button id=\"button-praeparat\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-praeparat'); event.stopPropagation()\">\n        <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n      </button>\n      <div dir=\"auto\" id=\"praeparat\" class=\"hints\" style=\"display: none;\">{{edit:Präparat}}</div>\n    </span>\n    {{/Präparat}}\n\n    {{#Memes}}\n    <span id=\"hint-memes\" class=\"hintBtn\" data-name=\"Memes\" style=\"display: none;\">\n      <button id=\"button-memes\" class=\"button-general\" onclick=\"toggleHintBtn('hint-memes'); event.stopPropagation()\">\n        <img src=\"__sonstiges.svg\" style=\"height: 10px;\"> Memes\n      </button>\n      <div dir=\"auto\" id=\"memes\" class=\"hints\" style=\"display: none;\">{{edit:Memes}}</div>\n    </span>\n    {{/Memes}}\n\n    <!-- LINEBREAKS IF BUTTONS EXIST -->\n    <script>\n      var array = [`{{Eigene Notizen & Bilder}}`, `{{Eigene Prüfungsfragen}}`, `{{Definitionen}}`, `{{Merksprüche}}`, `{{Klinik}}`, `{{Präparat}}`, `{{Memes}}`];\n      var anyistrue = (element) => element;\n      if (array.some(anyistrue)) {\n        document.getElementById(\"linebreaksIfButtons\").innerHTML = \"<br>\";\n      }\n    </script>\n    <div id=\"linebreaksIfButtons\"></div>\n\n    <!-- Extra field -->\n    {{#Extra}}\n    <div id=\"extra\" style=\"display: none;\">\n      <br>{{edit:Extra}}<br><br>\n    </div>\n    {{/Extra}}\n\n    <!-- Image field -->\n    {{#Bild}}\n    <div id=\"image\" style=\"display: none;\">\n      {{edit:Bild}}<br><br></div>\n    {{/Bild}}\n    {{^Bild}}\n    <span id=\"image\" style=\"display: none;\"></span>\n    {{/Bild}}\n    {{#Bild}}\n    <span id=\"hint-image\" style=\"display: none;\">\n      <button id=\"button-image\" class=\"button-general\"\n        onclick=\"var image = document.getElementById('image'); if (image.style.display == 'none') { image.style.display = 'block' } else { image.style.display = 'none' }; event.stopPropagation()\">\n        <img src=\"__image.svg\" style=\"height: 10px;\"> Abbildung\n      </button>\n    </span>\n    {{/Bild}}\n\n    <span id=\"hint-uafi\" class=\"hintBtn\" data-name=\"Ursprung, Ansatz, Verlauf, Funktion, Innervation, Äste\"\n      style=\"display: none;\">\n      <button id=\"button-uafi\" class=\"button-general expanded-button\"\n        onclick=\"toggleHintBtn('hint-uafi'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Weitere Informationen\n      </button>\n      <div id=\"uafi\" class=\"hints\" style=\"display: block;\">\n        <table class=\"uncloze\">\n          {{#Ursprung}}\n          <tr class=\"uafi-element\" id=\"Ursprung\">\n            <td><i>Ursprung</i></td>\n            <td>{{Ursprung}}</td>\n          </tr>\n          {{/Ursprung}}\n          {{#Ansatz}}\n          <tr class=\"uafi-element\" id=\"Ansatz\">\n            <td><i>Ansatz</i></td>\n            <td>{{Ansatz}}</td>\n          </tr>\n          {{/Ansatz}}\n          {{#Verlauf}}\n          <tr class=\"uafi-element\" id=\"Verlauf\">\n            <td><i>Verlauf</i></td>\n            <td>{{Verlauf}}</td>\n          </tr>\n          {{/Verlauf}}\n          {{#Funktion}}\n          <tr class=\"uafi-element\" id=\"Funktion\">\n            <td><i>Funktion</i></td>\n            <td>{{Funktion}}</td>\n          </tr>\n          {{/Funktion}}\n          {{#Innervation}}\n          <tr class=\"uafi-element\" id=\"Innervation\">\n            <td><i>Innervation</i></td>\n            <td>{{Innervation}}</td>\n          </tr>\n          {{/Innervation}}\n          {{#Äste}}\n          <tr class=\"uafi-element\" id=\"Äste\">\n            <td><i>Äste</i></td>\n            <td>{{Äste}}</td>\n          </tr>\n          {{/Äste}}\n        </table>\n      </div>\n\n      <script>\n        // iterate over all uafi-elements and hide only the one\n        // that is equal to the card's answer (i.e., value of {{Card}})\n        var uafiElements = document.getElementsByClassName(\"uafi-element\");\n        for (var i = 0; i < uafiElements.length; i++) {\n          if (((\"{{Card}}\").startsWith(uafiElements[i].id))) {\n            uafiElements[i].remove()\n          }\n        }\n      </script>\n    </span>\n\n    {{#AMBOSS-Link}}\n    <span id=\"hint-amboss\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:AMBOSS-Link}}\">\n        <button id=\"button-amboss\" class=\"button-general\">\n          <img src=\"__amboss.svg\" style=\"height: 10px;\"> AMBOSS&#8203;\n        </button>\n      </a>\n    </span>\n    {{/AMBOSS-Link}}\n\n    {{#Thieme via medici-Link}}\n    <span id=\"hint-thieme\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Thieme via medici-Link}}\">\n        <button id=\"button-thieme\" class=\"button-general\">\n          <img id=\"button-thieme-img\" src=\"__thieme-heart.svg\" style=\"height: 10px;\"> Thieme via medici\n        </button>\n      </a>\n    </span>\n    {{/Thieme via medici-Link}}\n\n    {{#Meditricks}}\n    <span id=\"hint-meditricks\" class=\"hintBtn\" data-name=\"Meditricks\" style=\"display: none;\">\n      <button id=\"button-meditricks\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-meditricks'); event.stopPropagation()\">\n        <img src=\"__meditricks.svg\" style=\"height: 10px;\"> Meditricks\n      </button>\n      <div dir=\"auto\" id=\"meditricks\" class=\"hints\" style=\"display: none;\">{{edit:Meditricks}}</div>\n    </span>\n    {{/Meditricks}}\n\n    {{#weitere Links}}\n    <span id=\"hint-linkcontainer\" class=\"hintBtn\" data-name=\"linkContainer\" style=\"display: none;\">\n      <button id=\"button-linkcontainer\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-linkcontainer'); event.stopPropagation()\">\n        <img src=\"__internet.svg\" style=\"height: 10px;\"> weitere Links\n      </button>\n      <div id=\"linkcontainer\" class=\"hints\" style=\"display: none;\"></div>\n      <span id=\"linkContainerLinks\" style=\"display: none;\">{{edit:weitere Links}}</span>\n    </span>\n    {{/weitere Links}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n  try {\n    for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n      href = link.href\n      text = link.innerText\n\n      const el = document.createElement('a');\n      el.setAttribute('href', link.href);\n\n      const btn = document.createElement('button');\n      btn.classList.add('button-general');\n      btn.classList.add('expanded-button');\n\n      domain = href.replace(/.+\\/\\/|(www|flexikon|register|de|next|com).|\\..+/g, '');\n      domainDict = {\n        \"amboss\": \"__amboss.svg\",\n        \"wikipedia\": \"__wikipedia.svg\",\n        \"doccheck\": \"__doccheck.png\",\n        \"notfallguru\": \"__notfallguru.svg\",\n        \"awmf\": \"__awmf.svg\",\n        \"gelbe-liste\": \"__gelbe-liste.png\",\n        \"embryotox\": \"__embryotox.svg\",\n        \"radiopaedia\": \"__radiopaedia.png\",\n        \"orphanet\": \"__orphanet.png\",\n      }\n      if (domain in domainDict) {\n        icon = domainDict[domain]\n      } else {\n        icon = \"__internet.svg\"\n      }\n\n      const img = document.createElement('img');\n      img.setAttribute('src', icon);\n      img.setAttribute('style', 'height: 10px;');\n\n      btn.appendChild(img);\n      btn.innerHTML = btn.innerHTML + \" \" + text;\n\n      el.appendChild(btn);\n\n      document.getElementById(\"linkcontainer\").appendChild(el)\n    }\n  }\n  catch (err) {\n    console.log(err)\n  }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-uafi\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- AUTOFLIP BACK SCRIPT -->\n<script>\n  // autoflip hides card in front template\n  document.getElementById(\"qa\").style.removeProperty(\"display\")\n</script>\n\n<!-- CLOZE ONE BY ONE SCRIPT -->\n<style>\n  .cloze-replacer:hover {\n    cursor: pointer;\n  }\n\n  .cloze-hidden {\n    display: none;\n  }\n\n  .cloze-replacer .hidden {\n    display: none;\n  }\n\n  #extra.hidden {\n    display: none;\n  }\n</style>\n\n<!--\n Based on the AnKing Notetype, but expanded and modified by phyn.\n Credit to the original authors, except where modified or otherwise indicated.\n-->\n\n<script>\n    (function () {\n      // enables cloze one-by-one even when one-by-one field is empty\n      // minNumberOfClozes is still considered in this case\n      // overridden in importance by selectiveOneByOne\n      var clozeOneByOneEnabled = true;\n\n      // remove the clickAnywhere function from global scope\n      document.documentElement.removeAttribute(\"onclick\")\n\n      // --- CHECK IF ONE BY ONE IS GENERALLY ENABLED FOR THIS NOTE ---\n      var oneByOneFieldNotEmpty = \"{{One by one}}\" !== \"\";\n      try {\n        clozeOneByOneEnabled = alwaysOneByOne || oneByOneFieldNotEmpty;\n      } catch (exception) {\n        console.log(exception)\n      }\n\n      /**\n   * helper functions to show / hide fields containing additional information\n   */\n      const showExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const hideExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const buttonIds = [\n        \"hint-zusatz\",\n        \"hint-definition\",\n        \"hint-hammer\",\n        \"hint-klinik\",\n        \"hint-praeparat\",\n        \"hint-microscope\",\n        \"hint-smartzoom\",\n        \"hint-histotrainer\",\n        \"hint-uafi\",\n        \"hint-merksprueche\",\n        \"hint-memes\",\n        \"hint-image\",\n        \"hint-amboss\",\n        \"hint-thieme\",\n        \"hint-meditricks\",\n        \"hint-linkcontainer\",\n      ];\n\n      const showExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document\n              .getElementById(buttonIds[button])\n              .style.removeProperty(\"display\");\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n      const hideExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document.getElementById(buttonIds[button]).style.display = \"none\";\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n\n      // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n      /**\n       * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n       */\n      const getCardNumber = function () {\n        clz = document.body.className;\n        const regex = /card(\\d+)/gm;\n\n        let clz2;\n        try {\n          clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n        } catch (e) {\n          clz2 = \"\";\n        }\n        const regex2 = /.*?Cloze(\\d+)/gm;\n\n        let m;\n\n        if ((m = regex2.exec(clz2)) !== null) {\n          return m[1];\n        } else if ((m = regex.exec(clz)) !== null) {\n          return m[1];\n        } else {\n          // Should only fire if card is not cloze\n          console.error(\"Cannot find cardN class of body element!\");\n          return \"0\";\n        }\n      }\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (!clozeOneByOneEnabled) {\n        showExtra()\n        showExtraButtons()\n        document.getElementById(\"onebyone-buttons\").style.display = \"none\"\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n        return\n      }\n\n      // Needed for amboss to recognize first word in .cloze-hidden\n      const CLOZE_REPLACER_SEP = \"<span class='hidden'> </span>\"\n\n      const hideAllCloze = function (initial) {\n        let clozes = document.getElementsByClassName(\"cloze\")\n        let count = 0 // hidden cloze count\n        for (const cloze of clozes) {\n          const existingHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n          if (existingHidden) {\n            revealCloze(cloze);\n          }\n          if (cloze.offsetWidth === 0) {\n            continue\n          }\n          const clozeReplacer = document.createElement(\"span\")\n          const clozeHidden = document.createElement(\"span\")\n          clozeReplacer.classList.add(\"cloze-replacer\")\n          clozeHidden.classList.add(\"cloze-hidden\")\n          while (cloze.childNodes.length > 0) {\n            clozeHidden.appendChild(cloze.childNodes[0])\n          }\n          cloze.appendChild(clozeReplacer)\n          cloze.appendChild(clozeHidden)\n\n          var clozeHints = Persistence.getItem(\"clozeHints\");\n          if (clozeHints && clozeHints[count]) {\n            clozeReplacer.classList.add(\"cloze-hint\")\n            clozeReplacer.innerHTML = clozeHints[count] + CLOZE_REPLACER_SEP\n          } else {\n            clozeReplacer.innerHTML = clozeHider(cloze) + CLOZE_REPLACER_SEP\n          }\n          count += 1\n          document.getElementById(\"button-reveal-next\").style.display = \"inline-block\";\n          if (initial) {\n            cloze.addEventListener(\"touchend\", revealClozeClicked)\n            cloze.addEventListener(\"click\", revealClozeClicked)\n            cloze.classList.add(\"one-by-one\");\n          }\n        }\n\n        // Hide #extra until all clozes are shown\n        const extra = document.getElementById(\"extra\");\n        if (extra) {\n          extra.classList.add(\"hidden\");\n        }\n\n        hideExtra();\n        hideExtraButtons();\n        if (revealAnywhere) {\n          document.documentElement.setAttribute(\"onclick\", \"revealNextCloze(); event.stopPropagation()\")\n        }\n\n\n        // Also hide autoReveal fields\n        for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n          const container = document.querySelector(`[data-name=\"${field}\"]`)\n          if (container) {\n            const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n            if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n              // const link = container.getElementsByTagName(\"a\")[0]\n              const button = container.getElementsByTagName(\"button\")[0]\n              const hint = container.getElementsByTagName(\"div\")[0]\n              button.classList.remove(\"expanded-button\")\n              hint.style.display = \"none\"\n              // link.style.display = \"\"\n            }\n          }\n        }\n      }\n\n      const revealCloze = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        cloze.removeChild(clozeReplacer)\n        cloze.removeChild(clozeHidden)\n        while (clozeHidden.childNodes.length > 0) {\n          cloze.appendChild(clozeHidden.childNodes[0])\n        }\n        maybeRevealExtraField()\n      }\n\n      const revealClozeWord = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        let range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundSpace = setRangeEnd(range, clozeHidden, \"beforeFirstSpace\")\n        if (!foundSpace) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        let fragment = range.extractContents()\n        cloze.insertBefore(fragment, clozeReplacer)\n        // Extract whitespaces after word\n        range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundWord = setRangeEnd(range, clozeHidden, \"beforeFirstChar\")\n        if (!foundWord) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        fragment = range.extractContents();\n        cloze.insertBefore(fragment, clozeReplacer)\n        if (!foundWord) {\n          cloze.removeChild(clozeHidden)\n          cloze.removeChild(clozeReplacer)\n          maybeRevealExtraField()\n          return\n        }\n        clozeReplacer.innerHTML = clozeHider(clozeHidden) + CLOZE_REPLACER_SEP\n        if (clozeReplacer.classList.contains(\"cloze-hint\")) [\n          clozeReplacer.classList.remove(\"cloze-hint\")\n        ]\n        maybeRevealExtraField()\n      }\n\n      const revealNextClozeOf = (type) => {\n        const nextHidden = document.querySelectorAll(\".cloze-hidden\")\n        const nextNextHidden = nextHidden.length > 1 ? true : false\n        if (!nextNextHidden) {\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\";\n        }\n        if (!nextHidden) {\n          return\n        }\n        const cloze = clozeElOfClozeHidden(nextHidden[0]);\n        if (type === \"word\") {\n          revealClozeWord(cloze)\n        } else if (type === \"cloze\") {\n          revealCloze(cloze)\n        } else {\n          console.error(\"Invalid type: \" + type)\n        }\n      }\n\n      const revealClozeClicked = function (ev) {\n        let elem = ev.currentTarget\n        if (!ev.altKey && (revealNextClozeMode !== \"word\")) {\n          revealCloze(elem)\n        } else {\n          revealClozeWord(elem)\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      }\n\n      window.revealNextCloze = function () {\n        revealNextClozeOf(revealNextClozeMode)\n      }\n\n      window.toggleAllCloze = function () {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length > 0) {\n          for (const elem of elems) {\n            const cloze = clozeElOfClozeHidden(elem)\n            revealCloze(cloze)\n          }\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\"\n        } else {\n          hideAllCloze(initial = false)\n        }\n      }\n\n      const clozeElOfClozeHidden = (cloze) => {\n        while (!cloze.classList.contains(\"cloze\")) {\n          cloze = cloze.parentElement;\n        }\n        return cloze;\n      }\n\n      const maybeRevealExtraField = () => {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length == 0) {\n          const extra = document.getElementById(\"extra\")\n          if (extra) {\n            extra.classList.remove(\"hidden\")\n          }\n\n          showExtra();\n          showExtraButtons();\n          document.documentElement.removeAttribute(\"onclick\")\n\n          // Also reveal autoReveal fields\n          for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n            const container = document.querySelector(`[data-name=\"${field}\"]`)\n            if (container) {\n              const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n              if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n                // const link = container.getElementsByTagName(\"a\")[0]\n                const button = container.getElementsByTagName(\"button\")[0]\n                const hint = container.getElementsByTagName(\"div\")[0]\n                button.classList.add(\"expanded-button\")\n                hint.style.display = \"block\"\n                // link.style.display = \"none\"\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * mode: 'beforeFirstSpace' or 'beforeFirstChar'\n       * Return `true` if it exists and setEnd() was called, otherwise `false`\n       */\n      const setRangeEnd = function (range, node, mode) {\n        if (node.nodeType === Node.TEXT_NODE) {\n          const regex = mode === 'beforeFirstSpace' ? /\\s/ : /\\S/\n          const match = node.textContent.match(regex)\n          if (match) {\n            if (match.index === 0) {\n              while (node.previousSibling === null) {\n                node = node.parentElement\n              }\n              range.setEndBefore(node)\n            } else {\n              range.setEnd(node, match.index);\n            }\n            return true;\n          } else {\n            return false;\n          }\n        } else if (mode === 'beforeFirstChar' && isCharNode(node)) {\n          range.setEndBefore(node)\n          return true\n        } else if (!ignoreSpaceInNode(node)) {\n          for (const child of node.childNodes) {\n            if (setRangeEnd(range, child, mode)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }\n\n      const ignoreSpaceInNode = function (node) {\n        return node.tagName === \"MJX-ASSISTIVE-MML\"\n      }\n\n      const isCharNode = function (node) {\n        return [\"IMG\", \"MJX-CONTAINER\"].includes(node.tagName)\n      }\n\n      hideAllCloze(initial = true)\n\n      let isShowNextShortcut = shortcutMatcher(window.revealNextShortcut)\n      let isShowWordShortcut = shortcutMatcher(window.revealNextWordShortcut)\n      let isToggleAllShortcut = shortcutMatcher(window.toggleAllShortcut)\n      ankingAddEventListener(\"keydown\", (ev) => {\n        let next = isShowNextShortcut(ev)\n        let word = isShowWordShortcut(ev)\n        let all = isToggleAllShortcut(ev)\n        if (next) {\n          revealNextClozeOf(\"cloze\")\n        } else if (word) {\n          revealNextClozeOf(\"word\")\n        } else if (all) {\n          toggleAllCloze()\n        } else {\n          return;\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      });\n    })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- MEDITRICKS SNIPPETS DATA -->\n<div id=\"meditricks-mtsp-values\" style=\"display:none;\">\n  <div id=\"meditricks-mtsp-nfname\">_meditricks_nf_v1000_ankizin</div>\n  <div id=\"meditricks-mtsp-nid\">{{Note ID}}</div>\n</div>\n<script src=\"_meditricks_mtsp_scripts_v1000_ankizin.js\"></script>\n<link href=\"_meditricks_mtsp_styles_v1000_ankizin.css\" rel=\"stylesheet\" />\n\n<!-- include \"_meditricks_mtsp_nf_v1000_ankizin.js\" -->\n<!-- include \"_meditricks_mtsp_scripts_v1000_iframe.map\" -->\n<!-- include \"_meditricks_mtsp_mtlogo.webp\" -->\n<!-- include \"_meditricks_mtsp_mt-loading.png\" -->\n<!-- include \"_meditricks_mtsp_mt-loading_night.png\" -->\n\n<!-- //MEDITRICKS SNIPPETS DATA -->\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>",
      "bqfmt": "{{Muskel / Leitungsbahn}}",
      "bafmt": "{{Innervation}}",
      "did": null,
      "bfont": "Helvetica",
      "bsize": 12
    },
    {
      "name": "Äste",
      "ord": 5,
      "qfmt": "<!-- version f0935e4 -->\n{{#Äste}}\n{{^ÄsteCloze1}}{{^ÄsteCloze2}}{{^ÄsteCloze3}}\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n<div id=\"cloze\" data-card=\"{{Card}}\"></div>\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TIMER CONFIG  ##############\n  // Timer config (timer length, timer finished message)\n  var minutes = 0\n  var seconds = 15\n  var timeOverMsg = \"<span style='color:#CC5B5B'>!!!</span>\"\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  // Auto flip to back when One by one mode.\n  var autoflip = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Was sind die <i>Äste</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\"></div>\n\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<script>\n  //DONT FADE BETWEEN CARDS\n  qFade = 0;\n  if (typeof anki !== 'undefined') anki.qFade = qFade;\n</script>\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    if (!indentation) { return; }\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- CLOZE ONE BY ONE FRONT -->\n<div id=\"one-by-one\" style=\"display: none;\"></div>\n\n<script>\n  /**\n   * Based on the AnKing Notetype, but expanded and modified by phyn.\n   * Credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  Persistence.clear();\n\n  // check if OneByOne is generally enabled for this card\n  var oneByOneFieldEmpty = selectiveOneByOne ? \"{{One by one}}\" === \"\" : true;\n  var clozeOneByOneEnabled = alwaysOneByOne ? true : !oneByOneFieldEmpty;\n\n  // avoid flickering. Must unset this in the back.\n  document.getElementById(\"qa\").style.display = \"none\";\n  var clozeHints = [];\n\n  if (clozeOneByOneEnabled) {\n    // collect hints from front side (independent of whether or not OneByOne is enabled)\n    document.getElementById(\"qa\").classList.add('one-by-one');\n    // Save cloze hints to display in the back\n    var clozes = document.getElementsByClassName(\"cloze\")\n    for (var i = 0; i < clozes.length; i++) {\n      clozes[i].classList.add(\"one-by-one\");\n      if (clozes[i].innerHTML === \"[...]\") {\n        clozeHints.push(\"\")\n      } else {\n        clozeHints.push(clozes[i].innerHTML)\n      }\n    }\n\n    // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n    /**\n     * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n     */\n    const getCardNumber = function () {\n      clz = document.body.className;\n      const regex = /card(\\d+)/gm;\n\n      let clz2;\n      try {\n        clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n      } catch (e) {\n        clz2 = \"\";\n      }\n      const regex2 = /.*?Cloze(\\d+)/gm;\n\n      let m;\n\n      if ((m = regex2.exec(clz2)) !== null) {\n        return m[1];\n      } else if ((m = regex.exec(clz)) !== null) {\n        return m[1];\n      } else {\n        // Should only fire if card is not cloze\n        console.error(\"Cannot find cardN class of body element!\");\n        return \"0\";\n      }\n    }\n\n    var alreadyRendered = false;\n\n    function processSelective1b1() {\n      if (alreadyRendered) return;\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (autoflip && clozeOneByOneEnabled) {\n        if (window.pycmd || window.showAnswer) {\n          // avoid flickering. Must unset this in the back.\n          document.getElementById(\"qa\").style.display = \"none\";\n        }\n        if (window.pycmd) {\n          pycmd(\"ans\")\n        } else if (window.showAnswer) {\n          showAnswer()\n        }\n      } else {\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n      }\n      // AnkiMobile JS API doesn't have one for show answer.\n      // Best alternative is to use Taps/Swipes to show answer.\n\n      alreadyRendered = true;\n    }\n\n    function delayedProcessSelective1b1() {\n      if (window.requestAnimationFrame) window.requestAnimationFrame(processSelective1b1); // less flickering\n      else window.setTimeout(processSelective1b1, 0);\n    };\n\n    window.onload = delayedProcessSelective1b1;\n    if (document.readyState === \"complete\") {\n      delayedProcessSelective1b1();\n    }\n    else {\n      document.addEventListener(\"DOMContentLoaded\", delayedProcessSelective1b1);\n    }\n\n    // Observe document.body class changes to trigger re-rendering.\n    // This is useful, because Anki doesn’t always start with an up-to-date class list:\n    // https://forums.ankiweb.net/t/card-card-classes-only-injected-separately-now/27387.\n    const observer = new MutationObserver(function (mutationsList, observer) {\n      for (let mutation of mutationsList) {\n        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {\n          delayedProcessSelective1b1();\n        }\n      }\n    });\n    observer.observe(document.body, { attributes: true });\n  }\n  Persistence.setItem(\"clozeHints\", clozeHints);\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>\n\n\n{{/ÄsteCloze3}}{{/ÄsteCloze2}}{{/ÄsteCloze1}}\n{{/Äste}}",
      "afmt": "<!-- version f0935e4 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n<div id=\"back\"></div>\n<div id=\"cloze\" data-card=\"{{Card}}\"></div>\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Eigene Notizen & Bilder\": \"Alt + 1\",\n    \"Eigene Prüfungsfragen\": \"Alt + 2\",\n    \"Definitionen\": \"Alt + 3\",\n    \"Merksprüche\": \"Alt + 4\",\n    \"Klinik\": \"Alt + 5\",\n    \"Präparat\": \"Alt + 6\",\n    \"Memes\": \"Alt + 7\",\n    \"linkContainer\": \"Alt + L\",\n    \"Meditricks\": \"Alt + M\",\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Eigene Notizen & Bilder\": false,\n    \"Eigene Prüfungsfragen\": false,\n    \"Definitionen\": false,\n    \"Merksprüche\": false,\n    \"Klinik\": false,\n    \"Präparat\": false,\n    \"Memes\": false,\n    \"linkContainer\": true,\n    \"Meditricks\": false,\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  var revealNextShortcut = \"N\"\n  var revealNextWordShortcut = \"Shift + N\"\n  var toggleAllShortcut = \",\"\n\n  // Enables revealing of next Cloze by simply clicking / tapping anywhere on the card (except the buttons)\n  var revealAnywhere = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // Changes how \"Reveal Next\" and clicking behaves. Either \"cloze\" or \"word\".\n  // \"word\" reveals word by word. \n  var revealNextClozeMode = \"cloze\"\n\n  // Changes how fields with additional information are displayed.\n  // true displays fields with additional information only if all clozes are revealed.\n  var hideAdditional = true;\n  var hideAdditionalButtons = true;\n\n  // What cloze is hidden with\n  var clozeHider = (elem) => \"[&nbsp;_&nbsp;]\"\n  /*\n  You can replace the above line with below examples. '█' or '_' works well for hiding clozes.\n  \n  // Fixed length:\n  var clozeHider = (elem) => \"███\"\n  // Replace each character with \"█\":\n  var clozeHider = (elem) => \"█\".repeat(elem.textContent.length)\n  // Show whitespaces:\n  var clozeHider = (elem) => \"[\" + elem.textContent.split(\" \").map((t) => \"█\".repeat(t.length)).join(\" \") + \"]\"\n  // Color-filled box (doesn't hide images):\n  var clozeHider = (elem) => `<span style=\"background-color: red; color: transparent;\">${elem.innerHTML}</span>`\n  */\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Was sind die <i>Äste</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div class=\"cloze\"><br>{{Äste}}</div>\n\n    <!-- ClOZE ONE BY ONE BUTTONS -->\n    <div id=\"onebyone-buttons\" class=\"onebyone\">\n      <br>\n      <button id=\"button-reveal-next\" class=\"button-general button-one-by-one\"\n        onclick=\"revealNextCloze(); event.stopPropagation()\">Reveal Next</button>\n      <button id=\"button-toggle-all\" class=\"button-general button-one-by-one\"\n        onclick=\"toggleAllCloze(); event.stopPropagation()\">Toggle All</button>\n    </div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- BUTTON FIELDS -->\n    {{#Eigene Notizen & Bilder}}\n    <span id=\"hint-zusatz\" class=\"hintBtn\" data-name=\"Eigene Notizen & Bilder\" style=\"display: none;\">\n      <button id=\"button-zusatz\" class=\"button-general\" onclick=\"toggleHintBtn('hint-zusatz'); event.stopPropagation()\">\n        <img src=\"__zusatz.svg\" style=\"height: 10px;\"> Eigene Notizen & Bilder\n      </button>\n      <div dir=\"auto\" id=\"zusatz\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Notizen & Bilder}}</div>\n    </span>\n    {{/Eigene Notizen & Bilder}}\n\n    {{#Eigene Prüfungsfragen}}\n    <span id=\"hint-hammer\" class=\"hintBtn\" data-name=\"Eigene Prüfungsfragen\" style=\"display: none;\">\n      <button id=\"button-hammer\" class=\"button-general\" onclick=\"toggleHintBtn('hint-hammer'); event.stopPropagation()\">\n        <img src=\"__hammer.svg\" style=\"height: 10px;\"> Eigene Prüfungsfragen\n      </button>\n      <div dir=\"auto\" id=\"hammer\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Prüfungsfragen}}</div>\n    </span>\n    {{/Eigene Prüfungsfragen}}\n\n    {{#Definitionen}}\n    <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Definitionen\" style=\"display: none;\">\n      <button id=\"button-definition\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Definitionen\n      </button>\n      <div dir=\"auto\" id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Definitionen}}</div>\n    </span>\n    {{/Definitionen}}\n\n    {{#Merksprüche}}\n    <span id=\"hint-merksprueche\" class=\"hintBtn\" data-name=\"Merksprüche\" style=\"display: none;\">\n      <button id=\"button-merksprueche\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-merksprueche'); event.stopPropagation()\">\n        <img src=\"__merkhilfe.svg\" style=\"height: 10px;\"> Merksprüche\n      </button>\n      <div dir=\"auto\" id=\"merksprueche\" class=\"hints\" style=\"display: none;\">{{edit:Merksprüche}}</div>\n    </span>\n    {{/Merksprüche}}\n\n    {{#Klinik}}\n    <span id=\"hint-klinik\" class=\"hintBtn\" data-name=\"Klinik\" style=\"display: none;\">\n      <button id=\"button-klinik\" class=\"button-general\" onclick=\"toggleHintBtn('hint-klinik'); event.stopPropagation()\">\n        <img src=\"__stethoscope.svg\" style=\"height: 10px;\"> Klinik\n      </button>\n      <div dir=\"auto\" id=\"klinik\" class=\"hints\" style=\"display: none;\">{{edit:Klinik}}</div>\n    </span>\n    {{/Klinik}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-praeparat\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n        </button>\n      </a>\n    </span>\n    {{/Präparat}}\n\n    {{#Virtuelle Mikroskopie}}\n    <span id=\"hint-microscope-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Virtuelle Mikroskopie}}\">\n        <button id=\"button-microscope\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Virtuelle Mikroskopie\n        </button>\n      </a>\n    </span>\n    {{/Virtuelle Mikroskopie}}\n\n    {{#Smart Zoom}}\n    <span id=\"hint-smartzoom-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-smartzoom\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Smart Zoom\n        </button>\n      </a>\n    </span>\n    {{/Smart Zoom}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat\" class=\"hintBtn\" data-name=\"Präparat\" style=\"display: none;\">\n      <button id=\"button-praeparat\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-praeparat'); event.stopPropagation()\">\n        <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n      </button>\n      <div dir=\"auto\" id=\"praeparat\" class=\"hints\" style=\"display: none;\">{{edit:Präparat}}</div>\n    </span>\n    {{/Präparat}}\n\n    {{#Memes}}\n    <span id=\"hint-memes\" class=\"hintBtn\" data-name=\"Memes\" style=\"display: none;\">\n      <button id=\"button-memes\" class=\"button-general\" onclick=\"toggleHintBtn('hint-memes'); event.stopPropagation()\">\n        <img src=\"__sonstiges.svg\" style=\"height: 10px;\"> Memes\n      </button>\n      <div dir=\"auto\" id=\"memes\" class=\"hints\" style=\"display: none;\">{{edit:Memes}}</div>\n    </span>\n    {{/Memes}}\n\n    <!-- LINEBREAKS IF BUTTONS EXIST -->\n    <script>\n      var array = [`{{Eigene Notizen & Bilder}}`, `{{Eigene Prüfungsfragen}}`, `{{Definitionen}}`, `{{Merksprüche}}`, `{{Klinik}}`, `{{Präparat}}`, `{{Memes}}`];\n      var anyistrue = (element) => element;\n      if (array.some(anyistrue)) {\n        document.getElementById(\"linebreaksIfButtons\").innerHTML = \"<br>\";\n      }\n    </script>\n    <div id=\"linebreaksIfButtons\"></div>\n\n    <!-- Extra field -->\n    {{#Extra}}\n    <div id=\"extra\" style=\"display: none;\">\n      <br>{{edit:Extra}}<br><br>\n    </div>\n    {{/Extra}}\n\n    <!-- Image field -->\n    {{#Bild}}\n    <div id=\"image\" style=\"display: none;\">\n      {{edit:Bild}}<br><br></div>\n    {{/Bild}}\n    {{^Bild}}\n    <span id=\"image\" style=\"display: none;\"></span>\n    {{/Bild}}\n    {{#Bild}}\n    <span id=\"hint-image\" style=\"display: none;\">\n      <button id=\"button-image\" class=\"button-general\"\n        onclick=\"var image = document.getElementById('image'); if (image.style.display == 'none') { image.style.display = 'block' } else { image.style.display = 'none' }; event.stopPropagation()\">\n        <img src=\"__image.svg\" style=\"height: 10px;\"> Abbildung\n      </button>\n    </span>\n    {{/Bild}}\n\n    <span id=\"hint-uafi\" class=\"hintBtn\" data-name=\"Ursprung, Ansatz, Verlauf, Funktion, Innervation, Äste\"\n      style=\"display: none;\">\n      <button id=\"button-uafi\" class=\"button-general expanded-button\"\n        onclick=\"toggleHintBtn('hint-uafi'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Weitere Informationen\n      </button>\n      <div id=\"uafi\" class=\"hints\" style=\"display: block;\">\n        <table class=\"uncloze\">\n          {{#Ursprung}}\n          <tr class=\"uafi-element\" id=\"Ursprung\">\n            <td><i>Ursprung</i></td>\n            <td>{{Ursprung}}</td>\n          </tr>\n          {{/Ursprung}}\n          {{#Ansatz}}\n          <tr class=\"uafi-element\" id=\"Ansatz\">\n            <td><i>Ansatz</i></td>\n            <td>{{Ansatz}}</td>\n          </tr>\n          {{/Ansatz}}\n          {{#Verlauf}}\n          <tr class=\"uafi-element\" id=\"Verlauf\">\n            <td><i>Verlauf</i></td>\n            <td>{{Verlauf}}</td>\n          </tr>\n          {{/Verlauf}}\n          {{#Funktion}}\n          <tr class=\"uafi-element\" id=\"Funktion\">\n            <td><i>Funktion</i></td>\n            <td>{{Funktion}}</td>\n          </tr>\n          {{/Funktion}}\n          {{#Innervation}}\n          <tr class=\"uafi-element\" id=\"Innervation\">\n            <td><i>Innervation</i></td>\n            <td>{{Innervation}}</td>\n          </tr>\n          {{/Innervation}}\n          {{#Äste}}\n          <tr class=\"uafi-element\" id=\"Äste\">\n            <td><i>Äste</i></td>\n            <td>{{Äste}}</td>\n          </tr>\n          {{/Äste}}\n        </table>\n      </div>\n\n      <script>\n        // iterate over all uafi-elements and hide only the one\n        // that is equal to the card's answer (i.e., value of {{Card}})\n        var uafiElements = document.getElementsByClassName(\"uafi-element\");\n        for (var i = 0; i < uafiElements.length; i++) {\n          if (((\"{{Card}}\").startsWith(uafiElements[i].id))) {\n            uafiElements[i].remove()\n          }\n        }\n      </script>\n    </span>\n\n    {{#AMBOSS-Link}}\n    <span id=\"hint-amboss\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:AMBOSS-Link}}\">\n        <button id=\"button-amboss\" class=\"button-general\">\n          <img src=\"__amboss.svg\" style=\"height: 10px;\"> AMBOSS&#8203;\n        </button>\n      </a>\n    </span>\n    {{/AMBOSS-Link}}\n\n    {{#Thieme via medici-Link}}\n    <span id=\"hint-thieme\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Thieme via medici-Link}}\">\n        <button id=\"button-thieme\" class=\"button-general\">\n          <img id=\"button-thieme-img\" src=\"__thieme-heart.svg\" style=\"height: 10px;\"> Thieme via medici\n        </button>\n      </a>\n    </span>\n    {{/Thieme via medici-Link}}\n\n    {{#Meditricks}}\n    <span id=\"hint-meditricks\" class=\"hintBtn\" data-name=\"Meditricks\" style=\"display: none;\">\n      <button id=\"button-meditricks\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-meditricks'); event.stopPropagation()\">\n        <img src=\"__meditricks.svg\" style=\"height: 10px;\"> Meditricks\n      </button>\n      <div dir=\"auto\" id=\"meditricks\" class=\"hints\" style=\"display: none;\">{{edit:Meditricks}}</div>\n    </span>\n    {{/Meditricks}}\n\n    {{#weitere Links}}\n    <span id=\"hint-linkcontainer\" class=\"hintBtn\" data-name=\"linkContainer\" style=\"display: none;\">\n      <button id=\"button-linkcontainer\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-linkcontainer'); event.stopPropagation()\">\n        <img src=\"__internet.svg\" style=\"height: 10px;\"> weitere Links\n      </button>\n      <div id=\"linkcontainer\" class=\"hints\" style=\"display: none;\"></div>\n      <span id=\"linkContainerLinks\" style=\"display: none;\">{{edit:weitere Links}}</span>\n    </span>\n    {{/weitere Links}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n  try {\n    for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n      href = link.href\n      text = link.innerText\n\n      const el = document.createElement('a');\n      el.setAttribute('href', link.href);\n\n      const btn = document.createElement('button');\n      btn.classList.add('button-general');\n      btn.classList.add('expanded-button');\n\n      domain = href.replace(/.+\\/\\/|(www|flexikon|register|de|next|com).|\\..+/g, '');\n      domainDict = {\n        \"amboss\": \"__amboss.svg\",\n        \"wikipedia\": \"__wikipedia.svg\",\n        \"doccheck\": \"__doccheck.png\",\n        \"notfallguru\": \"__notfallguru.svg\",\n        \"awmf\": \"__awmf.svg\",\n        \"gelbe-liste\": \"__gelbe-liste.png\",\n        \"embryotox\": \"__embryotox.svg\",\n        \"radiopaedia\": \"__radiopaedia.png\",\n        \"orphanet\": \"__orphanet.png\",\n      }\n      if (domain in domainDict) {\n        icon = domainDict[domain]\n      } else {\n        icon = \"__internet.svg\"\n      }\n\n      const img = document.createElement('img');\n      img.setAttribute('src', icon);\n      img.setAttribute('style', 'height: 10px;');\n\n      btn.appendChild(img);\n      btn.innerHTML = btn.innerHTML + \" \" + text;\n\n      el.appendChild(btn);\n\n      document.getElementById(\"linkcontainer\").appendChild(el)\n    }\n  }\n  catch (err) {\n    console.log(err)\n  }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-uafi\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- AUTOFLIP BACK SCRIPT -->\n<script>\n  // autoflip hides card in front template\n  document.getElementById(\"qa\").style.removeProperty(\"display\")\n</script>\n\n<!-- CLOZE ONE BY ONE SCRIPT -->\n<style>\n  .cloze-replacer:hover {\n    cursor: pointer;\n  }\n\n  .cloze-hidden {\n    display: none;\n  }\n\n  .cloze-replacer .hidden {\n    display: none;\n  }\n\n  #extra.hidden {\n    display: none;\n  }\n</style>\n\n<!--\n Based on the AnKing Notetype, but expanded and modified by phyn.\n Credit to the original authors, except where modified or otherwise indicated.\n-->\n\n<script>\n    (function () {\n      // enables cloze one-by-one even when one-by-one field is empty\n      // minNumberOfClozes is still considered in this case\n      // overridden in importance by selectiveOneByOne\n      var clozeOneByOneEnabled = true;\n\n      // remove the clickAnywhere function from global scope\n      document.documentElement.removeAttribute(\"onclick\")\n\n      // --- CHECK IF ONE BY ONE IS GENERALLY ENABLED FOR THIS NOTE ---\n      var oneByOneFieldNotEmpty = \"{{One by one}}\" !== \"\";\n      try {\n        clozeOneByOneEnabled = alwaysOneByOne || oneByOneFieldNotEmpty;\n      } catch (exception) {\n        console.log(exception)\n      }\n\n      /**\n   * helper functions to show / hide fields containing additional information\n   */\n      const showExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const hideExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const buttonIds = [\n        \"hint-zusatz\",\n        \"hint-definition\",\n        \"hint-hammer\",\n        \"hint-klinik\",\n        \"hint-praeparat\",\n        \"hint-microscope\",\n        \"hint-smartzoom\",\n        \"hint-histotrainer\",\n        \"hint-uafi\",\n        \"hint-merksprueche\",\n        \"hint-memes\",\n        \"hint-image\",\n        \"hint-amboss\",\n        \"hint-thieme\",\n        \"hint-meditricks\",\n        \"hint-linkcontainer\",\n      ];\n\n      const showExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document\n              .getElementById(buttonIds[button])\n              .style.removeProperty(\"display\");\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n      const hideExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document.getElementById(buttonIds[button]).style.display = \"none\";\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n\n      // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n      /**\n       * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n       */\n      const getCardNumber = function () {\n        clz = document.body.className;\n        const regex = /card(\\d+)/gm;\n\n        let clz2;\n        try {\n          clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n        } catch (e) {\n          clz2 = \"\";\n        }\n        const regex2 = /.*?Cloze(\\d+)/gm;\n\n        let m;\n\n        if ((m = regex2.exec(clz2)) !== null) {\n          return m[1];\n        } else if ((m = regex.exec(clz)) !== null) {\n          return m[1];\n        } else {\n          // Should only fire if card is not cloze\n          console.error(\"Cannot find cardN class of body element!\");\n          return \"0\";\n        }\n      }\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (!clozeOneByOneEnabled) {\n        showExtra()\n        showExtraButtons()\n        document.getElementById(\"onebyone-buttons\").style.display = \"none\"\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n        return\n      }\n\n      // Needed for amboss to recognize first word in .cloze-hidden\n      const CLOZE_REPLACER_SEP = \"<span class='hidden'> </span>\"\n\n      const hideAllCloze = function (initial) {\n        let clozes = document.getElementsByClassName(\"cloze\")\n        let count = 0 // hidden cloze count\n        for (const cloze of clozes) {\n          const existingHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n          if (existingHidden) {\n            revealCloze(cloze);\n          }\n          if (cloze.offsetWidth === 0) {\n            continue\n          }\n          const clozeReplacer = document.createElement(\"span\")\n          const clozeHidden = document.createElement(\"span\")\n          clozeReplacer.classList.add(\"cloze-replacer\")\n          clozeHidden.classList.add(\"cloze-hidden\")\n          while (cloze.childNodes.length > 0) {\n            clozeHidden.appendChild(cloze.childNodes[0])\n          }\n          cloze.appendChild(clozeReplacer)\n          cloze.appendChild(clozeHidden)\n\n          var clozeHints = Persistence.getItem(\"clozeHints\");\n          if (clozeHints && clozeHints[count]) {\n            clozeReplacer.classList.add(\"cloze-hint\")\n            clozeReplacer.innerHTML = clozeHints[count] + CLOZE_REPLACER_SEP\n          } else {\n            clozeReplacer.innerHTML = clozeHider(cloze) + CLOZE_REPLACER_SEP\n          }\n          count += 1\n          document.getElementById(\"button-reveal-next\").style.display = \"inline-block\";\n          if (initial) {\n            cloze.addEventListener(\"touchend\", revealClozeClicked)\n            cloze.addEventListener(\"click\", revealClozeClicked)\n            cloze.classList.add(\"one-by-one\");\n          }\n        }\n\n        // Hide #extra until all clozes are shown\n        const extra = document.getElementById(\"extra\");\n        if (extra) {\n          extra.classList.add(\"hidden\");\n        }\n\n        hideExtra();\n        hideExtraButtons();\n        if (revealAnywhere) {\n          document.documentElement.setAttribute(\"onclick\", \"revealNextCloze(); event.stopPropagation()\")\n        }\n\n\n        // Also hide autoReveal fields\n        for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n          const container = document.querySelector(`[data-name=\"${field}\"]`)\n          if (container) {\n            const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n            if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n              // const link = container.getElementsByTagName(\"a\")[0]\n              const button = container.getElementsByTagName(\"button\")[0]\n              const hint = container.getElementsByTagName(\"div\")[0]\n              button.classList.remove(\"expanded-button\")\n              hint.style.display = \"none\"\n              // link.style.display = \"\"\n            }\n          }\n        }\n      }\n\n      const revealCloze = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        cloze.removeChild(clozeReplacer)\n        cloze.removeChild(clozeHidden)\n        while (clozeHidden.childNodes.length > 0) {\n          cloze.appendChild(clozeHidden.childNodes[0])\n        }\n        maybeRevealExtraField()\n      }\n\n      const revealClozeWord = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        let range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundSpace = setRangeEnd(range, clozeHidden, \"beforeFirstSpace\")\n        if (!foundSpace) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        let fragment = range.extractContents()\n        cloze.insertBefore(fragment, clozeReplacer)\n        // Extract whitespaces after word\n        range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundWord = setRangeEnd(range, clozeHidden, \"beforeFirstChar\")\n        if (!foundWord) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        fragment = range.extractContents();\n        cloze.insertBefore(fragment, clozeReplacer)\n        if (!foundWord) {\n          cloze.removeChild(clozeHidden)\n          cloze.removeChild(clozeReplacer)\n          maybeRevealExtraField()\n          return\n        }\n        clozeReplacer.innerHTML = clozeHider(clozeHidden) + CLOZE_REPLACER_SEP\n        if (clozeReplacer.classList.contains(\"cloze-hint\")) [\n          clozeReplacer.classList.remove(\"cloze-hint\")\n        ]\n        maybeRevealExtraField()\n      }\n\n      const revealNextClozeOf = (type) => {\n        const nextHidden = document.querySelectorAll(\".cloze-hidden\")\n        const nextNextHidden = nextHidden.length > 1 ? true : false\n        if (!nextNextHidden) {\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\";\n        }\n        if (!nextHidden) {\n          return\n        }\n        const cloze = clozeElOfClozeHidden(nextHidden[0]);\n        if (type === \"word\") {\n          revealClozeWord(cloze)\n        } else if (type === \"cloze\") {\n          revealCloze(cloze)\n        } else {\n          console.error(\"Invalid type: \" + type)\n        }\n      }\n\n      const revealClozeClicked = function (ev) {\n        let elem = ev.currentTarget\n        if (!ev.altKey && (revealNextClozeMode !== \"word\")) {\n          revealCloze(elem)\n        } else {\n          revealClozeWord(elem)\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      }\n\n      window.revealNextCloze = function () {\n        revealNextClozeOf(revealNextClozeMode)\n      }\n\n      window.toggleAllCloze = function () {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length > 0) {\n          for (const elem of elems) {\n            const cloze = clozeElOfClozeHidden(elem)\n            revealCloze(cloze)\n          }\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\"\n        } else {\n          hideAllCloze(initial = false)\n        }\n      }\n\n      const clozeElOfClozeHidden = (cloze) => {\n        while (!cloze.classList.contains(\"cloze\")) {\n          cloze = cloze.parentElement;\n        }\n        return cloze;\n      }\n\n      const maybeRevealExtraField = () => {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length == 0) {\n          const extra = document.getElementById(\"extra\")\n          if (extra) {\n            extra.classList.remove(\"hidden\")\n          }\n\n          showExtra();\n          showExtraButtons();\n          document.documentElement.removeAttribute(\"onclick\")\n\n          // Also reveal autoReveal fields\n          for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n            const container = document.querySelector(`[data-name=\"${field}\"]`)\n            if (container) {\n              const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n              if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n                // const link = container.getElementsByTagName(\"a\")[0]\n                const button = container.getElementsByTagName(\"button\")[0]\n                const hint = container.getElementsByTagName(\"div\")[0]\n                button.classList.add(\"expanded-button\")\n                hint.style.display = \"block\"\n                // link.style.display = \"none\"\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * mode: 'beforeFirstSpace' or 'beforeFirstChar'\n       * Return `true` if it exists and setEnd() was called, otherwise `false`\n       */\n      const setRangeEnd = function (range, node, mode) {\n        if (node.nodeType === Node.TEXT_NODE) {\n          const regex = mode === 'beforeFirstSpace' ? /\\s/ : /\\S/\n          const match = node.textContent.match(regex)\n          if (match) {\n            if (match.index === 0) {\n              while (node.previousSibling === null) {\n                node = node.parentElement\n              }\n              range.setEndBefore(node)\n            } else {\n              range.setEnd(node, match.index);\n            }\n            return true;\n          } else {\n            return false;\n          }\n        } else if (mode === 'beforeFirstChar' && isCharNode(node)) {\n          range.setEndBefore(node)\n          return true\n        } else if (!ignoreSpaceInNode(node)) {\n          for (const child of node.childNodes) {\n            if (setRangeEnd(range, child, mode)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }\n\n      const ignoreSpaceInNode = function (node) {\n        return node.tagName === \"MJX-ASSISTIVE-MML\"\n      }\n\n      const isCharNode = function (node) {\n        return [\"IMG\", \"MJX-CONTAINER\"].includes(node.tagName)\n      }\n\n      hideAllCloze(initial = true)\n\n      let isShowNextShortcut = shortcutMatcher(window.revealNextShortcut)\n      let isShowWordShortcut = shortcutMatcher(window.revealNextWordShortcut)\n      let isToggleAllShortcut = shortcutMatcher(window.toggleAllShortcut)\n      ankingAddEventListener(\"keydown\", (ev) => {\n        let next = isShowNextShortcut(ev)\n        let word = isShowWordShortcut(ev)\n        let all = isToggleAllShortcut(ev)\n        if (next) {\n          revealNextClozeOf(\"cloze\")\n        } else if (word) {\n          revealNextClozeOf(\"word\")\n        } else if (all) {\n          toggleAllCloze()\n        } else {\n          return;\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      });\n    })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- MEDITRICKS SNIPPETS DATA -->\n<div id=\"meditricks-mtsp-values\" style=\"display:none;\">\n  <div id=\"meditricks-mtsp-nfname\">_meditricks_nf_v1000_ankizin</div>\n  <div id=\"meditricks-mtsp-nid\">{{Note ID}}</div>\n</div>\n<script src=\"_meditricks_mtsp_scripts_v1000_ankizin.js\"></script>\n<link href=\"_meditricks_mtsp_styles_v1000_ankizin.css\" rel=\"stylesheet\" />\n\n<!-- include \"_meditricks_mtsp_nf_v1000_ankizin.js\" -->\n<!-- include \"_meditricks_mtsp_scripts_v1000_iframe.map\" -->\n<!-- include \"_meditricks_mtsp_mtlogo.webp\" -->\n<!-- include \"_meditricks_mtsp_mt-loading.png\" -->\n<!-- include \"_meditricks_mtsp_mt-loading_night.png\" -->\n\n<!-- //MEDITRICKS SNIPPETS DATA -->\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>",
      "bqfmt": "{{Muskel / Leitungsbahn}}",
      "bafmt": "{{Äste}}",
      "did": null,
      "bfont": "Helvetica",
      "bsize": 12
    },
    {
      "name": "UrsprungCloze1",
      "ord": 6,
      "qfmt": "<!-- version f0935e4 -->\n{{#Ursprung}}\n{{#UrsprungCloze1}}\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TIMER CONFIG  ##############\n  // Timer config (timer length, timer finished message)\n  var minutes = 0\n  var seconds = 15\n  var timeOverMsg = \"<span style='color:#CC5B5B'>!!!</span>\"\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  // Auto flip to back when One by one mode.\n  var autoflip = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Wo liegt der <i>Ursprung</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" data-card=\"{{Card}}\"><br>{{Ursprung}}</div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\"></div>\n\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<script>\n  //DONT FADE BETWEEN CARDS\n  qFade = 0;\n  if (typeof anki !== 'undefined') anki.qFade = qFade;\n</script>\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    if (!indentation) { return; }\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- CLOZE ONE BY ONE FRONT -->\n<div id=\"one-by-one\" style=\"display: none;\"></div>\n\n<script>\n  /**\n   * Based on the AnKing Notetype, but expanded and modified by phyn.\n   * Credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  Persistence.clear();\n\n  // check if OneByOne is generally enabled for this card\n  var oneByOneFieldEmpty = selectiveOneByOne ? \"{{One by one}}\" === \"\" : true;\n  var clozeOneByOneEnabled = alwaysOneByOne ? true : !oneByOneFieldEmpty;\n\n  // avoid flickering. Must unset this in the back.\n  document.getElementById(\"qa\").style.display = \"none\";\n  var clozeHints = [];\n\n  if (clozeOneByOneEnabled) {\n    // collect hints from front side (independent of whether or not OneByOne is enabled)\n    document.getElementById(\"qa\").classList.add('one-by-one');\n    // Save cloze hints to display in the back\n    var clozes = document.getElementsByClassName(\"cloze\")\n    for (var i = 0; i < clozes.length; i++) {\n      clozes[i].classList.add(\"one-by-one\");\n      if (clozes[i].innerHTML === \"[...]\") {\n        clozeHints.push(\"\")\n      } else {\n        clozeHints.push(clozes[i].innerHTML)\n      }\n    }\n\n    // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n    /**\n     * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n     */\n    const getCardNumber = function () {\n      clz = document.body.className;\n      const regex = /card(\\d+)/gm;\n\n      let clz2;\n      try {\n        clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n      } catch (e) {\n        clz2 = \"\";\n      }\n      const regex2 = /.*?Cloze(\\d+)/gm;\n\n      let m;\n\n      if ((m = regex2.exec(clz2)) !== null) {\n        return m[1];\n      } else if ((m = regex.exec(clz)) !== null) {\n        return m[1];\n      } else {\n        // Should only fire if card is not cloze\n        console.error(\"Cannot find cardN class of body element!\");\n        return \"0\";\n      }\n    }\n\n    var alreadyRendered = false;\n\n    function processSelective1b1() {\n      if (alreadyRendered) return;\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (autoflip && clozeOneByOneEnabled) {\n        if (window.pycmd || window.showAnswer) {\n          // avoid flickering. Must unset this in the back.\n          document.getElementById(\"qa\").style.display = \"none\";\n        }\n        if (window.pycmd) {\n          pycmd(\"ans\")\n        } else if (window.showAnswer) {\n          showAnswer()\n        }\n      } else {\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n      }\n      // AnkiMobile JS API doesn't have one for show answer.\n      // Best alternative is to use Taps/Swipes to show answer.\n\n      alreadyRendered = true;\n    }\n\n    function delayedProcessSelective1b1() {\n      if (window.requestAnimationFrame) window.requestAnimationFrame(processSelective1b1); // less flickering\n      else window.setTimeout(processSelective1b1, 0);\n    };\n\n    window.onload = delayedProcessSelective1b1;\n    if (document.readyState === \"complete\") {\n      delayedProcessSelective1b1();\n    }\n    else {\n      document.addEventListener(\"DOMContentLoaded\", delayedProcessSelective1b1);\n    }\n\n    // Observe document.body class changes to trigger re-rendering.\n    // This is useful, because Anki doesn’t always start with an up-to-date class list:\n    // https://forums.ankiweb.net/t/card-card-classes-only-injected-separately-now/27387.\n    const observer = new MutationObserver(function (mutationsList, observer) {\n      for (let mutation of mutationsList) {\n        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {\n          delayedProcessSelective1b1();\n        }\n      }\n    });\n    observer.observe(document.body, { attributes: true });\n  }\n  Persistence.setItem(\"clozeHints\", clozeHints);\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>\n\n\n{{/UrsprungCloze1}}\n{{/Ursprung}}",
      "afmt": "<!-- version f0935e4 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n<div id=\"back\"></div>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Eigene Notizen & Bilder\": \"Alt + 1\",\n    \"Eigene Prüfungsfragen\": \"Alt + 2\",\n    \"Definitionen\": \"Alt + 3\",\n    \"Merksprüche\": \"Alt + 4\",\n    \"Klinik\": \"Alt + 5\",\n    \"Präparat\": \"Alt + 6\",\n    \"Memes\": \"Alt + 7\",\n    \"linkContainer\": \"Alt + L\",\n    \"Meditricks\": \"Alt + M\",\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Eigene Notizen & Bilder\": false,\n    \"Eigene Prüfungsfragen\": false,\n    \"Definitionen\": false,\n    \"Merksprüche\": false,\n    \"Klinik\": false,\n    \"Präparat\": false,\n    \"Memes\": false,\n    \"linkContainer\": true,\n    \"Meditricks\": false,\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  var revealNextShortcut = \"N\"\n  var revealNextWordShortcut = \"Shift + N\"\n  var toggleAllShortcut = \",\"\n\n  // Enables revealing of next Cloze by simply clicking / tapping anywhere on the card (except the buttons)\n  var revealAnywhere = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // Changes how \"Reveal Next\" and clicking behaves. Either \"cloze\" or \"word\".\n  // \"word\" reveals word by word. \n  var revealNextClozeMode = \"cloze\"\n\n  // Changes how fields with additional information are displayed.\n  // true displays fields with additional information only if all clozes are revealed.\n  var hideAdditional = true;\n  var hideAdditionalButtons = true;\n\n  // What cloze is hidden with\n  var clozeHider = (elem) => \"[&nbsp;_&nbsp;]\"\n  /*\n  You can replace the above line with below examples. '█' or '_' works well for hiding clozes.\n  \n  // Fixed length:\n  var clozeHider = (elem) => \"███\"\n  // Replace each character with \"█\":\n  var clozeHider = (elem) => \"█\".repeat(elem.textContent.length)\n  // Show whitespaces:\n  var clozeHider = (elem) => \"[\" + elem.textContent.split(\" \").map((t) => \"█\".repeat(t.length)).join(\" \") + \"]\"\n  // Color-filled box (doesn't hide images):\n  var clozeHider = (elem) => `<span style=\"background-color: red; color: transparent;\">${elem.innerHTML}</span>`\n  */\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Wo liegt der <i>Ursprung</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" class=\"clozefield\" data-card=\"{{Card}}\"><br>{{Ursprung}}</div>\n\n    <!-- ClOZE ONE BY ONE BUTTONS -->\n    <div id=\"onebyone-buttons\" class=\"onebyone\">\n      <br>\n      <button id=\"button-reveal-next\" class=\"button-general button-one-by-one\"\n        onclick=\"revealNextCloze(); event.stopPropagation()\">Reveal Next</button>\n      <button id=\"button-toggle-all\" class=\"button-general button-one-by-one\"\n        onclick=\"toggleAllCloze(); event.stopPropagation()\">Toggle All</button>\n    </div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- BUTTON FIELDS -->\n    {{#Eigene Notizen & Bilder}}\n    <span id=\"hint-zusatz\" class=\"hintBtn\" data-name=\"Eigene Notizen & Bilder\" style=\"display: none;\">\n      <button id=\"button-zusatz\" class=\"button-general\" onclick=\"toggleHintBtn('hint-zusatz'); event.stopPropagation()\">\n        <img src=\"__zusatz.svg\" style=\"height: 10px;\"> Eigene Notizen & Bilder\n      </button>\n      <div dir=\"auto\" id=\"zusatz\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Notizen & Bilder}}</div>\n    </span>\n    {{/Eigene Notizen & Bilder}}\n\n    {{#Eigene Prüfungsfragen}}\n    <span id=\"hint-hammer\" class=\"hintBtn\" data-name=\"Eigene Prüfungsfragen\" style=\"display: none;\">\n      <button id=\"button-hammer\" class=\"button-general\" onclick=\"toggleHintBtn('hint-hammer'); event.stopPropagation()\">\n        <img src=\"__hammer.svg\" style=\"height: 10px;\"> Eigene Prüfungsfragen\n      </button>\n      <div dir=\"auto\" id=\"hammer\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Prüfungsfragen}}</div>\n    </span>\n    {{/Eigene Prüfungsfragen}}\n\n    {{#Definitionen}}\n    <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Definitionen\" style=\"display: none;\">\n      <button id=\"button-definition\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Definitionen\n      </button>\n      <div dir=\"auto\" id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Definitionen}}</div>\n    </span>\n    {{/Definitionen}}\n\n    {{#Merksprüche}}\n    <span id=\"hint-merksprueche\" class=\"hintBtn\" data-name=\"Merksprüche\" style=\"display: none;\">\n      <button id=\"button-merksprueche\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-merksprueche'); event.stopPropagation()\">\n        <img src=\"__merkhilfe.svg\" style=\"height: 10px;\"> Merksprüche\n      </button>\n      <div dir=\"auto\" id=\"merksprueche\" class=\"hints\" style=\"display: none;\">{{edit:Merksprüche}}</div>\n    </span>\n    {{/Merksprüche}}\n\n    {{#Klinik}}\n    <span id=\"hint-klinik\" class=\"hintBtn\" data-name=\"Klinik\" style=\"display: none;\">\n      <button id=\"button-klinik\" class=\"button-general\" onclick=\"toggleHintBtn('hint-klinik'); event.stopPropagation()\">\n        <img src=\"__stethoscope.svg\" style=\"height: 10px;\"> Klinik\n      </button>\n      <div dir=\"auto\" id=\"klinik\" class=\"hints\" style=\"display: none;\">{{edit:Klinik}}</div>\n    </span>\n    {{/Klinik}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-praeparat\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n        </button>\n      </a>\n    </span>\n    {{/Präparat}}\n\n    {{#Virtuelle Mikroskopie}}\n    <span id=\"hint-microscope-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Virtuelle Mikroskopie}}\">\n        <button id=\"button-microscope\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Virtuelle Mikroskopie\n        </button>\n      </a>\n    </span>\n    {{/Virtuelle Mikroskopie}}\n\n    {{#Smart Zoom}}\n    <span id=\"hint-smartzoom-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-smartzoom\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Smart Zoom\n        </button>\n      </a>\n    </span>\n    {{/Smart Zoom}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat\" class=\"hintBtn\" data-name=\"Präparat\" style=\"display: none;\">\n      <button id=\"button-praeparat\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-praeparat'); event.stopPropagation()\">\n        <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n      </button>\n      <div dir=\"auto\" id=\"praeparat\" class=\"hints\" style=\"display: none;\">{{edit:Präparat}}</div>\n    </span>\n    {{/Präparat}}\n\n    {{#Memes}}\n    <span id=\"hint-memes\" class=\"hintBtn\" data-name=\"Memes\" style=\"display: none;\">\n      <button id=\"button-memes\" class=\"button-general\" onclick=\"toggleHintBtn('hint-memes'); event.stopPropagation()\">\n        <img src=\"__sonstiges.svg\" style=\"height: 10px;\"> Memes\n      </button>\n      <div dir=\"auto\" id=\"memes\" class=\"hints\" style=\"display: none;\">{{edit:Memes}}</div>\n    </span>\n    {{/Memes}}\n\n    <!-- LINEBREAKS IF BUTTONS EXIST -->\n    <script>\n      var array = [`{{Eigene Notizen & Bilder}}`, `{{Eigene Prüfungsfragen}}`, `{{Definitionen}}`, `{{Merksprüche}}`, `{{Klinik}}`, `{{Präparat}}`, `{{Memes}}`];\n      var anyistrue = (element) => element;\n      if (array.some(anyistrue)) {\n        document.getElementById(\"linebreaksIfButtons\").innerHTML = \"<br>\";\n      }\n    </script>\n    <div id=\"linebreaksIfButtons\"></div>\n\n    <!-- Extra field -->\n    {{#Extra}}\n    <div id=\"extra\" style=\"display: none;\">\n      <br>{{edit:Extra}}<br><br>\n    </div>\n    {{/Extra}}\n\n    <!-- Image field -->\n    {{#Bild}}\n    <div id=\"image\" style=\"display: none;\">\n      {{edit:Bild}}<br><br></div>\n    {{/Bild}}\n    {{^Bild}}\n    <span id=\"image\" style=\"display: none;\"></span>\n    {{/Bild}}\n    {{#Bild}}\n    <span id=\"hint-image\" style=\"display: none;\">\n      <button id=\"button-image\" class=\"button-general\"\n        onclick=\"var image = document.getElementById('image'); if (image.style.display == 'none') { image.style.display = 'block' } else { image.style.display = 'none' }; event.stopPropagation()\">\n        <img src=\"__image.svg\" style=\"height: 10px;\"> Abbildung\n      </button>\n    </span>\n    {{/Bild}}\n\n    <span id=\"hint-uafi\" class=\"hintBtn\" data-name=\"Ursprung, Ansatz, Verlauf, Funktion, Innervation, Äste\"\n      style=\"display: none;\">\n      <button id=\"button-uafi\" class=\"button-general expanded-button\"\n        onclick=\"toggleHintBtn('hint-uafi'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Weitere Informationen\n      </button>\n      <div id=\"uafi\" class=\"hints\" style=\"display: block;\">\n        <table class=\"uncloze\">\n          {{#Ursprung}}\n          <tr class=\"uafi-element\" id=\"Ursprung\">\n            <td><i>Ursprung</i></td>\n            <td>{{Ursprung}}</td>\n          </tr>\n          {{/Ursprung}}\n          {{#Ansatz}}\n          <tr class=\"uafi-element\" id=\"Ansatz\">\n            <td><i>Ansatz</i></td>\n            <td>{{Ansatz}}</td>\n          </tr>\n          {{/Ansatz}}\n          {{#Verlauf}}\n          <tr class=\"uafi-element\" id=\"Verlauf\">\n            <td><i>Verlauf</i></td>\n            <td>{{Verlauf}}</td>\n          </tr>\n          {{/Verlauf}}\n          {{#Funktion}}\n          <tr class=\"uafi-element\" id=\"Funktion\">\n            <td><i>Funktion</i></td>\n            <td>{{Funktion}}</td>\n          </tr>\n          {{/Funktion}}\n          {{#Innervation}}\n          <tr class=\"uafi-element\" id=\"Innervation\">\n            <td><i>Innervation</i></td>\n            <td>{{Innervation}}</td>\n          </tr>\n          {{/Innervation}}\n          {{#Äste}}\n          <tr class=\"uafi-element\" id=\"Äste\">\n            <td><i>Äste</i></td>\n            <td>{{Äste}}</td>\n          </tr>\n          {{/Äste}}\n        </table>\n      </div>\n\n      <script>\n        // iterate over all uafi-elements and hide only the one\n        // that is equal to the card's answer (i.e., value of {{Card}})\n        var uafiElements = document.getElementsByClassName(\"uafi-element\");\n        for (var i = 0; i < uafiElements.length; i++) {\n          if (((\"{{Card}}\").startsWith(uafiElements[i].id))) {\n            uafiElements[i].remove()\n          }\n        }\n      </script>\n    </span>\n\n    {{#AMBOSS-Link}}\n    <span id=\"hint-amboss\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:AMBOSS-Link}}\">\n        <button id=\"button-amboss\" class=\"button-general\">\n          <img src=\"__amboss.svg\" style=\"height: 10px;\"> AMBOSS&#8203;\n        </button>\n      </a>\n    </span>\n    {{/AMBOSS-Link}}\n\n    {{#Thieme via medici-Link}}\n    <span id=\"hint-thieme\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Thieme via medici-Link}}\">\n        <button id=\"button-thieme\" class=\"button-general\">\n          <img id=\"button-thieme-img\" src=\"__thieme-heart.svg\" style=\"height: 10px;\"> Thieme via medici\n        </button>\n      </a>\n    </span>\n    {{/Thieme via medici-Link}}\n\n    {{#Meditricks}}\n    <span id=\"hint-meditricks\" class=\"hintBtn\" data-name=\"Meditricks\" style=\"display: none;\">\n      <button id=\"button-meditricks\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-meditricks'); event.stopPropagation()\">\n        <img src=\"__meditricks.svg\" style=\"height: 10px;\"> Meditricks\n      </button>\n      <div dir=\"auto\" id=\"meditricks\" class=\"hints\" style=\"display: none;\">{{edit:Meditricks}}</div>\n    </span>\n    {{/Meditricks}}\n\n    {{#weitere Links}}\n    <span id=\"hint-linkcontainer\" class=\"hintBtn\" data-name=\"linkContainer\" style=\"display: none;\">\n      <button id=\"button-linkcontainer\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-linkcontainer'); event.stopPropagation()\">\n        <img src=\"__internet.svg\" style=\"height: 10px;\"> weitere Links\n      </button>\n      <div id=\"linkcontainer\" class=\"hints\" style=\"display: none;\"></div>\n      <span id=\"linkContainerLinks\" style=\"display: none;\">{{edit:weitere Links}}</span>\n    </span>\n    {{/weitere Links}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n  try {\n    for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n      href = link.href\n      text = link.innerText\n\n      const el = document.createElement('a');\n      el.setAttribute('href', link.href);\n\n      const btn = document.createElement('button');\n      btn.classList.add('button-general');\n      btn.classList.add('expanded-button');\n\n      domain = href.replace(/.+\\/\\/|(www|flexikon|register|de|next|com).|\\..+/g, '');\n      domainDict = {\n        \"amboss\": \"__amboss.svg\",\n        \"wikipedia\": \"__wikipedia.svg\",\n        \"doccheck\": \"__doccheck.png\",\n        \"notfallguru\": \"__notfallguru.svg\",\n        \"awmf\": \"__awmf.svg\",\n        \"gelbe-liste\": \"__gelbe-liste.png\",\n        \"embryotox\": \"__embryotox.svg\",\n        \"radiopaedia\": \"__radiopaedia.png\",\n        \"orphanet\": \"__orphanet.png\",\n      }\n      if (domain in domainDict) {\n        icon = domainDict[domain]\n      } else {\n        icon = \"__internet.svg\"\n      }\n\n      const img = document.createElement('img');\n      img.setAttribute('src', icon);\n      img.setAttribute('style', 'height: 10px;');\n\n      btn.appendChild(img);\n      btn.innerHTML = btn.innerHTML + \" \" + text;\n\n      el.appendChild(btn);\n\n      document.getElementById(\"linkcontainer\").appendChild(el)\n    }\n  }\n  catch (err) {\n    console.log(err)\n  }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-uafi\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- AUTOFLIP BACK SCRIPT -->\n<script>\n  // autoflip hides card in front template\n  document.getElementById(\"qa\").style.removeProperty(\"display\")\n</script>\n\n<!-- CLOZE ONE BY ONE SCRIPT -->\n<style>\n  .cloze-replacer:hover {\n    cursor: pointer;\n  }\n\n  .cloze-hidden {\n    display: none;\n  }\n\n  .cloze-replacer .hidden {\n    display: none;\n  }\n\n  #extra.hidden {\n    display: none;\n  }\n</style>\n\n<!--\n Based on the AnKing Notetype, but expanded and modified by phyn.\n Credit to the original authors, except where modified or otherwise indicated.\n-->\n\n<script>\n    (function () {\n      // enables cloze one-by-one even when one-by-one field is empty\n      // minNumberOfClozes is still considered in this case\n      // overridden in importance by selectiveOneByOne\n      var clozeOneByOneEnabled = true;\n\n      // remove the clickAnywhere function from global scope\n      document.documentElement.removeAttribute(\"onclick\")\n\n      // --- CHECK IF ONE BY ONE IS GENERALLY ENABLED FOR THIS NOTE ---\n      var oneByOneFieldNotEmpty = \"{{One by one}}\" !== \"\";\n      try {\n        clozeOneByOneEnabled = alwaysOneByOne || oneByOneFieldNotEmpty;\n      } catch (exception) {\n        console.log(exception)\n      }\n\n      /**\n   * helper functions to show / hide fields containing additional information\n   */\n      const showExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const hideExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const buttonIds = [\n        \"hint-zusatz\",\n        \"hint-definition\",\n        \"hint-hammer\",\n        \"hint-klinik\",\n        \"hint-praeparat\",\n        \"hint-microscope\",\n        \"hint-smartzoom\",\n        \"hint-histotrainer\",\n        \"hint-uafi\",\n        \"hint-merksprueche\",\n        \"hint-memes\",\n        \"hint-image\",\n        \"hint-amboss\",\n        \"hint-thieme\",\n        \"hint-meditricks\",\n        \"hint-linkcontainer\",\n      ];\n\n      const showExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document\n              .getElementById(buttonIds[button])\n              .style.removeProperty(\"display\");\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n      const hideExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document.getElementById(buttonIds[button]).style.display = \"none\";\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n\n      // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n      /**\n       * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n       */\n      const getCardNumber = function () {\n        clz = document.body.className;\n        const regex = /card(\\d+)/gm;\n\n        let clz2;\n        try {\n          clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n        } catch (e) {\n          clz2 = \"\";\n        }\n        const regex2 = /.*?Cloze(\\d+)/gm;\n\n        let m;\n\n        if ((m = regex2.exec(clz2)) !== null) {\n          return m[1];\n        } else if ((m = regex.exec(clz)) !== null) {\n          return m[1];\n        } else {\n          // Should only fire if card is not cloze\n          console.error(\"Cannot find cardN class of body element!\");\n          return \"0\";\n        }\n      }\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (!clozeOneByOneEnabled) {\n        showExtra()\n        showExtraButtons()\n        document.getElementById(\"onebyone-buttons\").style.display = \"none\"\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n        return\n      }\n\n      // Needed for amboss to recognize first word in .cloze-hidden\n      const CLOZE_REPLACER_SEP = \"<span class='hidden'> </span>\"\n\n      const hideAllCloze = function (initial) {\n        let clozes = document.getElementsByClassName(\"cloze\")\n        let count = 0 // hidden cloze count\n        for (const cloze of clozes) {\n          const existingHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n          if (existingHidden) {\n            revealCloze(cloze);\n          }\n          if (cloze.offsetWidth === 0) {\n            continue\n          }\n          const clozeReplacer = document.createElement(\"span\")\n          const clozeHidden = document.createElement(\"span\")\n          clozeReplacer.classList.add(\"cloze-replacer\")\n          clozeHidden.classList.add(\"cloze-hidden\")\n          while (cloze.childNodes.length > 0) {\n            clozeHidden.appendChild(cloze.childNodes[0])\n          }\n          cloze.appendChild(clozeReplacer)\n          cloze.appendChild(clozeHidden)\n\n          var clozeHints = Persistence.getItem(\"clozeHints\");\n          if (clozeHints && clozeHints[count]) {\n            clozeReplacer.classList.add(\"cloze-hint\")\n            clozeReplacer.innerHTML = clozeHints[count] + CLOZE_REPLACER_SEP\n          } else {\n            clozeReplacer.innerHTML = clozeHider(cloze) + CLOZE_REPLACER_SEP\n          }\n          count += 1\n          document.getElementById(\"button-reveal-next\").style.display = \"inline-block\";\n          if (initial) {\n            cloze.addEventListener(\"touchend\", revealClozeClicked)\n            cloze.addEventListener(\"click\", revealClozeClicked)\n            cloze.classList.add(\"one-by-one\");\n          }\n        }\n\n        // Hide #extra until all clozes are shown\n        const extra = document.getElementById(\"extra\");\n        if (extra) {\n          extra.classList.add(\"hidden\");\n        }\n\n        hideExtra();\n        hideExtraButtons();\n        if (revealAnywhere) {\n          document.documentElement.setAttribute(\"onclick\", \"revealNextCloze(); event.stopPropagation()\")\n        }\n\n\n        // Also hide autoReveal fields\n        for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n          const container = document.querySelector(`[data-name=\"${field}\"]`)\n          if (container) {\n            const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n            if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n              // const link = container.getElementsByTagName(\"a\")[0]\n              const button = container.getElementsByTagName(\"button\")[0]\n              const hint = container.getElementsByTagName(\"div\")[0]\n              button.classList.remove(\"expanded-button\")\n              hint.style.display = \"none\"\n              // link.style.display = \"\"\n            }\n          }\n        }\n      }\n\n      const revealCloze = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        cloze.removeChild(clozeReplacer)\n        cloze.removeChild(clozeHidden)\n        while (clozeHidden.childNodes.length > 0) {\n          cloze.appendChild(clozeHidden.childNodes[0])\n        }\n        maybeRevealExtraField()\n      }\n\n      const revealClozeWord = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        let range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundSpace = setRangeEnd(range, clozeHidden, \"beforeFirstSpace\")\n        if (!foundSpace) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        let fragment = range.extractContents()\n        cloze.insertBefore(fragment, clozeReplacer)\n        // Extract whitespaces after word\n        range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundWord = setRangeEnd(range, clozeHidden, \"beforeFirstChar\")\n        if (!foundWord) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        fragment = range.extractContents();\n        cloze.insertBefore(fragment, clozeReplacer)\n        if (!foundWord) {\n          cloze.removeChild(clozeHidden)\n          cloze.removeChild(clozeReplacer)\n          maybeRevealExtraField()\n          return\n        }\n        clozeReplacer.innerHTML = clozeHider(clozeHidden) + CLOZE_REPLACER_SEP\n        if (clozeReplacer.classList.contains(\"cloze-hint\")) [\n          clozeReplacer.classList.remove(\"cloze-hint\")\n        ]\n        maybeRevealExtraField()\n      }\n\n      const revealNextClozeOf = (type) => {\n        const nextHidden = document.querySelectorAll(\".cloze-hidden\")\n        const nextNextHidden = nextHidden.length > 1 ? true : false\n        if (!nextNextHidden) {\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\";\n        }\n        if (!nextHidden) {\n          return\n        }\n        const cloze = clozeElOfClozeHidden(nextHidden[0]);\n        if (type === \"word\") {\n          revealClozeWord(cloze)\n        } else if (type === \"cloze\") {\n          revealCloze(cloze)\n        } else {\n          console.error(\"Invalid type: \" + type)\n        }\n      }\n\n      const revealClozeClicked = function (ev) {\n        let elem = ev.currentTarget\n        if (!ev.altKey && (revealNextClozeMode !== \"word\")) {\n          revealCloze(elem)\n        } else {\n          revealClozeWord(elem)\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      }\n\n      window.revealNextCloze = function () {\n        revealNextClozeOf(revealNextClozeMode)\n      }\n\n      window.toggleAllCloze = function () {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length > 0) {\n          for (const elem of elems) {\n            const cloze = clozeElOfClozeHidden(elem)\n            revealCloze(cloze)\n          }\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\"\n        } else {\n          hideAllCloze(initial = false)\n        }\n      }\n\n      const clozeElOfClozeHidden = (cloze) => {\n        while (!cloze.classList.contains(\"cloze\")) {\n          cloze = cloze.parentElement;\n        }\n        return cloze;\n      }\n\n      const maybeRevealExtraField = () => {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length == 0) {\n          const extra = document.getElementById(\"extra\")\n          if (extra) {\n            extra.classList.remove(\"hidden\")\n          }\n\n          showExtra();\n          showExtraButtons();\n          document.documentElement.removeAttribute(\"onclick\")\n\n          // Also reveal autoReveal fields\n          for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n            const container = document.querySelector(`[data-name=\"${field}\"]`)\n            if (container) {\n              const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n              if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n                // const link = container.getElementsByTagName(\"a\")[0]\n                const button = container.getElementsByTagName(\"button\")[0]\n                const hint = container.getElementsByTagName(\"div\")[0]\n                button.classList.add(\"expanded-button\")\n                hint.style.display = \"block\"\n                // link.style.display = \"none\"\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * mode: 'beforeFirstSpace' or 'beforeFirstChar'\n       * Return `true` if it exists and setEnd() was called, otherwise `false`\n       */\n      const setRangeEnd = function (range, node, mode) {\n        if (node.nodeType === Node.TEXT_NODE) {\n          const regex = mode === 'beforeFirstSpace' ? /\\s/ : /\\S/\n          const match = node.textContent.match(regex)\n          if (match) {\n            if (match.index === 0) {\n              while (node.previousSibling === null) {\n                node = node.parentElement\n              }\n              range.setEndBefore(node)\n            } else {\n              range.setEnd(node, match.index);\n            }\n            return true;\n          } else {\n            return false;\n          }\n        } else if (mode === 'beforeFirstChar' && isCharNode(node)) {\n          range.setEndBefore(node)\n          return true\n        } else if (!ignoreSpaceInNode(node)) {\n          for (const child of node.childNodes) {\n            if (setRangeEnd(range, child, mode)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }\n\n      const ignoreSpaceInNode = function (node) {\n        return node.tagName === \"MJX-ASSISTIVE-MML\"\n      }\n\n      const isCharNode = function (node) {\n        return [\"IMG\", \"MJX-CONTAINER\"].includes(node.tagName)\n      }\n\n      hideAllCloze(initial = true)\n\n      let isShowNextShortcut = shortcutMatcher(window.revealNextShortcut)\n      let isShowWordShortcut = shortcutMatcher(window.revealNextWordShortcut)\n      let isToggleAllShortcut = shortcutMatcher(window.toggleAllShortcut)\n      ankingAddEventListener(\"keydown\", (ev) => {\n        let next = isShowNextShortcut(ev)\n        let word = isShowWordShortcut(ev)\n        let all = isToggleAllShortcut(ev)\n        if (next) {\n          revealNextClozeOf(\"cloze\")\n        } else if (word) {\n          revealNextClozeOf(\"word\")\n        } else if (all) {\n          toggleAllCloze()\n        } else {\n          return;\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      });\n    })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- MEDITRICKS SNIPPETS DATA -->\n<div id=\"meditricks-mtsp-values\" style=\"display:none;\">\n  <div id=\"meditricks-mtsp-nfname\">_meditricks_nf_v1000_ankizin</div>\n  <div id=\"meditricks-mtsp-nid\">{{Note ID}}</div>\n</div>\n<script src=\"_meditricks_mtsp_scripts_v1000_ankizin.js\"></script>\n<link href=\"_meditricks_mtsp_styles_v1000_ankizin.css\" rel=\"stylesheet\" />\n\n<!-- include \"_meditricks_mtsp_nf_v1000_ankizin.js\" -->\n<!-- include \"_meditricks_mtsp_scripts_v1000_iframe.map\" -->\n<!-- include \"_meditricks_mtsp_mtlogo.webp\" -->\n<!-- include \"_meditricks_mtsp_mt-loading.png\" -->\n<!-- include \"_meditricks_mtsp_mt-loading_night.png\" -->\n\n<!-- //MEDITRICKS SNIPPETS DATA -->\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>",
      "bqfmt": "{{Muskel / Leitungsbahn}}",
      "bafmt": "{{Ursprung}}",
      "bfont": "Helvetica",
      "bsize": 12
    },
    {
      "name": "UrsprungCloze2",
      "ord": 7,
      "qfmt": "<!-- version f0935e4 -->\n{{#Ursprung}}\n{{#UrsprungCloze2}}\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TIMER CONFIG  ##############\n  // Timer config (timer length, timer finished message)\n  var minutes = 0\n  var seconds = 15\n  var timeOverMsg = \"<span style='color:#CC5B5B'>!!!</span>\"\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  // Auto flip to back when One by one mode.\n  var autoflip = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Wo liegt der <i>Ursprung</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" data-card=\"{{Card}}\"><br>{{Ursprung}}</div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\"></div>\n\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<script>\n  //DONT FADE BETWEEN CARDS\n  qFade = 0;\n  if (typeof anki !== 'undefined') anki.qFade = qFade;\n</script>\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    if (!indentation) { return; }\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- CLOZE ONE BY ONE FRONT -->\n<div id=\"one-by-one\" style=\"display: none;\"></div>\n\n<script>\n  /**\n   * Based on the AnKing Notetype, but expanded and modified by phyn.\n   * Credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  Persistence.clear();\n\n  // check if OneByOne is generally enabled for this card\n  var oneByOneFieldEmpty = selectiveOneByOne ? \"{{One by one}}\" === \"\" : true;\n  var clozeOneByOneEnabled = alwaysOneByOne ? true : !oneByOneFieldEmpty;\n\n  // avoid flickering. Must unset this in the back.\n  document.getElementById(\"qa\").style.display = \"none\";\n  var clozeHints = [];\n\n  if (clozeOneByOneEnabled) {\n    // collect hints from front side (independent of whether or not OneByOne is enabled)\n    document.getElementById(\"qa\").classList.add('one-by-one');\n    // Save cloze hints to display in the back\n    var clozes = document.getElementsByClassName(\"cloze\")\n    for (var i = 0; i < clozes.length; i++) {\n      clozes[i].classList.add(\"one-by-one\");\n      if (clozes[i].innerHTML === \"[...]\") {\n        clozeHints.push(\"\")\n      } else {\n        clozeHints.push(clozes[i].innerHTML)\n      }\n    }\n\n    // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n    /**\n     * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n     */\n    const getCardNumber = function () {\n      clz = document.body.className;\n      const regex = /card(\\d+)/gm;\n\n      let clz2;\n      try {\n        clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n      } catch (e) {\n        clz2 = \"\";\n      }\n      const regex2 = /.*?Cloze(\\d+)/gm;\n\n      let m;\n\n      if ((m = regex2.exec(clz2)) !== null) {\n        return m[1];\n      } else if ((m = regex.exec(clz)) !== null) {\n        return m[1];\n      } else {\n        // Should only fire if card is not cloze\n        console.error(\"Cannot find cardN class of body element!\");\n        return \"0\";\n      }\n    }\n\n    var alreadyRendered = false;\n\n    function processSelective1b1() {\n      if (alreadyRendered) return;\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (autoflip && clozeOneByOneEnabled) {\n        if (window.pycmd || window.showAnswer) {\n          // avoid flickering. Must unset this in the back.\n          document.getElementById(\"qa\").style.display = \"none\";\n        }\n        if (window.pycmd) {\n          pycmd(\"ans\")\n        } else if (window.showAnswer) {\n          showAnswer()\n        }\n      } else {\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n      }\n      // AnkiMobile JS API doesn't have one for show answer.\n      // Best alternative is to use Taps/Swipes to show answer.\n\n      alreadyRendered = true;\n    }\n\n    function delayedProcessSelective1b1() {\n      if (window.requestAnimationFrame) window.requestAnimationFrame(processSelective1b1); // less flickering\n      else window.setTimeout(processSelective1b1, 0);\n    };\n\n    window.onload = delayedProcessSelective1b1;\n    if (document.readyState === \"complete\") {\n      delayedProcessSelective1b1();\n    }\n    else {\n      document.addEventListener(\"DOMContentLoaded\", delayedProcessSelective1b1);\n    }\n\n    // Observe document.body class changes to trigger re-rendering.\n    // This is useful, because Anki doesn’t always start with an up-to-date class list:\n    // https://forums.ankiweb.net/t/card-card-classes-only-injected-separately-now/27387.\n    const observer = new MutationObserver(function (mutationsList, observer) {\n      for (let mutation of mutationsList) {\n        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {\n          delayedProcessSelective1b1();\n        }\n      }\n    });\n    observer.observe(document.body, { attributes: true });\n  }\n  Persistence.setItem(\"clozeHints\", clozeHints);\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>\n\n\n{{/UrsprungCloze2}}\n{{/Ursprung}}",
      "afmt": "<!-- version f0935e4 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n<div id=\"back\"></div>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Eigene Notizen & Bilder\": \"Alt + 1\",\n    \"Eigene Prüfungsfragen\": \"Alt + 2\",\n    \"Definitionen\": \"Alt + 3\",\n    \"Merksprüche\": \"Alt + 4\",\n    \"Klinik\": \"Alt + 5\",\n    \"Präparat\": \"Alt + 6\",\n    \"Memes\": \"Alt + 7\",\n    \"linkContainer\": \"Alt + L\",\n    \"Meditricks\": \"Alt + M\",\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Eigene Notizen & Bilder\": false,\n    \"Eigene Prüfungsfragen\": false,\n    \"Definitionen\": false,\n    \"Merksprüche\": false,\n    \"Klinik\": false,\n    \"Präparat\": false,\n    \"Memes\": false,\n    \"linkContainer\": true,\n    \"Meditricks\": false,\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  var revealNextShortcut = \"N\"\n  var revealNextWordShortcut = \"Shift + N\"\n  var toggleAllShortcut = \",\"\n\n  // Enables revealing of next Cloze by simply clicking / tapping anywhere on the card (except the buttons)\n  var revealAnywhere = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // Changes how \"Reveal Next\" and clicking behaves. Either \"cloze\" or \"word\".\n  // \"word\" reveals word by word. \n  var revealNextClozeMode = \"cloze\"\n\n  // Changes how fields with additional information are displayed.\n  // true displays fields with additional information only if all clozes are revealed.\n  var hideAdditional = true;\n  var hideAdditionalButtons = true;\n\n  // What cloze is hidden with\n  var clozeHider = (elem) => \"[&nbsp;_&nbsp;]\"\n  /*\n  You can replace the above line with below examples. '█' or '_' works well for hiding clozes.\n  \n  // Fixed length:\n  var clozeHider = (elem) => \"███\"\n  // Replace each character with \"█\":\n  var clozeHider = (elem) => \"█\".repeat(elem.textContent.length)\n  // Show whitespaces:\n  var clozeHider = (elem) => \"[\" + elem.textContent.split(\" \").map((t) => \"█\".repeat(t.length)).join(\" \") + \"]\"\n  // Color-filled box (doesn't hide images):\n  var clozeHider = (elem) => `<span style=\"background-color: red; color: transparent;\">${elem.innerHTML}</span>`\n  */\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Wo liegt der <i>Ursprung</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" class=\"clozefield\" data-card=\"{{Card}}\"><br>{{Ursprung}}</div>\n\n    <!-- ClOZE ONE BY ONE BUTTONS -->\n    <div id=\"onebyone-buttons\" class=\"onebyone\">\n      <br>\n      <button id=\"button-reveal-next\" class=\"button-general button-one-by-one\"\n        onclick=\"revealNextCloze(); event.stopPropagation()\">Reveal Next</button>\n      <button id=\"button-toggle-all\" class=\"button-general button-one-by-one\"\n        onclick=\"toggleAllCloze(); event.stopPropagation()\">Toggle All</button>\n    </div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- BUTTON FIELDS -->\n    {{#Eigene Notizen & Bilder}}\n    <span id=\"hint-zusatz\" class=\"hintBtn\" data-name=\"Eigene Notizen & Bilder\" style=\"display: none;\">\n      <button id=\"button-zusatz\" class=\"button-general\" onclick=\"toggleHintBtn('hint-zusatz'); event.stopPropagation()\">\n        <img src=\"__zusatz.svg\" style=\"height: 10px;\"> Eigene Notizen & Bilder\n      </button>\n      <div dir=\"auto\" id=\"zusatz\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Notizen & Bilder}}</div>\n    </span>\n    {{/Eigene Notizen & Bilder}}\n\n    {{#Eigene Prüfungsfragen}}\n    <span id=\"hint-hammer\" class=\"hintBtn\" data-name=\"Eigene Prüfungsfragen\" style=\"display: none;\">\n      <button id=\"button-hammer\" class=\"button-general\" onclick=\"toggleHintBtn('hint-hammer'); event.stopPropagation()\">\n        <img src=\"__hammer.svg\" style=\"height: 10px;\"> Eigene Prüfungsfragen\n      </button>\n      <div dir=\"auto\" id=\"hammer\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Prüfungsfragen}}</div>\n    </span>\n    {{/Eigene Prüfungsfragen}}\n\n    {{#Definitionen}}\n    <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Definitionen\" style=\"display: none;\">\n      <button id=\"button-definition\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Definitionen\n      </button>\n      <div dir=\"auto\" id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Definitionen}}</div>\n    </span>\n    {{/Definitionen}}\n\n    {{#Merksprüche}}\n    <span id=\"hint-merksprueche\" class=\"hintBtn\" data-name=\"Merksprüche\" style=\"display: none;\">\n      <button id=\"button-merksprueche\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-merksprueche'); event.stopPropagation()\">\n        <img src=\"__merkhilfe.svg\" style=\"height: 10px;\"> Merksprüche\n      </button>\n      <div dir=\"auto\" id=\"merksprueche\" class=\"hints\" style=\"display: none;\">{{edit:Merksprüche}}</div>\n    </span>\n    {{/Merksprüche}}\n\n    {{#Klinik}}\n    <span id=\"hint-klinik\" class=\"hintBtn\" data-name=\"Klinik\" style=\"display: none;\">\n      <button id=\"button-klinik\" class=\"button-general\" onclick=\"toggleHintBtn('hint-klinik'); event.stopPropagation()\">\n        <img src=\"__stethoscope.svg\" style=\"height: 10px;\"> Klinik\n      </button>\n      <div dir=\"auto\" id=\"klinik\" class=\"hints\" style=\"display: none;\">{{edit:Klinik}}</div>\n    </span>\n    {{/Klinik}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-praeparat\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n        </button>\n      </a>\n    </span>\n    {{/Präparat}}\n\n    {{#Virtuelle Mikroskopie}}\n    <span id=\"hint-microscope-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Virtuelle Mikroskopie}}\">\n        <button id=\"button-microscope\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Virtuelle Mikroskopie\n        </button>\n      </a>\n    </span>\n    {{/Virtuelle Mikroskopie}}\n\n    {{#Smart Zoom}}\n    <span id=\"hint-smartzoom-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-smartzoom\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Smart Zoom\n        </button>\n      </a>\n    </span>\n    {{/Smart Zoom}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat\" class=\"hintBtn\" data-name=\"Präparat\" style=\"display: none;\">\n      <button id=\"button-praeparat\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-praeparat'); event.stopPropagation()\">\n        <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n      </button>\n      <div dir=\"auto\" id=\"praeparat\" class=\"hints\" style=\"display: none;\">{{edit:Präparat}}</div>\n    </span>\n    {{/Präparat}}\n\n    {{#Memes}}\n    <span id=\"hint-memes\" class=\"hintBtn\" data-name=\"Memes\" style=\"display: none;\">\n      <button id=\"button-memes\" class=\"button-general\" onclick=\"toggleHintBtn('hint-memes'); event.stopPropagation()\">\n        <img src=\"__sonstiges.svg\" style=\"height: 10px;\"> Memes\n      </button>\n      <div dir=\"auto\" id=\"memes\" class=\"hints\" style=\"display: none;\">{{edit:Memes}}</div>\n    </span>\n    {{/Memes}}\n\n    <!-- LINEBREAKS IF BUTTONS EXIST -->\n    <script>\n      var array = [`{{Eigene Notizen & Bilder}}`, `{{Eigene Prüfungsfragen}}`, `{{Definitionen}}`, `{{Merksprüche}}`, `{{Klinik}}`, `{{Präparat}}`, `{{Memes}}`];\n      var anyistrue = (element) => element;\n      if (array.some(anyistrue)) {\n        document.getElementById(\"linebreaksIfButtons\").innerHTML = \"<br>\";\n      }\n    </script>\n    <div id=\"linebreaksIfButtons\"></div>\n\n    <!-- Extra field -->\n    {{#Extra}}\n    <div id=\"extra\" style=\"display: none;\">\n      <br>{{edit:Extra}}<br><br>\n    </div>\n    {{/Extra}}\n\n    <!-- Image field -->\n    {{#Bild}}\n    <div id=\"image\" style=\"display: none;\">\n      {{edit:Bild}}<br><br></div>\n    {{/Bild}}\n    {{^Bild}}\n    <span id=\"image\" style=\"display: none;\"></span>\n    {{/Bild}}\n    {{#Bild}}\n    <span id=\"hint-image\" style=\"display: none;\">\n      <button id=\"button-image\" class=\"button-general\"\n        onclick=\"var image = document.getElementById('image'); if (image.style.display == 'none') { image.style.display = 'block' } else { image.style.display = 'none' }; event.stopPropagation()\">\n        <img src=\"__image.svg\" style=\"height: 10px;\"> Abbildung\n      </button>\n    </span>\n    {{/Bild}}\n\n    <span id=\"hint-uafi\" class=\"hintBtn\" data-name=\"Ursprung, Ansatz, Verlauf, Funktion, Innervation, Äste\"\n      style=\"display: none;\">\n      <button id=\"button-uafi\" class=\"button-general expanded-button\"\n        onclick=\"toggleHintBtn('hint-uafi'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Weitere Informationen\n      </button>\n      <div id=\"uafi\" class=\"hints\" style=\"display: block;\">\n        <table class=\"uncloze\">\n          {{#Ursprung}}\n          <tr class=\"uafi-element\" id=\"Ursprung\">\n            <td><i>Ursprung</i></td>\n            <td>{{Ursprung}}</td>\n          </tr>\n          {{/Ursprung}}\n          {{#Ansatz}}\n          <tr class=\"uafi-element\" id=\"Ansatz\">\n            <td><i>Ansatz</i></td>\n            <td>{{Ansatz}}</td>\n          </tr>\n          {{/Ansatz}}\n          {{#Verlauf}}\n          <tr class=\"uafi-element\" id=\"Verlauf\">\n            <td><i>Verlauf</i></td>\n            <td>{{Verlauf}}</td>\n          </tr>\n          {{/Verlauf}}\n          {{#Funktion}}\n          <tr class=\"uafi-element\" id=\"Funktion\">\n            <td><i>Funktion</i></td>\n            <td>{{Funktion}}</td>\n          </tr>\n          {{/Funktion}}\n          {{#Innervation}}\n          <tr class=\"uafi-element\" id=\"Innervation\">\n            <td><i>Innervation</i></td>\n            <td>{{Innervation}}</td>\n          </tr>\n          {{/Innervation}}\n          {{#Äste}}\n          <tr class=\"uafi-element\" id=\"Äste\">\n            <td><i>Äste</i></td>\n            <td>{{Äste}}</td>\n          </tr>\n          {{/Äste}}\n        </table>\n      </div>\n\n      <script>\n        // iterate over all uafi-elements and hide only the one\n        // that is equal to the card's answer (i.e., value of {{Card}})\n        var uafiElements = document.getElementsByClassName(\"uafi-element\");\n        for (var i = 0; i < uafiElements.length; i++) {\n          if (((\"{{Card}}\").startsWith(uafiElements[i].id))) {\n            uafiElements[i].remove()\n          }\n        }\n      </script>\n    </span>\n\n    {{#AMBOSS-Link}}\n    <span id=\"hint-amboss\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:AMBOSS-Link}}\">\n        <button id=\"button-amboss\" class=\"button-general\">\n          <img src=\"__amboss.svg\" style=\"height: 10px;\"> AMBOSS&#8203;\n        </button>\n      </a>\n    </span>\n    {{/AMBOSS-Link}}\n\n    {{#Thieme via medici-Link}}\n    <span id=\"hint-thieme\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Thieme via medici-Link}}\">\n        <button id=\"button-thieme\" class=\"button-general\">\n          <img id=\"button-thieme-img\" src=\"__thieme-heart.svg\" style=\"height: 10px;\"> Thieme via medici\n        </button>\n      </a>\n    </span>\n    {{/Thieme via medici-Link}}\n\n    {{#Meditricks}}\n    <span id=\"hint-meditricks\" class=\"hintBtn\" data-name=\"Meditricks\" style=\"display: none;\">\n      <button id=\"button-meditricks\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-meditricks'); event.stopPropagation()\">\n        <img src=\"__meditricks.svg\" style=\"height: 10px;\"> Meditricks\n      </button>\n      <div dir=\"auto\" id=\"meditricks\" class=\"hints\" style=\"display: none;\">{{edit:Meditricks}}</div>\n    </span>\n    {{/Meditricks}}\n\n    {{#weitere Links}}\n    <span id=\"hint-linkcontainer\" class=\"hintBtn\" data-name=\"linkContainer\" style=\"display: none;\">\n      <button id=\"button-linkcontainer\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-linkcontainer'); event.stopPropagation()\">\n        <img src=\"__internet.svg\" style=\"height: 10px;\"> weitere Links\n      </button>\n      <div id=\"linkcontainer\" class=\"hints\" style=\"display: none;\"></div>\n      <span id=\"linkContainerLinks\" style=\"display: none;\">{{edit:weitere Links}}</span>\n    </span>\n    {{/weitere Links}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n  try {\n    for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n      href = link.href\n      text = link.innerText\n\n      const el = document.createElement('a');\n      el.setAttribute('href', link.href);\n\n      const btn = document.createElement('button');\n      btn.classList.add('button-general');\n      btn.classList.add('expanded-button');\n\n      domain = href.replace(/.+\\/\\/|(www|flexikon|register|de|next|com).|\\..+/g, '');\n      domainDict = {\n        \"amboss\": \"__amboss.svg\",\n        \"wikipedia\": \"__wikipedia.svg\",\n        \"doccheck\": \"__doccheck.png\",\n        \"notfallguru\": \"__notfallguru.svg\",\n        \"awmf\": \"__awmf.svg\",\n        \"gelbe-liste\": \"__gelbe-liste.png\",\n        \"embryotox\": \"__embryotox.svg\",\n        \"radiopaedia\": \"__radiopaedia.png\",\n        \"orphanet\": \"__orphanet.png\",\n      }\n      if (domain in domainDict) {\n        icon = domainDict[domain]\n      } else {\n        icon = \"__internet.svg\"\n      }\n\n      const img = document.createElement('img');\n      img.setAttribute('src', icon);\n      img.setAttribute('style', 'height: 10px;');\n\n      btn.appendChild(img);\n      btn.innerHTML = btn.innerHTML + \" \" + text;\n\n      el.appendChild(btn);\n\n      document.getElementById(\"linkcontainer\").appendChild(el)\n    }\n  }\n  catch (err) {\n    console.log(err)\n  }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-uafi\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- AUTOFLIP BACK SCRIPT -->\n<script>\n  // autoflip hides card in front template\n  document.getElementById(\"qa\").style.removeProperty(\"display\")\n</script>\n\n<!-- CLOZE ONE BY ONE SCRIPT -->\n<style>\n  .cloze-replacer:hover {\n    cursor: pointer;\n  }\n\n  .cloze-hidden {\n    display: none;\n  }\n\n  .cloze-replacer .hidden {\n    display: none;\n  }\n\n  #extra.hidden {\n    display: none;\n  }\n</style>\n\n<!--\n Based on the AnKing Notetype, but expanded and modified by phyn.\n Credit to the original authors, except where modified or otherwise indicated.\n-->\n\n<script>\n    (function () {\n      // enables cloze one-by-one even when one-by-one field is empty\n      // minNumberOfClozes is still considered in this case\n      // overridden in importance by selectiveOneByOne\n      var clozeOneByOneEnabled = true;\n\n      // remove the clickAnywhere function from global scope\n      document.documentElement.removeAttribute(\"onclick\")\n\n      // --- CHECK IF ONE BY ONE IS GENERALLY ENABLED FOR THIS NOTE ---\n      var oneByOneFieldNotEmpty = \"{{One by one}}\" !== \"\";\n      try {\n        clozeOneByOneEnabled = alwaysOneByOne || oneByOneFieldNotEmpty;\n      } catch (exception) {\n        console.log(exception)\n      }\n\n      /**\n   * helper functions to show / hide fields containing additional information\n   */\n      const showExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const hideExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const buttonIds = [\n        \"hint-zusatz\",\n        \"hint-definition\",\n        \"hint-hammer\",\n        \"hint-klinik\",\n        \"hint-praeparat\",\n        \"hint-microscope\",\n        \"hint-smartzoom\",\n        \"hint-histotrainer\",\n        \"hint-uafi\",\n        \"hint-merksprueche\",\n        \"hint-memes\",\n        \"hint-image\",\n        \"hint-amboss\",\n        \"hint-thieme\",\n        \"hint-meditricks\",\n        \"hint-linkcontainer\",\n      ];\n\n      const showExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document\n              .getElementById(buttonIds[button])\n              .style.removeProperty(\"display\");\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n      const hideExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document.getElementById(buttonIds[button]).style.display = \"none\";\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n\n      // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n      /**\n       * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n       */\n      const getCardNumber = function () {\n        clz = document.body.className;\n        const regex = /card(\\d+)/gm;\n\n        let clz2;\n        try {\n          clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n        } catch (e) {\n          clz2 = \"\";\n        }\n        const regex2 = /.*?Cloze(\\d+)/gm;\n\n        let m;\n\n        if ((m = regex2.exec(clz2)) !== null) {\n          return m[1];\n        } else if ((m = regex.exec(clz)) !== null) {\n          return m[1];\n        } else {\n          // Should only fire if card is not cloze\n          console.error(\"Cannot find cardN class of body element!\");\n          return \"0\";\n        }\n      }\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (!clozeOneByOneEnabled) {\n        showExtra()\n        showExtraButtons()\n        document.getElementById(\"onebyone-buttons\").style.display = \"none\"\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n        return\n      }\n\n      // Needed for amboss to recognize first word in .cloze-hidden\n      const CLOZE_REPLACER_SEP = \"<span class='hidden'> </span>\"\n\n      const hideAllCloze = function (initial) {\n        let clozes = document.getElementsByClassName(\"cloze\")\n        let count = 0 // hidden cloze count\n        for (const cloze of clozes) {\n          const existingHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n          if (existingHidden) {\n            revealCloze(cloze);\n          }\n          if (cloze.offsetWidth === 0) {\n            continue\n          }\n          const clozeReplacer = document.createElement(\"span\")\n          const clozeHidden = document.createElement(\"span\")\n          clozeReplacer.classList.add(\"cloze-replacer\")\n          clozeHidden.classList.add(\"cloze-hidden\")\n          while (cloze.childNodes.length > 0) {\n            clozeHidden.appendChild(cloze.childNodes[0])\n          }\n          cloze.appendChild(clozeReplacer)\n          cloze.appendChild(clozeHidden)\n\n          var clozeHints = Persistence.getItem(\"clozeHints\");\n          if (clozeHints && clozeHints[count]) {\n            clozeReplacer.classList.add(\"cloze-hint\")\n            clozeReplacer.innerHTML = clozeHints[count] + CLOZE_REPLACER_SEP\n          } else {\n            clozeReplacer.innerHTML = clozeHider(cloze) + CLOZE_REPLACER_SEP\n          }\n          count += 1\n          document.getElementById(\"button-reveal-next\").style.display = \"inline-block\";\n          if (initial) {\n            cloze.addEventListener(\"touchend\", revealClozeClicked)\n            cloze.addEventListener(\"click\", revealClozeClicked)\n            cloze.classList.add(\"one-by-one\");\n          }\n        }\n\n        // Hide #extra until all clozes are shown\n        const extra = document.getElementById(\"extra\");\n        if (extra) {\n          extra.classList.add(\"hidden\");\n        }\n\n        hideExtra();\n        hideExtraButtons();\n        if (revealAnywhere) {\n          document.documentElement.setAttribute(\"onclick\", \"revealNextCloze(); event.stopPropagation()\")\n        }\n\n\n        // Also hide autoReveal fields\n        for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n          const container = document.querySelector(`[data-name=\"${field}\"]`)\n          if (container) {\n            const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n            if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n              // const link = container.getElementsByTagName(\"a\")[0]\n              const button = container.getElementsByTagName(\"button\")[0]\n              const hint = container.getElementsByTagName(\"div\")[0]\n              button.classList.remove(\"expanded-button\")\n              hint.style.display = \"none\"\n              // link.style.display = \"\"\n            }\n          }\n        }\n      }\n\n      const revealCloze = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        cloze.removeChild(clozeReplacer)\n        cloze.removeChild(clozeHidden)\n        while (clozeHidden.childNodes.length > 0) {\n          cloze.appendChild(clozeHidden.childNodes[0])\n        }\n        maybeRevealExtraField()\n      }\n\n      const revealClozeWord = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        let range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundSpace = setRangeEnd(range, clozeHidden, \"beforeFirstSpace\")\n        if (!foundSpace) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        let fragment = range.extractContents()\n        cloze.insertBefore(fragment, clozeReplacer)\n        // Extract whitespaces after word\n        range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundWord = setRangeEnd(range, clozeHidden, \"beforeFirstChar\")\n        if (!foundWord) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        fragment = range.extractContents();\n        cloze.insertBefore(fragment, clozeReplacer)\n        if (!foundWord) {\n          cloze.removeChild(clozeHidden)\n          cloze.removeChild(clozeReplacer)\n          maybeRevealExtraField()\n          return\n        }\n        clozeReplacer.innerHTML = clozeHider(clozeHidden) + CLOZE_REPLACER_SEP\n        if (clozeReplacer.classList.contains(\"cloze-hint\")) [\n          clozeReplacer.classList.remove(\"cloze-hint\")\n        ]\n        maybeRevealExtraField()\n      }\n\n      const revealNextClozeOf = (type) => {\n        const nextHidden = document.querySelectorAll(\".cloze-hidden\")\n        const nextNextHidden = nextHidden.length > 1 ? true : false\n        if (!nextNextHidden) {\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\";\n        }\n        if (!nextHidden) {\n          return\n        }\n        const cloze = clozeElOfClozeHidden(nextHidden[0]);\n        if (type === \"word\") {\n          revealClozeWord(cloze)\n        } else if (type === \"cloze\") {\n          revealCloze(cloze)\n        } else {\n          console.error(\"Invalid type: \" + type)\n        }\n      }\n\n      const revealClozeClicked = function (ev) {\n        let elem = ev.currentTarget\n        if (!ev.altKey && (revealNextClozeMode !== \"word\")) {\n          revealCloze(elem)\n        } else {\n          revealClozeWord(elem)\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      }\n\n      window.revealNextCloze = function () {\n        revealNextClozeOf(revealNextClozeMode)\n      }\n\n      window.toggleAllCloze = function () {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length > 0) {\n          for (const elem of elems) {\n            const cloze = clozeElOfClozeHidden(elem)\n            revealCloze(cloze)\n          }\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\"\n        } else {\n          hideAllCloze(initial = false)\n        }\n      }\n\n      const clozeElOfClozeHidden = (cloze) => {\n        while (!cloze.classList.contains(\"cloze\")) {\n          cloze = cloze.parentElement;\n        }\n        return cloze;\n      }\n\n      const maybeRevealExtraField = () => {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length == 0) {\n          const extra = document.getElementById(\"extra\")\n          if (extra) {\n            extra.classList.remove(\"hidden\")\n          }\n\n          showExtra();\n          showExtraButtons();\n          document.documentElement.removeAttribute(\"onclick\")\n\n          // Also reveal autoReveal fields\n          for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n            const container = document.querySelector(`[data-name=\"${field}\"]`)\n            if (container) {\n              const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n              if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n                // const link = container.getElementsByTagName(\"a\")[0]\n                const button = container.getElementsByTagName(\"button\")[0]\n                const hint = container.getElementsByTagName(\"div\")[0]\n                button.classList.add(\"expanded-button\")\n                hint.style.display = \"block\"\n                // link.style.display = \"none\"\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * mode: 'beforeFirstSpace' or 'beforeFirstChar'\n       * Return `true` if it exists and setEnd() was called, otherwise `false`\n       */\n      const setRangeEnd = function (range, node, mode) {\n        if (node.nodeType === Node.TEXT_NODE) {\n          const regex = mode === 'beforeFirstSpace' ? /\\s/ : /\\S/\n          const match = node.textContent.match(regex)\n          if (match) {\n            if (match.index === 0) {\n              while (node.previousSibling === null) {\n                node = node.parentElement\n              }\n              range.setEndBefore(node)\n            } else {\n              range.setEnd(node, match.index);\n            }\n            return true;\n          } else {\n            return false;\n          }\n        } else if (mode === 'beforeFirstChar' && isCharNode(node)) {\n          range.setEndBefore(node)\n          return true\n        } else if (!ignoreSpaceInNode(node)) {\n          for (const child of node.childNodes) {\n            if (setRangeEnd(range, child, mode)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }\n\n      const ignoreSpaceInNode = function (node) {\n        return node.tagName === \"MJX-ASSISTIVE-MML\"\n      }\n\n      const isCharNode = function (node) {\n        return [\"IMG\", \"MJX-CONTAINER\"].includes(node.tagName)\n      }\n\n      hideAllCloze(initial = true)\n\n      let isShowNextShortcut = shortcutMatcher(window.revealNextShortcut)\n      let isShowWordShortcut = shortcutMatcher(window.revealNextWordShortcut)\n      let isToggleAllShortcut = shortcutMatcher(window.toggleAllShortcut)\n      ankingAddEventListener(\"keydown\", (ev) => {\n        let next = isShowNextShortcut(ev)\n        let word = isShowWordShortcut(ev)\n        let all = isToggleAllShortcut(ev)\n        if (next) {\n          revealNextClozeOf(\"cloze\")\n        } else if (word) {\n          revealNextClozeOf(\"word\")\n        } else if (all) {\n          toggleAllCloze()\n        } else {\n          return;\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      });\n    })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- MEDITRICKS SNIPPETS DATA -->\n<div id=\"meditricks-mtsp-values\" style=\"display:none;\">\n  <div id=\"meditricks-mtsp-nfname\">_meditricks_nf_v1000_ankizin</div>\n  <div id=\"meditricks-mtsp-nid\">{{Note ID}}</div>\n</div>\n<script src=\"_meditricks_mtsp_scripts_v1000_ankizin.js\"></script>\n<link href=\"_meditricks_mtsp_styles_v1000_ankizin.css\" rel=\"stylesheet\" />\n\n<!-- include \"_meditricks_mtsp_nf_v1000_ankizin.js\" -->\n<!-- include \"_meditricks_mtsp_scripts_v1000_iframe.map\" -->\n<!-- include \"_meditricks_mtsp_mtlogo.webp\" -->\n<!-- include \"_meditricks_mtsp_mt-loading.png\" -->\n<!-- include \"_meditricks_mtsp_mt-loading_night.png\" -->\n\n<!-- //MEDITRICKS SNIPPETS DATA -->\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>",
      "bqfmt": "{{Muskel / Leitungsbahn}}",
      "bafmt": "{{Ursprung}}",
      "bfont": "Helvetica",
      "bsize": 12
    },
    {
      "name": "UrsprungCloze3",
      "ord": 8,
      "qfmt": "<!-- version f0935e4 -->\n{{#Ursprung}}\n{{#UrsprungCloze3}}\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TIMER CONFIG  ##############\n  // Timer config (timer length, timer finished message)\n  var minutes = 0\n  var seconds = 15\n  var timeOverMsg = \"<span style='color:#CC5B5B'>!!!</span>\"\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  // Auto flip to back when One by one mode.\n  var autoflip = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Wo liegt der <i>Ursprung</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" data-card=\"{{Card}}\"><br>{{Ursprung}}</div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\"></div>\n\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<script>\n  //DONT FADE BETWEEN CARDS\n  qFade = 0;\n  if (typeof anki !== 'undefined') anki.qFade = qFade;\n</script>\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    if (!indentation) { return; }\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- CLOZE ONE BY ONE FRONT -->\n<div id=\"one-by-one\" style=\"display: none;\"></div>\n\n<script>\n  /**\n   * Based on the AnKing Notetype, but expanded and modified by phyn.\n   * Credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  Persistence.clear();\n\n  // check if OneByOne is generally enabled for this card\n  var oneByOneFieldEmpty = selectiveOneByOne ? \"{{One by one}}\" === \"\" : true;\n  var clozeOneByOneEnabled = alwaysOneByOne ? true : !oneByOneFieldEmpty;\n\n  // avoid flickering. Must unset this in the back.\n  document.getElementById(\"qa\").style.display = \"none\";\n  var clozeHints = [];\n\n  if (clozeOneByOneEnabled) {\n    // collect hints from front side (independent of whether or not OneByOne is enabled)\n    document.getElementById(\"qa\").classList.add('one-by-one');\n    // Save cloze hints to display in the back\n    var clozes = document.getElementsByClassName(\"cloze\")\n    for (var i = 0; i < clozes.length; i++) {\n      clozes[i].classList.add(\"one-by-one\");\n      if (clozes[i].innerHTML === \"[...]\") {\n        clozeHints.push(\"\")\n      } else {\n        clozeHints.push(clozes[i].innerHTML)\n      }\n    }\n\n    // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n    /**\n     * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n     */\n    const getCardNumber = function () {\n      clz = document.body.className;\n      const regex = /card(\\d+)/gm;\n\n      let clz2;\n      try {\n        clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n      } catch (e) {\n        clz2 = \"\";\n      }\n      const regex2 = /.*?Cloze(\\d+)/gm;\n\n      let m;\n\n      if ((m = regex2.exec(clz2)) !== null) {\n        return m[1];\n      } else if ((m = regex.exec(clz)) !== null) {\n        return m[1];\n      } else {\n        // Should only fire if card is not cloze\n        console.error(\"Cannot find cardN class of body element!\");\n        return \"0\";\n      }\n    }\n\n    var alreadyRendered = false;\n\n    function processSelective1b1() {\n      if (alreadyRendered) return;\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (autoflip && clozeOneByOneEnabled) {\n        if (window.pycmd || window.showAnswer) {\n          // avoid flickering. Must unset this in the back.\n          document.getElementById(\"qa\").style.display = \"none\";\n        }\n        if (window.pycmd) {\n          pycmd(\"ans\")\n        } else if (window.showAnswer) {\n          showAnswer()\n        }\n      } else {\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n      }\n      // AnkiMobile JS API doesn't have one for show answer.\n      // Best alternative is to use Taps/Swipes to show answer.\n\n      alreadyRendered = true;\n    }\n\n    function delayedProcessSelective1b1() {\n      if (window.requestAnimationFrame) window.requestAnimationFrame(processSelective1b1); // less flickering\n      else window.setTimeout(processSelective1b1, 0);\n    };\n\n    window.onload = delayedProcessSelective1b1;\n    if (document.readyState === \"complete\") {\n      delayedProcessSelective1b1();\n    }\n    else {\n      document.addEventListener(\"DOMContentLoaded\", delayedProcessSelective1b1);\n    }\n\n    // Observe document.body class changes to trigger re-rendering.\n    // This is useful, because Anki doesn’t always start with an up-to-date class list:\n    // https://forums.ankiweb.net/t/card-card-classes-only-injected-separately-now/27387.\n    const observer = new MutationObserver(function (mutationsList, observer) {\n      for (let mutation of mutationsList) {\n        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {\n          delayedProcessSelective1b1();\n        }\n      }\n    });\n    observer.observe(document.body, { attributes: true });\n  }\n  Persistence.setItem(\"clozeHints\", clozeHints);\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>\n\n\n{{/UrsprungCloze3}}\n{{/Ursprung}}",
      "afmt": "<!-- version f0935e4 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n<div id=\"back\"></div>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Eigene Notizen & Bilder\": \"Alt + 1\",\n    \"Eigene Prüfungsfragen\": \"Alt + 2\",\n    \"Definitionen\": \"Alt + 3\",\n    \"Merksprüche\": \"Alt + 4\",\n    \"Klinik\": \"Alt + 5\",\n    \"Präparat\": \"Alt + 6\",\n    \"Memes\": \"Alt + 7\",\n    \"linkContainer\": \"Alt + L\",\n    \"Meditricks\": \"Alt + M\",\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Eigene Notizen & Bilder\": false,\n    \"Eigene Prüfungsfragen\": false,\n    \"Definitionen\": false,\n    \"Merksprüche\": false,\n    \"Klinik\": false,\n    \"Präparat\": false,\n    \"Memes\": false,\n    \"linkContainer\": true,\n    \"Meditricks\": false,\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  var revealNextShortcut = \"N\"\n  var revealNextWordShortcut = \"Shift + N\"\n  var toggleAllShortcut = \",\"\n\n  // Enables revealing of next Cloze by simply clicking / tapping anywhere on the card (except the buttons)\n  var revealAnywhere = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // Changes how \"Reveal Next\" and clicking behaves. Either \"cloze\" or \"word\".\n  // \"word\" reveals word by word. \n  var revealNextClozeMode = \"cloze\"\n\n  // Changes how fields with additional information are displayed.\n  // true displays fields with additional information only if all clozes are revealed.\n  var hideAdditional = true;\n  var hideAdditionalButtons = true;\n\n  // What cloze is hidden with\n  var clozeHider = (elem) => \"[&nbsp;_&nbsp;]\"\n  /*\n  You can replace the above line with below examples. '█' or '_' works well for hiding clozes.\n  \n  // Fixed length:\n  var clozeHider = (elem) => \"███\"\n  // Replace each character with \"█\":\n  var clozeHider = (elem) => \"█\".repeat(elem.textContent.length)\n  // Show whitespaces:\n  var clozeHider = (elem) => \"[\" + elem.textContent.split(\" \").map((t) => \"█\".repeat(t.length)).join(\" \") + \"]\"\n  // Color-filled box (doesn't hide images):\n  var clozeHider = (elem) => `<span style=\"background-color: red; color: transparent;\">${elem.innerHTML}</span>`\n  */\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Wo liegt der <i>Ursprung</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" class=\"clozefield\" data-card=\"{{Card}}\"><br>{{Ursprung}}</div>\n\n    <!-- ClOZE ONE BY ONE BUTTONS -->\n    <div id=\"onebyone-buttons\" class=\"onebyone\">\n      <br>\n      <button id=\"button-reveal-next\" class=\"button-general button-one-by-one\"\n        onclick=\"revealNextCloze(); event.stopPropagation()\">Reveal Next</button>\n      <button id=\"button-toggle-all\" class=\"button-general button-one-by-one\"\n        onclick=\"toggleAllCloze(); event.stopPropagation()\">Toggle All</button>\n    </div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- BUTTON FIELDS -->\n    {{#Eigene Notizen & Bilder}}\n    <span id=\"hint-zusatz\" class=\"hintBtn\" data-name=\"Eigene Notizen & Bilder\" style=\"display: none;\">\n      <button id=\"button-zusatz\" class=\"button-general\" onclick=\"toggleHintBtn('hint-zusatz'); event.stopPropagation()\">\n        <img src=\"__zusatz.svg\" style=\"height: 10px;\"> Eigene Notizen & Bilder\n      </button>\n      <div dir=\"auto\" id=\"zusatz\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Notizen & Bilder}}</div>\n    </span>\n    {{/Eigene Notizen & Bilder}}\n\n    {{#Eigene Prüfungsfragen}}\n    <span id=\"hint-hammer\" class=\"hintBtn\" data-name=\"Eigene Prüfungsfragen\" style=\"display: none;\">\n      <button id=\"button-hammer\" class=\"button-general\" onclick=\"toggleHintBtn('hint-hammer'); event.stopPropagation()\">\n        <img src=\"__hammer.svg\" style=\"height: 10px;\"> Eigene Prüfungsfragen\n      </button>\n      <div dir=\"auto\" id=\"hammer\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Prüfungsfragen}}</div>\n    </span>\n    {{/Eigene Prüfungsfragen}}\n\n    {{#Definitionen}}\n    <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Definitionen\" style=\"display: none;\">\n      <button id=\"button-definition\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Definitionen\n      </button>\n      <div dir=\"auto\" id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Definitionen}}</div>\n    </span>\n    {{/Definitionen}}\n\n    {{#Merksprüche}}\n    <span id=\"hint-merksprueche\" class=\"hintBtn\" data-name=\"Merksprüche\" style=\"display: none;\">\n      <button id=\"button-merksprueche\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-merksprueche'); event.stopPropagation()\">\n        <img src=\"__merkhilfe.svg\" style=\"height: 10px;\"> Merksprüche\n      </button>\n      <div dir=\"auto\" id=\"merksprueche\" class=\"hints\" style=\"display: none;\">{{edit:Merksprüche}}</div>\n    </span>\n    {{/Merksprüche}}\n\n    {{#Klinik}}\n    <span id=\"hint-klinik\" class=\"hintBtn\" data-name=\"Klinik\" style=\"display: none;\">\n      <button id=\"button-klinik\" class=\"button-general\" onclick=\"toggleHintBtn('hint-klinik'); event.stopPropagation()\">\n        <img src=\"__stethoscope.svg\" style=\"height: 10px;\"> Klinik\n      </button>\n      <div dir=\"auto\" id=\"klinik\" class=\"hints\" style=\"display: none;\">{{edit:Klinik}}</div>\n    </span>\n    {{/Klinik}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-praeparat\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n        </button>\n      </a>\n    </span>\n    {{/Präparat}}\n\n    {{#Virtuelle Mikroskopie}}\n    <span id=\"hint-microscope-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Virtuelle Mikroskopie}}\">\n        <button id=\"button-microscope\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Virtuelle Mikroskopie\n        </button>\n      </a>\n    </span>\n    {{/Virtuelle Mikroskopie}}\n\n    {{#Smart Zoom}}\n    <span id=\"hint-smartzoom-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-smartzoom\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Smart Zoom\n        </button>\n      </a>\n    </span>\n    {{/Smart Zoom}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat\" class=\"hintBtn\" data-name=\"Präparat\" style=\"display: none;\">\n      <button id=\"button-praeparat\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-praeparat'); event.stopPropagation()\">\n        <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n      </button>\n      <div dir=\"auto\" id=\"praeparat\" class=\"hints\" style=\"display: none;\">{{edit:Präparat}}</div>\n    </span>\n    {{/Präparat}}\n\n    {{#Memes}}\n    <span id=\"hint-memes\" class=\"hintBtn\" data-name=\"Memes\" style=\"display: none;\">\n      <button id=\"button-memes\" class=\"button-general\" onclick=\"toggleHintBtn('hint-memes'); event.stopPropagation()\">\n        <img src=\"__sonstiges.svg\" style=\"height: 10px;\"> Memes\n      </button>\n      <div dir=\"auto\" id=\"memes\" class=\"hints\" style=\"display: none;\">{{edit:Memes}}</div>\n    </span>\n    {{/Memes}}\n\n    <!-- LINEBREAKS IF BUTTONS EXIST -->\n    <script>\n      var array = [`{{Eigene Notizen & Bilder}}`, `{{Eigene Prüfungsfragen}}`, `{{Definitionen}}`, `{{Merksprüche}}`, `{{Klinik}}`, `{{Präparat}}`, `{{Memes}}`];\n      var anyistrue = (element) => element;\n      if (array.some(anyistrue)) {\n        document.getElementById(\"linebreaksIfButtons\").innerHTML = \"<br>\";\n      }\n    </script>\n    <div id=\"linebreaksIfButtons\"></div>\n\n    <!-- Extra field -->\n    {{#Extra}}\n    <div id=\"extra\" style=\"display: none;\">\n      <br>{{edit:Extra}}<br><br>\n    </div>\n    {{/Extra}}\n\n    <!-- Image field -->\n    {{#Bild}}\n    <div id=\"image\" style=\"display: none;\">\n      {{edit:Bild}}<br><br></div>\n    {{/Bild}}\n    {{^Bild}}\n    <span id=\"image\" style=\"display: none;\"></span>\n    {{/Bild}}\n    {{#Bild}}\n    <span id=\"hint-image\" style=\"display: none;\">\n      <button id=\"button-image\" class=\"button-general\"\n        onclick=\"var image = document.getElementById('image'); if (image.style.display == 'none') { image.style.display = 'block' } else { image.style.display = 'none' }; event.stopPropagation()\">\n        <img src=\"__image.svg\" style=\"height: 10px;\"> Abbildung\n      </button>\n    </span>\n    {{/Bild}}\n\n    <span id=\"hint-uafi\" class=\"hintBtn\" data-name=\"Ursprung, Ansatz, Verlauf, Funktion, Innervation, Äste\"\n      style=\"display: none;\">\n      <button id=\"button-uafi\" class=\"button-general expanded-button\"\n        onclick=\"toggleHintBtn('hint-uafi'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Weitere Informationen\n      </button>\n      <div id=\"uafi\" class=\"hints\" style=\"display: block;\">\n        <table class=\"uncloze\">\n          {{#Ursprung}}\n          <tr class=\"uafi-element\" id=\"Ursprung\">\n            <td><i>Ursprung</i></td>\n            <td>{{Ursprung}}</td>\n          </tr>\n          {{/Ursprung}}\n          {{#Ansatz}}\n          <tr class=\"uafi-element\" id=\"Ansatz\">\n            <td><i>Ansatz</i></td>\n            <td>{{Ansatz}}</td>\n          </tr>\n          {{/Ansatz}}\n          {{#Verlauf}}\n          <tr class=\"uafi-element\" id=\"Verlauf\">\n            <td><i>Verlauf</i></td>\n            <td>{{Verlauf}}</td>\n          </tr>\n          {{/Verlauf}}\n          {{#Funktion}}\n          <tr class=\"uafi-element\" id=\"Funktion\">\n            <td><i>Funktion</i></td>\n            <td>{{Funktion}}</td>\n          </tr>\n          {{/Funktion}}\n          {{#Innervation}}\n          <tr class=\"uafi-element\" id=\"Innervation\">\n            <td><i>Innervation</i></td>\n            <td>{{Innervation}}</td>\n          </tr>\n          {{/Innervation}}\n          {{#Äste}}\n          <tr class=\"uafi-element\" id=\"Äste\">\n            <td><i>Äste</i></td>\n            <td>{{Äste}}</td>\n          </tr>\n          {{/Äste}}\n        </table>\n      </div>\n\n      <script>\n        // iterate over all uafi-elements and hide only the one\n        // that is equal to the card's answer (i.e., value of {{Card}})\n        var uafiElements = document.getElementsByClassName(\"uafi-element\");\n        for (var i = 0; i < uafiElements.length; i++) {\n          if (((\"{{Card}}\").startsWith(uafiElements[i].id))) {\n            uafiElements[i].remove()\n          }\n        }\n      </script>\n    </span>\n\n    {{#AMBOSS-Link}}\n    <span id=\"hint-amboss\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:AMBOSS-Link}}\">\n        <button id=\"button-amboss\" class=\"button-general\">\n          <img src=\"__amboss.svg\" style=\"height: 10px;\"> AMBOSS&#8203;\n        </button>\n      </a>\n    </span>\n    {{/AMBOSS-Link}}\n\n    {{#Thieme via medici-Link}}\n    <span id=\"hint-thieme\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Thieme via medici-Link}}\">\n        <button id=\"button-thieme\" class=\"button-general\">\n          <img id=\"button-thieme-img\" src=\"__thieme-heart.svg\" style=\"height: 10px;\"> Thieme via medici\n        </button>\n      </a>\n    </span>\n    {{/Thieme via medici-Link}}\n\n    {{#Meditricks}}\n    <span id=\"hint-meditricks\" class=\"hintBtn\" data-name=\"Meditricks\" style=\"display: none;\">\n      <button id=\"button-meditricks\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-meditricks'); event.stopPropagation()\">\n        <img src=\"__meditricks.svg\" style=\"height: 10px;\"> Meditricks\n      </button>\n      <div dir=\"auto\" id=\"meditricks\" class=\"hints\" style=\"display: none;\">{{edit:Meditricks}}</div>\n    </span>\n    {{/Meditricks}}\n\n    {{#weitere Links}}\n    <span id=\"hint-linkcontainer\" class=\"hintBtn\" data-name=\"linkContainer\" style=\"display: none;\">\n      <button id=\"button-linkcontainer\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-linkcontainer'); event.stopPropagation()\">\n        <img src=\"__internet.svg\" style=\"height: 10px;\"> weitere Links\n      </button>\n      <div id=\"linkcontainer\" class=\"hints\" style=\"display: none;\"></div>\n      <span id=\"linkContainerLinks\" style=\"display: none;\">{{edit:weitere Links}}</span>\n    </span>\n    {{/weitere Links}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n  try {\n    for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n      href = link.href\n      text = link.innerText\n\n      const el = document.createElement('a');\n      el.setAttribute('href', link.href);\n\n      const btn = document.createElement('button');\n      btn.classList.add('button-general');\n      btn.classList.add('expanded-button');\n\n      domain = href.replace(/.+\\/\\/|(www|flexikon|register|de|next|com).|\\..+/g, '');\n      domainDict = {\n        \"amboss\": \"__amboss.svg\",\n        \"wikipedia\": \"__wikipedia.svg\",\n        \"doccheck\": \"__doccheck.png\",\n        \"notfallguru\": \"__notfallguru.svg\",\n        \"awmf\": \"__awmf.svg\",\n        \"gelbe-liste\": \"__gelbe-liste.png\",\n        \"embryotox\": \"__embryotox.svg\",\n        \"radiopaedia\": \"__radiopaedia.png\",\n        \"orphanet\": \"__orphanet.png\",\n      }\n      if (domain in domainDict) {\n        icon = domainDict[domain]\n      } else {\n        icon = \"__internet.svg\"\n      }\n\n      const img = document.createElement('img');\n      img.setAttribute('src', icon);\n      img.setAttribute('style', 'height: 10px;');\n\n      btn.appendChild(img);\n      btn.innerHTML = btn.innerHTML + \" \" + text;\n\n      el.appendChild(btn);\n\n      document.getElementById(\"linkcontainer\").appendChild(el)\n    }\n  }\n  catch (err) {\n    console.log(err)\n  }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-uafi\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- AUTOFLIP BACK SCRIPT -->\n<script>\n  // autoflip hides card in front template\n  document.getElementById(\"qa\").style.removeProperty(\"display\")\n</script>\n\n<!-- CLOZE ONE BY ONE SCRIPT -->\n<style>\n  .cloze-replacer:hover {\n    cursor: pointer;\n  }\n\n  .cloze-hidden {\n    display: none;\n  }\n\n  .cloze-replacer .hidden {\n    display: none;\n  }\n\n  #extra.hidden {\n    display: none;\n  }\n</style>\n\n<!--\n Based on the AnKing Notetype, but expanded and modified by phyn.\n Credit to the original authors, except where modified or otherwise indicated.\n-->\n\n<script>\n    (function () {\n      // enables cloze one-by-one even when one-by-one field is empty\n      // minNumberOfClozes is still considered in this case\n      // overridden in importance by selectiveOneByOne\n      var clozeOneByOneEnabled = true;\n\n      // remove the clickAnywhere function from global scope\n      document.documentElement.removeAttribute(\"onclick\")\n\n      // --- CHECK IF ONE BY ONE IS GENERALLY ENABLED FOR THIS NOTE ---\n      var oneByOneFieldNotEmpty = \"{{One by one}}\" !== \"\";\n      try {\n        clozeOneByOneEnabled = alwaysOneByOne || oneByOneFieldNotEmpty;\n      } catch (exception) {\n        console.log(exception)\n      }\n\n      /**\n   * helper functions to show / hide fields containing additional information\n   */\n      const showExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const hideExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const buttonIds = [\n        \"hint-zusatz\",\n        \"hint-definition\",\n        \"hint-hammer\",\n        \"hint-klinik\",\n        \"hint-praeparat\",\n        \"hint-microscope\",\n        \"hint-smartzoom\",\n        \"hint-histotrainer\",\n        \"hint-uafi\",\n        \"hint-merksprueche\",\n        \"hint-memes\",\n        \"hint-image\",\n        \"hint-amboss\",\n        \"hint-thieme\",\n        \"hint-meditricks\",\n        \"hint-linkcontainer\",\n      ];\n\n      const showExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document\n              .getElementById(buttonIds[button])\n              .style.removeProperty(\"display\");\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n      const hideExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document.getElementById(buttonIds[button]).style.display = \"none\";\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n\n      // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n      /**\n       * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n       */\n      const getCardNumber = function () {\n        clz = document.body.className;\n        const regex = /card(\\d+)/gm;\n\n        let clz2;\n        try {\n          clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n        } catch (e) {\n          clz2 = \"\";\n        }\n        const regex2 = /.*?Cloze(\\d+)/gm;\n\n        let m;\n\n        if ((m = regex2.exec(clz2)) !== null) {\n          return m[1];\n        } else if ((m = regex.exec(clz)) !== null) {\n          return m[1];\n        } else {\n          // Should only fire if card is not cloze\n          console.error(\"Cannot find cardN class of body element!\");\n          return \"0\";\n        }\n      }\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (!clozeOneByOneEnabled) {\n        showExtra()\n        showExtraButtons()\n        document.getElementById(\"onebyone-buttons\").style.display = \"none\"\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n        return\n      }\n\n      // Needed for amboss to recognize first word in .cloze-hidden\n      const CLOZE_REPLACER_SEP = \"<span class='hidden'> </span>\"\n\n      const hideAllCloze = function (initial) {\n        let clozes = document.getElementsByClassName(\"cloze\")\n        let count = 0 // hidden cloze count\n        for (const cloze of clozes) {\n          const existingHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n          if (existingHidden) {\n            revealCloze(cloze);\n          }\n          if (cloze.offsetWidth === 0) {\n            continue\n          }\n          const clozeReplacer = document.createElement(\"span\")\n          const clozeHidden = document.createElement(\"span\")\n          clozeReplacer.classList.add(\"cloze-replacer\")\n          clozeHidden.classList.add(\"cloze-hidden\")\n          while (cloze.childNodes.length > 0) {\n            clozeHidden.appendChild(cloze.childNodes[0])\n          }\n          cloze.appendChild(clozeReplacer)\n          cloze.appendChild(clozeHidden)\n\n          var clozeHints = Persistence.getItem(\"clozeHints\");\n          if (clozeHints && clozeHints[count]) {\n            clozeReplacer.classList.add(\"cloze-hint\")\n            clozeReplacer.innerHTML = clozeHints[count] + CLOZE_REPLACER_SEP\n          } else {\n            clozeReplacer.innerHTML = clozeHider(cloze) + CLOZE_REPLACER_SEP\n          }\n          count += 1\n          document.getElementById(\"button-reveal-next\").style.display = \"inline-block\";\n          if (initial) {\n            cloze.addEventListener(\"touchend\", revealClozeClicked)\n            cloze.addEventListener(\"click\", revealClozeClicked)\n            cloze.classList.add(\"one-by-one\");\n          }\n        }\n\n        // Hide #extra until all clozes are shown\n        const extra = document.getElementById(\"extra\");\n        if (extra) {\n          extra.classList.add(\"hidden\");\n        }\n\n        hideExtra();\n        hideExtraButtons();\n        if (revealAnywhere) {\n          document.documentElement.setAttribute(\"onclick\", \"revealNextCloze(); event.stopPropagation()\")\n        }\n\n\n        // Also hide autoReveal fields\n        for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n          const container = document.querySelector(`[data-name=\"${field}\"]`)\n          if (container) {\n            const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n            if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n              // const link = container.getElementsByTagName(\"a\")[0]\n              const button = container.getElementsByTagName(\"button\")[0]\n              const hint = container.getElementsByTagName(\"div\")[0]\n              button.classList.remove(\"expanded-button\")\n              hint.style.display = \"none\"\n              // link.style.display = \"\"\n            }\n          }\n        }\n      }\n\n      const revealCloze = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        cloze.removeChild(clozeReplacer)\n        cloze.removeChild(clozeHidden)\n        while (clozeHidden.childNodes.length > 0) {\n          cloze.appendChild(clozeHidden.childNodes[0])\n        }\n        maybeRevealExtraField()\n      }\n\n      const revealClozeWord = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        let range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundSpace = setRangeEnd(range, clozeHidden, \"beforeFirstSpace\")\n        if (!foundSpace) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        let fragment = range.extractContents()\n        cloze.insertBefore(fragment, clozeReplacer)\n        // Extract whitespaces after word\n        range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundWord = setRangeEnd(range, clozeHidden, \"beforeFirstChar\")\n        if (!foundWord) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        fragment = range.extractContents();\n        cloze.insertBefore(fragment, clozeReplacer)\n        if (!foundWord) {\n          cloze.removeChild(clozeHidden)\n          cloze.removeChild(clozeReplacer)\n          maybeRevealExtraField()\n          return\n        }\n        clozeReplacer.innerHTML = clozeHider(clozeHidden) + CLOZE_REPLACER_SEP\n        if (clozeReplacer.classList.contains(\"cloze-hint\")) [\n          clozeReplacer.classList.remove(\"cloze-hint\")\n        ]\n        maybeRevealExtraField()\n      }\n\n      const revealNextClozeOf = (type) => {\n        const nextHidden = document.querySelectorAll(\".cloze-hidden\")\n        const nextNextHidden = nextHidden.length > 1 ? true : false\n        if (!nextNextHidden) {\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\";\n        }\n        if (!nextHidden) {\n          return\n        }\n        const cloze = clozeElOfClozeHidden(nextHidden[0]);\n        if (type === \"word\") {\n          revealClozeWord(cloze)\n        } else if (type === \"cloze\") {\n          revealCloze(cloze)\n        } else {\n          console.error(\"Invalid type: \" + type)\n        }\n      }\n\n      const revealClozeClicked = function (ev) {\n        let elem = ev.currentTarget\n        if (!ev.altKey && (revealNextClozeMode !== \"word\")) {\n          revealCloze(elem)\n        } else {\n          revealClozeWord(elem)\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      }\n\n      window.revealNextCloze = function () {\n        revealNextClozeOf(revealNextClozeMode)\n      }\n\n      window.toggleAllCloze = function () {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length > 0) {\n          for (const elem of elems) {\n            const cloze = clozeElOfClozeHidden(elem)\n            revealCloze(cloze)\n          }\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\"\n        } else {\n          hideAllCloze(initial = false)\n        }\n      }\n\n      const clozeElOfClozeHidden = (cloze) => {\n        while (!cloze.classList.contains(\"cloze\")) {\n          cloze = cloze.parentElement;\n        }\n        return cloze;\n      }\n\n      const maybeRevealExtraField = () => {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length == 0) {\n          const extra = document.getElementById(\"extra\")\n          if (extra) {\n            extra.classList.remove(\"hidden\")\n          }\n\n          showExtra();\n          showExtraButtons();\n          document.documentElement.removeAttribute(\"onclick\")\n\n          // Also reveal autoReveal fields\n          for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n            const container = document.querySelector(`[data-name=\"${field}\"]`)\n            if (container) {\n              const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n              if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n                // const link = container.getElementsByTagName(\"a\")[0]\n                const button = container.getElementsByTagName(\"button\")[0]\n                const hint = container.getElementsByTagName(\"div\")[0]\n                button.classList.add(\"expanded-button\")\n                hint.style.display = \"block\"\n                // link.style.display = \"none\"\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * mode: 'beforeFirstSpace' or 'beforeFirstChar'\n       * Return `true` if it exists and setEnd() was called, otherwise `false`\n       */\n      const setRangeEnd = function (range, node, mode) {\n        if (node.nodeType === Node.TEXT_NODE) {\n          const regex = mode === 'beforeFirstSpace' ? /\\s/ : /\\S/\n          const match = node.textContent.match(regex)\n          if (match) {\n            if (match.index === 0) {\n              while (node.previousSibling === null) {\n                node = node.parentElement\n              }\n              range.setEndBefore(node)\n            } else {\n              range.setEnd(node, match.index);\n            }\n            return true;\n          } else {\n            return false;\n          }\n        } else if (mode === 'beforeFirstChar' && isCharNode(node)) {\n          range.setEndBefore(node)\n          return true\n        } else if (!ignoreSpaceInNode(node)) {\n          for (const child of node.childNodes) {\n            if (setRangeEnd(range, child, mode)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }\n\n      const ignoreSpaceInNode = function (node) {\n        return node.tagName === \"MJX-ASSISTIVE-MML\"\n      }\n\n      const isCharNode = function (node) {\n        return [\"IMG\", \"MJX-CONTAINER\"].includes(node.tagName)\n      }\n\n      hideAllCloze(initial = true)\n\n      let isShowNextShortcut = shortcutMatcher(window.revealNextShortcut)\n      let isShowWordShortcut = shortcutMatcher(window.revealNextWordShortcut)\n      let isToggleAllShortcut = shortcutMatcher(window.toggleAllShortcut)\n      ankingAddEventListener(\"keydown\", (ev) => {\n        let next = isShowNextShortcut(ev)\n        let word = isShowWordShortcut(ev)\n        let all = isToggleAllShortcut(ev)\n        if (next) {\n          revealNextClozeOf(\"cloze\")\n        } else if (word) {\n          revealNextClozeOf(\"word\")\n        } else if (all) {\n          toggleAllCloze()\n        } else {\n          return;\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      });\n    })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- MEDITRICKS SNIPPETS DATA -->\n<div id=\"meditricks-mtsp-values\" style=\"display:none;\">\n  <div id=\"meditricks-mtsp-nfname\">_meditricks_nf_v1000_ankizin</div>\n  <div id=\"meditricks-mtsp-nid\">{{Note ID}}</div>\n</div>\n<script src=\"_meditricks_mtsp_scripts_v1000_ankizin.js\"></script>\n<link href=\"_meditricks_mtsp_styles_v1000_ankizin.css\" rel=\"stylesheet\" />\n\n<!-- include \"_meditricks_mtsp_nf_v1000_ankizin.js\" -->\n<!-- include \"_meditricks_mtsp_scripts_v1000_iframe.map\" -->\n<!-- include \"_meditricks_mtsp_mtlogo.webp\" -->\n<!-- include \"_meditricks_mtsp_mt-loading.png\" -->\n<!-- include \"_meditricks_mtsp_mt-loading_night.png\" -->\n\n<!-- //MEDITRICKS SNIPPETS DATA -->\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>",
      "bqfmt": "{{Muskel / Leitungsbahn}}",
      "bafmt": "{{Ursprung}}",
      "bfont": "Helvetica",
      "bsize": 12
    },
    {
      "name": "AnsatzCloze1",
      "ord": 9,
      "qfmt": "<!-- version f0935e4 -->\n{{#Ansatz}}\n{{#AnsatzCloze1}}\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TIMER CONFIG  ##############\n  // Timer config (timer length, timer finished message)\n  var minutes = 0\n  var seconds = 15\n  var timeOverMsg = \"<span style='color:#CC5B5B'>!!!</span>\"\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  // Auto flip to back when One by one mode.\n  var autoflip = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Wo liegt der <i>Ansatz</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" data-card=\"{{Card}}\"><br>{{Ansatz}}</div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\"></div>\n\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<script>\n  //DONT FADE BETWEEN CARDS\n  qFade = 0;\n  if (typeof anki !== 'undefined') anki.qFade = qFade;\n</script>\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    if (!indentation) { return; }\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- CLOZE ONE BY ONE FRONT -->\n<div id=\"one-by-one\" style=\"display: none;\"></div>\n\n<script>\n  /**\n   * Based on the AnKing Notetype, but expanded and modified by phyn.\n   * Credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  Persistence.clear();\n\n  // check if OneByOne is generally enabled for this card\n  var oneByOneFieldEmpty = selectiveOneByOne ? \"{{One by one}}\" === \"\" : true;\n  var clozeOneByOneEnabled = alwaysOneByOne ? true : !oneByOneFieldEmpty;\n\n  // avoid flickering. Must unset this in the back.\n  document.getElementById(\"qa\").style.display = \"none\";\n  var clozeHints = [];\n\n  if (clozeOneByOneEnabled) {\n    // collect hints from front side (independent of whether or not OneByOne is enabled)\n    document.getElementById(\"qa\").classList.add('one-by-one');\n    // Save cloze hints to display in the back\n    var clozes = document.getElementsByClassName(\"cloze\")\n    for (var i = 0; i < clozes.length; i++) {\n      clozes[i].classList.add(\"one-by-one\");\n      if (clozes[i].innerHTML === \"[...]\") {\n        clozeHints.push(\"\")\n      } else {\n        clozeHints.push(clozes[i].innerHTML)\n      }\n    }\n\n    // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n    /**\n     * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n     */\n    const getCardNumber = function () {\n      clz = document.body.className;\n      const regex = /card(\\d+)/gm;\n\n      let clz2;\n      try {\n        clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n      } catch (e) {\n        clz2 = \"\";\n      }\n      const regex2 = /.*?Cloze(\\d+)/gm;\n\n      let m;\n\n      if ((m = regex2.exec(clz2)) !== null) {\n        return m[1];\n      } else if ((m = regex.exec(clz)) !== null) {\n        return m[1];\n      } else {\n        // Should only fire if card is not cloze\n        console.error(\"Cannot find cardN class of body element!\");\n        return \"0\";\n      }\n    }\n\n    var alreadyRendered = false;\n\n    function processSelective1b1() {\n      if (alreadyRendered) return;\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (autoflip && clozeOneByOneEnabled) {\n        if (window.pycmd || window.showAnswer) {\n          // avoid flickering. Must unset this in the back.\n          document.getElementById(\"qa\").style.display = \"none\";\n        }\n        if (window.pycmd) {\n          pycmd(\"ans\")\n        } else if (window.showAnswer) {\n          showAnswer()\n        }\n      } else {\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n      }\n      // AnkiMobile JS API doesn't have one for show answer.\n      // Best alternative is to use Taps/Swipes to show answer.\n\n      alreadyRendered = true;\n    }\n\n    function delayedProcessSelective1b1() {\n      if (window.requestAnimationFrame) window.requestAnimationFrame(processSelective1b1); // less flickering\n      else window.setTimeout(processSelective1b1, 0);\n    };\n\n    window.onload = delayedProcessSelective1b1;\n    if (document.readyState === \"complete\") {\n      delayedProcessSelective1b1();\n    }\n    else {\n      document.addEventListener(\"DOMContentLoaded\", delayedProcessSelective1b1);\n    }\n\n    // Observe document.body class changes to trigger re-rendering.\n    // This is useful, because Anki doesn’t always start with an up-to-date class list:\n    // https://forums.ankiweb.net/t/card-card-classes-only-injected-separately-now/27387.\n    const observer = new MutationObserver(function (mutationsList, observer) {\n      for (let mutation of mutationsList) {\n        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {\n          delayedProcessSelective1b1();\n        }\n      }\n    });\n    observer.observe(document.body, { attributes: true });\n  }\n  Persistence.setItem(\"clozeHints\", clozeHints);\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>\n\n\n{{/AnsatzCloze1}}\n{{/Ansatz}}",
      "afmt": "<!-- version f0935e4 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n<div id=\"back\"></div>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Eigene Notizen & Bilder\": \"Alt + 1\",\n    \"Eigene Prüfungsfragen\": \"Alt + 2\",\n    \"Definitionen\": \"Alt + 3\",\n    \"Merksprüche\": \"Alt + 4\",\n    \"Klinik\": \"Alt + 5\",\n    \"Präparat\": \"Alt + 6\",\n    \"Memes\": \"Alt + 7\",\n    \"linkContainer\": \"Alt + L\",\n    \"Meditricks\": \"Alt + M\",\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Eigene Notizen & Bilder\": false,\n    \"Eigene Prüfungsfragen\": false,\n    \"Definitionen\": false,\n    \"Merksprüche\": false,\n    \"Klinik\": false,\n    \"Präparat\": false,\n    \"Memes\": false,\n    \"linkContainer\": true,\n    \"Meditricks\": false,\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  var revealNextShortcut = \"N\"\n  var revealNextWordShortcut = \"Shift + N\"\n  var toggleAllShortcut = \",\"\n\n  // Enables revealing of next Cloze by simply clicking / tapping anywhere on the card (except the buttons)\n  var revealAnywhere = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // Changes how \"Reveal Next\" and clicking behaves. Either \"cloze\" or \"word\".\n  // \"word\" reveals word by word. \n  var revealNextClozeMode = \"cloze\"\n\n  // Changes how fields with additional information are displayed.\n  // true displays fields with additional information only if all clozes are revealed.\n  var hideAdditional = true;\n  var hideAdditionalButtons = true;\n\n  // What cloze is hidden with\n  var clozeHider = (elem) => \"[&nbsp;_&nbsp;]\"\n  /*\n  You can replace the above line with below examples. '█' or '_' works well for hiding clozes.\n  \n  // Fixed length:\n  var clozeHider = (elem) => \"███\"\n  // Replace each character with \"█\":\n  var clozeHider = (elem) => \"█\".repeat(elem.textContent.length)\n  // Show whitespaces:\n  var clozeHider = (elem) => \"[\" + elem.textContent.split(\" \").map((t) => \"█\".repeat(t.length)).join(\" \") + \"]\"\n  // Color-filled box (doesn't hide images):\n  var clozeHider = (elem) => `<span style=\"background-color: red; color: transparent;\">${elem.innerHTML}</span>`\n  */\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Wo liegt der <i>Ansatz</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" class=\"clozefield\" data-card=\"{{Card}}\"><br>{{Ansatz}}</div>\n\n    <!-- ClOZE ONE BY ONE BUTTONS -->\n    <div id=\"onebyone-buttons\" class=\"onebyone\">\n      <br>\n      <button id=\"button-reveal-next\" class=\"button-general button-one-by-one\"\n        onclick=\"revealNextCloze(); event.stopPropagation()\">Reveal Next</button>\n      <button id=\"button-toggle-all\" class=\"button-general button-one-by-one\"\n        onclick=\"toggleAllCloze(); event.stopPropagation()\">Toggle All</button>\n    </div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- BUTTON FIELDS -->\n    {{#Eigene Notizen & Bilder}}\n    <span id=\"hint-zusatz\" class=\"hintBtn\" data-name=\"Eigene Notizen & Bilder\" style=\"display: none;\">\n      <button id=\"button-zusatz\" class=\"button-general\" onclick=\"toggleHintBtn('hint-zusatz'); event.stopPropagation()\">\n        <img src=\"__zusatz.svg\" style=\"height: 10px;\"> Eigene Notizen & Bilder\n      </button>\n      <div dir=\"auto\" id=\"zusatz\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Notizen & Bilder}}</div>\n    </span>\n    {{/Eigene Notizen & Bilder}}\n\n    {{#Eigene Prüfungsfragen}}\n    <span id=\"hint-hammer\" class=\"hintBtn\" data-name=\"Eigene Prüfungsfragen\" style=\"display: none;\">\n      <button id=\"button-hammer\" class=\"button-general\" onclick=\"toggleHintBtn('hint-hammer'); event.stopPropagation()\">\n        <img src=\"__hammer.svg\" style=\"height: 10px;\"> Eigene Prüfungsfragen\n      </button>\n      <div dir=\"auto\" id=\"hammer\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Prüfungsfragen}}</div>\n    </span>\n    {{/Eigene Prüfungsfragen}}\n\n    {{#Definitionen}}\n    <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Definitionen\" style=\"display: none;\">\n      <button id=\"button-definition\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Definitionen\n      </button>\n      <div dir=\"auto\" id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Definitionen}}</div>\n    </span>\n    {{/Definitionen}}\n\n    {{#Merksprüche}}\n    <span id=\"hint-merksprueche\" class=\"hintBtn\" data-name=\"Merksprüche\" style=\"display: none;\">\n      <button id=\"button-merksprueche\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-merksprueche'); event.stopPropagation()\">\n        <img src=\"__merkhilfe.svg\" style=\"height: 10px;\"> Merksprüche\n      </button>\n      <div dir=\"auto\" id=\"merksprueche\" class=\"hints\" style=\"display: none;\">{{edit:Merksprüche}}</div>\n    </span>\n    {{/Merksprüche}}\n\n    {{#Klinik}}\n    <span id=\"hint-klinik\" class=\"hintBtn\" data-name=\"Klinik\" style=\"display: none;\">\n      <button id=\"button-klinik\" class=\"button-general\" onclick=\"toggleHintBtn('hint-klinik'); event.stopPropagation()\">\n        <img src=\"__stethoscope.svg\" style=\"height: 10px;\"> Klinik\n      </button>\n      <div dir=\"auto\" id=\"klinik\" class=\"hints\" style=\"display: none;\">{{edit:Klinik}}</div>\n    </span>\n    {{/Klinik}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-praeparat\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n        </button>\n      </a>\n    </span>\n    {{/Präparat}}\n\n    {{#Virtuelle Mikroskopie}}\n    <span id=\"hint-microscope-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Virtuelle Mikroskopie}}\">\n        <button id=\"button-microscope\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Virtuelle Mikroskopie\n        </button>\n      </a>\n    </span>\n    {{/Virtuelle Mikroskopie}}\n\n    {{#Smart Zoom}}\n    <span id=\"hint-smartzoom-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-smartzoom\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Smart Zoom\n        </button>\n      </a>\n    </span>\n    {{/Smart Zoom}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat\" class=\"hintBtn\" data-name=\"Präparat\" style=\"display: none;\">\n      <button id=\"button-praeparat\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-praeparat'); event.stopPropagation()\">\n        <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n      </button>\n      <div dir=\"auto\" id=\"praeparat\" class=\"hints\" style=\"display: none;\">{{edit:Präparat}}</div>\n    </span>\n    {{/Präparat}}\n\n    {{#Memes}}\n    <span id=\"hint-memes\" class=\"hintBtn\" data-name=\"Memes\" style=\"display: none;\">\n      <button id=\"button-memes\" class=\"button-general\" onclick=\"toggleHintBtn('hint-memes'); event.stopPropagation()\">\n        <img src=\"__sonstiges.svg\" style=\"height: 10px;\"> Memes\n      </button>\n      <div dir=\"auto\" id=\"memes\" class=\"hints\" style=\"display: none;\">{{edit:Memes}}</div>\n    </span>\n    {{/Memes}}\n\n    <!-- LINEBREAKS IF BUTTONS EXIST -->\n    <script>\n      var array = [`{{Eigene Notizen & Bilder}}`, `{{Eigene Prüfungsfragen}}`, `{{Definitionen}}`, `{{Merksprüche}}`, `{{Klinik}}`, `{{Präparat}}`, `{{Memes}}`];\n      var anyistrue = (element) => element;\n      if (array.some(anyistrue)) {\n        document.getElementById(\"linebreaksIfButtons\").innerHTML = \"<br>\";\n      }\n    </script>\n    <div id=\"linebreaksIfButtons\"></div>\n\n    <!-- Extra field -->\n    {{#Extra}}\n    <div id=\"extra\" style=\"display: none;\">\n      <br>{{edit:Extra}}<br><br>\n    </div>\n    {{/Extra}}\n\n    <!-- Image field -->\n    {{#Bild}}\n    <div id=\"image\" style=\"display: none;\">\n      {{edit:Bild}}<br><br></div>\n    {{/Bild}}\n    {{^Bild}}\n    <span id=\"image\" style=\"display: none;\"></span>\n    {{/Bild}}\n    {{#Bild}}\n    <span id=\"hint-image\" style=\"display: none;\">\n      <button id=\"button-image\" class=\"button-general\"\n        onclick=\"var image = document.getElementById('image'); if (image.style.display == 'none') { image.style.display = 'block' } else { image.style.display = 'none' }; event.stopPropagation()\">\n        <img src=\"__image.svg\" style=\"height: 10px;\"> Abbildung\n      </button>\n    </span>\n    {{/Bild}}\n\n    <span id=\"hint-uafi\" class=\"hintBtn\" data-name=\"Ursprung, Ansatz, Verlauf, Funktion, Innervation, Äste\"\n      style=\"display: none;\">\n      <button id=\"button-uafi\" class=\"button-general expanded-button\"\n        onclick=\"toggleHintBtn('hint-uafi'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Weitere Informationen\n      </button>\n      <div id=\"uafi\" class=\"hints\" style=\"display: block;\">\n        <table class=\"uncloze\">\n          {{#Ursprung}}\n          <tr class=\"uafi-element\" id=\"Ursprung\">\n            <td><i>Ursprung</i></td>\n            <td>{{Ursprung}}</td>\n          </tr>\n          {{/Ursprung}}\n          {{#Ansatz}}\n          <tr class=\"uafi-element\" id=\"Ansatz\">\n            <td><i>Ansatz</i></td>\n            <td>{{Ansatz}}</td>\n          </tr>\n          {{/Ansatz}}\n          {{#Verlauf}}\n          <tr class=\"uafi-element\" id=\"Verlauf\">\n            <td><i>Verlauf</i></td>\n            <td>{{Verlauf}}</td>\n          </tr>\n          {{/Verlauf}}\n          {{#Funktion}}\n          <tr class=\"uafi-element\" id=\"Funktion\">\n            <td><i>Funktion</i></td>\n            <td>{{Funktion}}</td>\n          </tr>\n          {{/Funktion}}\n          {{#Innervation}}\n          <tr class=\"uafi-element\" id=\"Innervation\">\n            <td><i>Innervation</i></td>\n            <td>{{Innervation}}</td>\n          </tr>\n          {{/Innervation}}\n          {{#Äste}}\n          <tr class=\"uafi-element\" id=\"Äste\">\n            <td><i>Äste</i></td>\n            <td>{{Äste}}</td>\n          </tr>\n          {{/Äste}}\n        </table>\n      </div>\n\n      <script>\n        // iterate over all uafi-elements and hide only the one\n        // that is equal to the card's answer (i.e., value of {{Card}})\n        var uafiElements = document.getElementsByClassName(\"uafi-element\");\n        for (var i = 0; i < uafiElements.length; i++) {\n          if (((\"{{Card}}\").startsWith(uafiElements[i].id))) {\n            uafiElements[i].remove()\n          }\n        }\n      </script>\n    </span>\n\n    {{#AMBOSS-Link}}\n    <span id=\"hint-amboss\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:AMBOSS-Link}}\">\n        <button id=\"button-amboss\" class=\"button-general\">\n          <img src=\"__amboss.svg\" style=\"height: 10px;\"> AMBOSS&#8203;\n        </button>\n      </a>\n    </span>\n    {{/AMBOSS-Link}}\n\n    {{#Thieme via medici-Link}}\n    <span id=\"hint-thieme\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Thieme via medici-Link}}\">\n        <button id=\"button-thieme\" class=\"button-general\">\n          <img id=\"button-thieme-img\" src=\"__thieme-heart.svg\" style=\"height: 10px;\"> Thieme via medici\n        </button>\n      </a>\n    </span>\n    {{/Thieme via medici-Link}}\n\n    {{#Meditricks}}\n    <span id=\"hint-meditricks\" class=\"hintBtn\" data-name=\"Meditricks\" style=\"display: none;\">\n      <button id=\"button-meditricks\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-meditricks'); event.stopPropagation()\">\n        <img src=\"__meditricks.svg\" style=\"height: 10px;\"> Meditricks\n      </button>\n      <div dir=\"auto\" id=\"meditricks\" class=\"hints\" style=\"display: none;\">{{edit:Meditricks}}</div>\n    </span>\n    {{/Meditricks}}\n\n    {{#weitere Links}}\n    <span id=\"hint-linkcontainer\" class=\"hintBtn\" data-name=\"linkContainer\" style=\"display: none;\">\n      <button id=\"button-linkcontainer\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-linkcontainer'); event.stopPropagation()\">\n        <img src=\"__internet.svg\" style=\"height: 10px;\"> weitere Links\n      </button>\n      <div id=\"linkcontainer\" class=\"hints\" style=\"display: none;\"></div>\n      <span id=\"linkContainerLinks\" style=\"display: none;\">{{edit:weitere Links}}</span>\n    </span>\n    {{/weitere Links}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n  try {\n    for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n      href = link.href\n      text = link.innerText\n\n      const el = document.createElement('a');\n      el.setAttribute('href', link.href);\n\n      const btn = document.createElement('button');\n      btn.classList.add('button-general');\n      btn.classList.add('expanded-button');\n\n      domain = href.replace(/.+\\/\\/|(www|flexikon|register|de|next|com).|\\..+/g, '');\n      domainDict = {\n        \"amboss\": \"__amboss.svg\",\n        \"wikipedia\": \"__wikipedia.svg\",\n        \"doccheck\": \"__doccheck.png\",\n        \"notfallguru\": \"__notfallguru.svg\",\n        \"awmf\": \"__awmf.svg\",\n        \"gelbe-liste\": \"__gelbe-liste.png\",\n        \"embryotox\": \"__embryotox.svg\",\n        \"radiopaedia\": \"__radiopaedia.png\",\n        \"orphanet\": \"__orphanet.png\",\n      }\n      if (domain in domainDict) {\n        icon = domainDict[domain]\n      } else {\n        icon = \"__internet.svg\"\n      }\n\n      const img = document.createElement('img');\n      img.setAttribute('src', icon);\n      img.setAttribute('style', 'height: 10px;');\n\n      btn.appendChild(img);\n      btn.innerHTML = btn.innerHTML + \" \" + text;\n\n      el.appendChild(btn);\n\n      document.getElementById(\"linkcontainer\").appendChild(el)\n    }\n  }\n  catch (err) {\n    console.log(err)\n  }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-uafi\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- AUTOFLIP BACK SCRIPT -->\n<script>\n  // autoflip hides card in front template\n  document.getElementById(\"qa\").style.removeProperty(\"display\")\n</script>\n\n<!-- CLOZE ONE BY ONE SCRIPT -->\n<style>\n  .cloze-replacer:hover {\n    cursor: pointer;\n  }\n\n  .cloze-hidden {\n    display: none;\n  }\n\n  .cloze-replacer .hidden {\n    display: none;\n  }\n\n  #extra.hidden {\n    display: none;\n  }\n</style>\n\n<!--\n Based on the AnKing Notetype, but expanded and modified by phyn.\n Credit to the original authors, except where modified or otherwise indicated.\n-->\n\n<script>\n    (function () {\n      // enables cloze one-by-one even when one-by-one field is empty\n      // minNumberOfClozes is still considered in this case\n      // overridden in importance by selectiveOneByOne\n      var clozeOneByOneEnabled = true;\n\n      // remove the clickAnywhere function from global scope\n      document.documentElement.removeAttribute(\"onclick\")\n\n      // --- CHECK IF ONE BY ONE IS GENERALLY ENABLED FOR THIS NOTE ---\n      var oneByOneFieldNotEmpty = \"{{One by one}}\" !== \"\";\n      try {\n        clozeOneByOneEnabled = alwaysOneByOne || oneByOneFieldNotEmpty;\n      } catch (exception) {\n        console.log(exception)\n      }\n\n      /**\n   * helper functions to show / hide fields containing additional information\n   */\n      const showExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const hideExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const buttonIds = [\n        \"hint-zusatz\",\n        \"hint-definition\",\n        \"hint-hammer\",\n        \"hint-klinik\",\n        \"hint-praeparat\",\n        \"hint-microscope\",\n        \"hint-smartzoom\",\n        \"hint-histotrainer\",\n        \"hint-uafi\",\n        \"hint-merksprueche\",\n        \"hint-memes\",\n        \"hint-image\",\n        \"hint-amboss\",\n        \"hint-thieme\",\n        \"hint-meditricks\",\n        \"hint-linkcontainer\",\n      ];\n\n      const showExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document\n              .getElementById(buttonIds[button])\n              .style.removeProperty(\"display\");\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n      const hideExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document.getElementById(buttonIds[button]).style.display = \"none\";\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n\n      // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n      /**\n       * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n       */\n      const getCardNumber = function () {\n        clz = document.body.className;\n        const regex = /card(\\d+)/gm;\n\n        let clz2;\n        try {\n          clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n        } catch (e) {\n          clz2 = \"\";\n        }\n        const regex2 = /.*?Cloze(\\d+)/gm;\n\n        let m;\n\n        if ((m = regex2.exec(clz2)) !== null) {\n          return m[1];\n        } else if ((m = regex.exec(clz)) !== null) {\n          return m[1];\n        } else {\n          // Should only fire if card is not cloze\n          console.error(\"Cannot find cardN class of body element!\");\n          return \"0\";\n        }\n      }\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (!clozeOneByOneEnabled) {\n        showExtra()\n        showExtraButtons()\n        document.getElementById(\"onebyone-buttons\").style.display = \"none\"\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n        return\n      }\n\n      // Needed for amboss to recognize first word in .cloze-hidden\n      const CLOZE_REPLACER_SEP = \"<span class='hidden'> </span>\"\n\n      const hideAllCloze = function (initial) {\n        let clozes = document.getElementsByClassName(\"cloze\")\n        let count = 0 // hidden cloze count\n        for (const cloze of clozes) {\n          const existingHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n          if (existingHidden) {\n            revealCloze(cloze);\n          }\n          if (cloze.offsetWidth === 0) {\n            continue\n          }\n          const clozeReplacer = document.createElement(\"span\")\n          const clozeHidden = document.createElement(\"span\")\n          clozeReplacer.classList.add(\"cloze-replacer\")\n          clozeHidden.classList.add(\"cloze-hidden\")\n          while (cloze.childNodes.length > 0) {\n            clozeHidden.appendChild(cloze.childNodes[0])\n          }\n          cloze.appendChild(clozeReplacer)\n          cloze.appendChild(clozeHidden)\n\n          var clozeHints = Persistence.getItem(\"clozeHints\");\n          if (clozeHints && clozeHints[count]) {\n            clozeReplacer.classList.add(\"cloze-hint\")\n            clozeReplacer.innerHTML = clozeHints[count] + CLOZE_REPLACER_SEP\n          } else {\n            clozeReplacer.innerHTML = clozeHider(cloze) + CLOZE_REPLACER_SEP\n          }\n          count += 1\n          document.getElementById(\"button-reveal-next\").style.display = \"inline-block\";\n          if (initial) {\n            cloze.addEventListener(\"touchend\", revealClozeClicked)\n            cloze.addEventListener(\"click\", revealClozeClicked)\n            cloze.classList.add(\"one-by-one\");\n          }\n        }\n\n        // Hide #extra until all clozes are shown\n        const extra = document.getElementById(\"extra\");\n        if (extra) {\n          extra.classList.add(\"hidden\");\n        }\n\n        hideExtra();\n        hideExtraButtons();\n        if (revealAnywhere) {\n          document.documentElement.setAttribute(\"onclick\", \"revealNextCloze(); event.stopPropagation()\")\n        }\n\n\n        // Also hide autoReveal fields\n        for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n          const container = document.querySelector(`[data-name=\"${field}\"]`)\n          if (container) {\n            const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n            if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n              // const link = container.getElementsByTagName(\"a\")[0]\n              const button = container.getElementsByTagName(\"button\")[0]\n              const hint = container.getElementsByTagName(\"div\")[0]\n              button.classList.remove(\"expanded-button\")\n              hint.style.display = \"none\"\n              // link.style.display = \"\"\n            }\n          }\n        }\n      }\n\n      const revealCloze = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        cloze.removeChild(clozeReplacer)\n        cloze.removeChild(clozeHidden)\n        while (clozeHidden.childNodes.length > 0) {\n          cloze.appendChild(clozeHidden.childNodes[0])\n        }\n        maybeRevealExtraField()\n      }\n\n      const revealClozeWord = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        let range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundSpace = setRangeEnd(range, clozeHidden, \"beforeFirstSpace\")\n        if (!foundSpace) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        let fragment = range.extractContents()\n        cloze.insertBefore(fragment, clozeReplacer)\n        // Extract whitespaces after word\n        range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundWord = setRangeEnd(range, clozeHidden, \"beforeFirstChar\")\n        if (!foundWord) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        fragment = range.extractContents();\n        cloze.insertBefore(fragment, clozeReplacer)\n        if (!foundWord) {\n          cloze.removeChild(clozeHidden)\n          cloze.removeChild(clozeReplacer)\n          maybeRevealExtraField()\n          return\n        }\n        clozeReplacer.innerHTML = clozeHider(clozeHidden) + CLOZE_REPLACER_SEP\n        if (clozeReplacer.classList.contains(\"cloze-hint\")) [\n          clozeReplacer.classList.remove(\"cloze-hint\")\n        ]\n        maybeRevealExtraField()\n      }\n\n      const revealNextClozeOf = (type) => {\n        const nextHidden = document.querySelectorAll(\".cloze-hidden\")\n        const nextNextHidden = nextHidden.length > 1 ? true : false\n        if (!nextNextHidden) {\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\";\n        }\n        if (!nextHidden) {\n          return\n        }\n        const cloze = clozeElOfClozeHidden(nextHidden[0]);\n        if (type === \"word\") {\n          revealClozeWord(cloze)\n        } else if (type === \"cloze\") {\n          revealCloze(cloze)\n        } else {\n          console.error(\"Invalid type: \" + type)\n        }\n      }\n\n      const revealClozeClicked = function (ev) {\n        let elem = ev.currentTarget\n        if (!ev.altKey && (revealNextClozeMode !== \"word\")) {\n          revealCloze(elem)\n        } else {\n          revealClozeWord(elem)\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      }\n\n      window.revealNextCloze = function () {\n        revealNextClozeOf(revealNextClozeMode)\n      }\n\n      window.toggleAllCloze = function () {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length > 0) {\n          for (const elem of elems) {\n            const cloze = clozeElOfClozeHidden(elem)\n            revealCloze(cloze)\n          }\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\"\n        } else {\n          hideAllCloze(initial = false)\n        }\n      }\n\n      const clozeElOfClozeHidden = (cloze) => {\n        while (!cloze.classList.contains(\"cloze\")) {\n          cloze = cloze.parentElement;\n        }\n        return cloze;\n      }\n\n      const maybeRevealExtraField = () => {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length == 0) {\n          const extra = document.getElementById(\"extra\")\n          if (extra) {\n            extra.classList.remove(\"hidden\")\n          }\n\n          showExtra();\n          showExtraButtons();\n          document.documentElement.removeAttribute(\"onclick\")\n\n          // Also reveal autoReveal fields\n          for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n            const container = document.querySelector(`[data-name=\"${field}\"]`)\n            if (container) {\n              const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n              if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n                // const link = container.getElementsByTagName(\"a\")[0]\n                const button = container.getElementsByTagName(\"button\")[0]\n                const hint = container.getElementsByTagName(\"div\")[0]\n                button.classList.add(\"expanded-button\")\n                hint.style.display = \"block\"\n                // link.style.display = \"none\"\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * mode: 'beforeFirstSpace' or 'beforeFirstChar'\n       * Return `true` if it exists and setEnd() was called, otherwise `false`\n       */\n      const setRangeEnd = function (range, node, mode) {\n        if (node.nodeType === Node.TEXT_NODE) {\n          const regex = mode === 'beforeFirstSpace' ? /\\s/ : /\\S/\n          const match = node.textContent.match(regex)\n          if (match) {\n            if (match.index === 0) {\n              while (node.previousSibling === null) {\n                node = node.parentElement\n              }\n              range.setEndBefore(node)\n            } else {\n              range.setEnd(node, match.index);\n            }\n            return true;\n          } else {\n            return false;\n          }\n        } else if (mode === 'beforeFirstChar' && isCharNode(node)) {\n          range.setEndBefore(node)\n          return true\n        } else if (!ignoreSpaceInNode(node)) {\n          for (const child of node.childNodes) {\n            if (setRangeEnd(range, child, mode)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }\n\n      const ignoreSpaceInNode = function (node) {\n        return node.tagName === \"MJX-ASSISTIVE-MML\"\n      }\n\n      const isCharNode = function (node) {\n        return [\"IMG\", \"MJX-CONTAINER\"].includes(node.tagName)\n      }\n\n      hideAllCloze(initial = true)\n\n      let isShowNextShortcut = shortcutMatcher(window.revealNextShortcut)\n      let isShowWordShortcut = shortcutMatcher(window.revealNextWordShortcut)\n      let isToggleAllShortcut = shortcutMatcher(window.toggleAllShortcut)\n      ankingAddEventListener(\"keydown\", (ev) => {\n        let next = isShowNextShortcut(ev)\n        let word = isShowWordShortcut(ev)\n        let all = isToggleAllShortcut(ev)\n        if (next) {\n          revealNextClozeOf(\"cloze\")\n        } else if (word) {\n          revealNextClozeOf(\"word\")\n        } else if (all) {\n          toggleAllCloze()\n        } else {\n          return;\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      });\n    })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- MEDITRICKS SNIPPETS DATA -->\n<div id=\"meditricks-mtsp-values\" style=\"display:none;\">\n  <div id=\"meditricks-mtsp-nfname\">_meditricks_nf_v1000_ankizin</div>\n  <div id=\"meditricks-mtsp-nid\">{{Note ID}}</div>\n</div>\n<script src=\"_meditricks_mtsp_scripts_v1000_ankizin.js\"></script>\n<link href=\"_meditricks_mtsp_styles_v1000_ankizin.css\" rel=\"stylesheet\" />\n\n<!-- include \"_meditricks_mtsp_nf_v1000_ankizin.js\" -->\n<!-- include \"_meditricks_mtsp_scripts_v1000_iframe.map\" -->\n<!-- include \"_meditricks_mtsp_mtlogo.webp\" -->\n<!-- include \"_meditricks_mtsp_mt-loading.png\" -->\n<!-- include \"_meditricks_mtsp_mt-loading_night.png\" -->\n\n<!-- //MEDITRICKS SNIPPETS DATA -->\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>",
      "bqfmt": "{{Muskel / Leitungsbahn}}",
      "bafmt": "{{Ansatz}}",
      "bfont": "Helvetica",
      "bsize": 12
    },
    {
      "name": "AnsatzCloze2",
      "ord": 10,
      "qfmt": "<!-- version f0935e4 -->\n{{#Ansatz}}\n{{#AnsatzCloze2}}\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TIMER CONFIG  ##############\n  // Timer config (timer length, timer finished message)\n  var minutes = 0\n  var seconds = 15\n  var timeOverMsg = \"<span style='color:#CC5B5B'>!!!</span>\"\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  // Auto flip to back when One by one mode.\n  var autoflip = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Wo liegt der <i>Ansatz</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" data-card=\"{{Card}}\"><br>{{Ansatz}}</div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\"></div>\n\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<script>\n  //DONT FADE BETWEEN CARDS\n  qFade = 0;\n  if (typeof anki !== 'undefined') anki.qFade = qFade;\n</script>\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    if (!indentation) { return; }\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- CLOZE ONE BY ONE FRONT -->\n<div id=\"one-by-one\" style=\"display: none;\"></div>\n\n<script>\n  /**\n   * Based on the AnKing Notetype, but expanded and modified by phyn.\n   * Credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  Persistence.clear();\n\n  // check if OneByOne is generally enabled for this card\n  var oneByOneFieldEmpty = selectiveOneByOne ? \"{{One by one}}\" === \"\" : true;\n  var clozeOneByOneEnabled = alwaysOneByOne ? true : !oneByOneFieldEmpty;\n\n  // avoid flickering. Must unset this in the back.\n  document.getElementById(\"qa\").style.display = \"none\";\n  var clozeHints = [];\n\n  if (clozeOneByOneEnabled) {\n    // collect hints from front side (independent of whether or not OneByOne is enabled)\n    document.getElementById(\"qa\").classList.add('one-by-one');\n    // Save cloze hints to display in the back\n    var clozes = document.getElementsByClassName(\"cloze\")\n    for (var i = 0; i < clozes.length; i++) {\n      clozes[i].classList.add(\"one-by-one\");\n      if (clozes[i].innerHTML === \"[...]\") {\n        clozeHints.push(\"\")\n      } else {\n        clozeHints.push(clozes[i].innerHTML)\n      }\n    }\n\n    // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n    /**\n     * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n     */\n    const getCardNumber = function () {\n      clz = document.body.className;\n      const regex = /card(\\d+)/gm;\n\n      let clz2;\n      try {\n        clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n      } catch (e) {\n        clz2 = \"\";\n      }\n      const regex2 = /.*?Cloze(\\d+)/gm;\n\n      let m;\n\n      if ((m = regex2.exec(clz2)) !== null) {\n        return m[1];\n      } else if ((m = regex.exec(clz)) !== null) {\n        return m[1];\n      } else {\n        // Should only fire if card is not cloze\n        console.error(\"Cannot find cardN class of body element!\");\n        return \"0\";\n      }\n    }\n\n    var alreadyRendered = false;\n\n    function processSelective1b1() {\n      if (alreadyRendered) return;\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (autoflip && clozeOneByOneEnabled) {\n        if (window.pycmd || window.showAnswer) {\n          // avoid flickering. Must unset this in the back.\n          document.getElementById(\"qa\").style.display = \"none\";\n        }\n        if (window.pycmd) {\n          pycmd(\"ans\")\n        } else if (window.showAnswer) {\n          showAnswer()\n        }\n      } else {\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n      }\n      // AnkiMobile JS API doesn't have one for show answer.\n      // Best alternative is to use Taps/Swipes to show answer.\n\n      alreadyRendered = true;\n    }\n\n    function delayedProcessSelective1b1() {\n      if (window.requestAnimationFrame) window.requestAnimationFrame(processSelective1b1); // less flickering\n      else window.setTimeout(processSelective1b1, 0);\n    };\n\n    window.onload = delayedProcessSelective1b1;\n    if (document.readyState === \"complete\") {\n      delayedProcessSelective1b1();\n    }\n    else {\n      document.addEventListener(\"DOMContentLoaded\", delayedProcessSelective1b1);\n    }\n\n    // Observe document.body class changes to trigger re-rendering.\n    // This is useful, because Anki doesn’t always start with an up-to-date class list:\n    // https://forums.ankiweb.net/t/card-card-classes-only-injected-separately-now/27387.\n    const observer = new MutationObserver(function (mutationsList, observer) {\n      for (let mutation of mutationsList) {\n        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {\n          delayedProcessSelective1b1();\n        }\n      }\n    });\n    observer.observe(document.body, { attributes: true });\n  }\n  Persistence.setItem(\"clozeHints\", clozeHints);\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>\n\n\n{{/AnsatzCloze2}}\n{{/Ansatz}}",
      "afmt": "<!-- version f0935e4 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n<div id=\"back\"></div>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Eigene Notizen & Bilder\": \"Alt + 1\",\n    \"Eigene Prüfungsfragen\": \"Alt + 2\",\n    \"Definitionen\": \"Alt + 3\",\n    \"Merksprüche\": \"Alt + 4\",\n    \"Klinik\": \"Alt + 5\",\n    \"Präparat\": \"Alt + 6\",\n    \"Memes\": \"Alt + 7\",\n    \"linkContainer\": \"Alt + L\",\n    \"Meditricks\": \"Alt + M\",\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Eigene Notizen & Bilder\": false,\n    \"Eigene Prüfungsfragen\": false,\n    \"Definitionen\": false,\n    \"Merksprüche\": false,\n    \"Klinik\": false,\n    \"Präparat\": false,\n    \"Memes\": false,\n    \"linkContainer\": true,\n    \"Meditricks\": false,\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  var revealNextShortcut = \"N\"\n  var revealNextWordShortcut = \"Shift + N\"\n  var toggleAllShortcut = \",\"\n\n  // Enables revealing of next Cloze by simply clicking / tapping anywhere on the card (except the buttons)\n  var revealAnywhere = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // Changes how \"Reveal Next\" and clicking behaves. Either \"cloze\" or \"word\".\n  // \"word\" reveals word by word. \n  var revealNextClozeMode = \"cloze\"\n\n  // Changes how fields with additional information are displayed.\n  // true displays fields with additional information only if all clozes are revealed.\n  var hideAdditional = true;\n  var hideAdditionalButtons = true;\n\n  // What cloze is hidden with\n  var clozeHider = (elem) => \"[&nbsp;_&nbsp;]\"\n  /*\n  You can replace the above line with below examples. '█' or '_' works well for hiding clozes.\n  \n  // Fixed length:\n  var clozeHider = (elem) => \"███\"\n  // Replace each character with \"█\":\n  var clozeHider = (elem) => \"█\".repeat(elem.textContent.length)\n  // Show whitespaces:\n  var clozeHider = (elem) => \"[\" + elem.textContent.split(\" \").map((t) => \"█\".repeat(t.length)).join(\" \") + \"]\"\n  // Color-filled box (doesn't hide images):\n  var clozeHider = (elem) => `<span style=\"background-color: red; color: transparent;\">${elem.innerHTML}</span>`\n  */\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Wo liegt der <i>Ansatz</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" class=\"clozefield\" data-card=\"{{Card}}\"><br>{{Ansatz}}</div>\n\n    <!-- ClOZE ONE BY ONE BUTTONS -->\n    <div id=\"onebyone-buttons\" class=\"onebyone\">\n      <br>\n      <button id=\"button-reveal-next\" class=\"button-general button-one-by-one\"\n        onclick=\"revealNextCloze(); event.stopPropagation()\">Reveal Next</button>\n      <button id=\"button-toggle-all\" class=\"button-general button-one-by-one\"\n        onclick=\"toggleAllCloze(); event.stopPropagation()\">Toggle All</button>\n    </div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- BUTTON FIELDS -->\n    {{#Eigene Notizen & Bilder}}\n    <span id=\"hint-zusatz\" class=\"hintBtn\" data-name=\"Eigene Notizen & Bilder\" style=\"display: none;\">\n      <button id=\"button-zusatz\" class=\"button-general\" onclick=\"toggleHintBtn('hint-zusatz'); event.stopPropagation()\">\n        <img src=\"__zusatz.svg\" style=\"height: 10px;\"> Eigene Notizen & Bilder\n      </button>\n      <div dir=\"auto\" id=\"zusatz\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Notizen & Bilder}}</div>\n    </span>\n    {{/Eigene Notizen & Bilder}}\n\n    {{#Eigene Prüfungsfragen}}\n    <span id=\"hint-hammer\" class=\"hintBtn\" data-name=\"Eigene Prüfungsfragen\" style=\"display: none;\">\n      <button id=\"button-hammer\" class=\"button-general\" onclick=\"toggleHintBtn('hint-hammer'); event.stopPropagation()\">\n        <img src=\"__hammer.svg\" style=\"height: 10px;\"> Eigene Prüfungsfragen\n      </button>\n      <div dir=\"auto\" id=\"hammer\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Prüfungsfragen}}</div>\n    </span>\n    {{/Eigene Prüfungsfragen}}\n\n    {{#Definitionen}}\n    <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Definitionen\" style=\"display: none;\">\n      <button id=\"button-definition\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Definitionen\n      </button>\n      <div dir=\"auto\" id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Definitionen}}</div>\n    </span>\n    {{/Definitionen}}\n\n    {{#Merksprüche}}\n    <span id=\"hint-merksprueche\" class=\"hintBtn\" data-name=\"Merksprüche\" style=\"display: none;\">\n      <button id=\"button-merksprueche\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-merksprueche'); event.stopPropagation()\">\n        <img src=\"__merkhilfe.svg\" style=\"height: 10px;\"> Merksprüche\n      </button>\n      <div dir=\"auto\" id=\"merksprueche\" class=\"hints\" style=\"display: none;\">{{edit:Merksprüche}}</div>\n    </span>\n    {{/Merksprüche}}\n\n    {{#Klinik}}\n    <span id=\"hint-klinik\" class=\"hintBtn\" data-name=\"Klinik\" style=\"display: none;\">\n      <button id=\"button-klinik\" class=\"button-general\" onclick=\"toggleHintBtn('hint-klinik'); event.stopPropagation()\">\n        <img src=\"__stethoscope.svg\" style=\"height: 10px;\"> Klinik\n      </button>\n      <div dir=\"auto\" id=\"klinik\" class=\"hints\" style=\"display: none;\">{{edit:Klinik}}</div>\n    </span>\n    {{/Klinik}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-praeparat\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n        </button>\n      </a>\n    </span>\n    {{/Präparat}}\n\n    {{#Virtuelle Mikroskopie}}\n    <span id=\"hint-microscope-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Virtuelle Mikroskopie}}\">\n        <button id=\"button-microscope\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Virtuelle Mikroskopie\n        </button>\n      </a>\n    </span>\n    {{/Virtuelle Mikroskopie}}\n\n    {{#Smart Zoom}}\n    <span id=\"hint-smartzoom-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-smartzoom\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Smart Zoom\n        </button>\n      </a>\n    </span>\n    {{/Smart Zoom}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat\" class=\"hintBtn\" data-name=\"Präparat\" style=\"display: none;\">\n      <button id=\"button-praeparat\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-praeparat'); event.stopPropagation()\">\n        <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n      </button>\n      <div dir=\"auto\" id=\"praeparat\" class=\"hints\" style=\"display: none;\">{{edit:Präparat}}</div>\n    </span>\n    {{/Präparat}}\n\n    {{#Memes}}\n    <span id=\"hint-memes\" class=\"hintBtn\" data-name=\"Memes\" style=\"display: none;\">\n      <button id=\"button-memes\" class=\"button-general\" onclick=\"toggleHintBtn('hint-memes'); event.stopPropagation()\">\n        <img src=\"__sonstiges.svg\" style=\"height: 10px;\"> Memes\n      </button>\n      <div dir=\"auto\" id=\"memes\" class=\"hints\" style=\"display: none;\">{{edit:Memes}}</div>\n    </span>\n    {{/Memes}}\n\n    <!-- LINEBREAKS IF BUTTONS EXIST -->\n    <script>\n      var array = [`{{Eigene Notizen & Bilder}}`, `{{Eigene Prüfungsfragen}}`, `{{Definitionen}}`, `{{Merksprüche}}`, `{{Klinik}}`, `{{Präparat}}`, `{{Memes}}`];\n      var anyistrue = (element) => element;\n      if (array.some(anyistrue)) {\n        document.getElementById(\"linebreaksIfButtons\").innerHTML = \"<br>\";\n      }\n    </script>\n    <div id=\"linebreaksIfButtons\"></div>\n\n    <!-- Extra field -->\n    {{#Extra}}\n    <div id=\"extra\" style=\"display: none;\">\n      <br>{{edit:Extra}}<br><br>\n    </div>\n    {{/Extra}}\n\n    <!-- Image field -->\n    {{#Bild}}\n    <div id=\"image\" style=\"display: none;\">\n      {{edit:Bild}}<br><br></div>\n    {{/Bild}}\n    {{^Bild}}\n    <span id=\"image\" style=\"display: none;\"></span>\n    {{/Bild}}\n    {{#Bild}}\n    <span id=\"hint-image\" style=\"display: none;\">\n      <button id=\"button-image\" class=\"button-general\"\n        onclick=\"var image = document.getElementById('image'); if (image.style.display == 'none') { image.style.display = 'block' } else { image.style.display = 'none' }; event.stopPropagation()\">\n        <img src=\"__image.svg\" style=\"height: 10px;\"> Abbildung\n      </button>\n    </span>\n    {{/Bild}}\n\n    <span id=\"hint-uafi\" class=\"hintBtn\" data-name=\"Ursprung, Ansatz, Verlauf, Funktion, Innervation, Äste\"\n      style=\"display: none;\">\n      <button id=\"button-uafi\" class=\"button-general expanded-button\"\n        onclick=\"toggleHintBtn('hint-uafi'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Weitere Informationen\n      </button>\n      <div id=\"uafi\" class=\"hints\" style=\"display: block;\">\n        <table class=\"uncloze\">\n          {{#Ursprung}}\n          <tr class=\"uafi-element\" id=\"Ursprung\">\n            <td><i>Ursprung</i></td>\n            <td>{{Ursprung}}</td>\n          </tr>\n          {{/Ursprung}}\n          {{#Ansatz}}\n          <tr class=\"uafi-element\" id=\"Ansatz\">\n            <td><i>Ansatz</i></td>\n            <td>{{Ansatz}}</td>\n          </tr>\n          {{/Ansatz}}\n          {{#Verlauf}}\n          <tr class=\"uafi-element\" id=\"Verlauf\">\n            <td><i>Verlauf</i></td>\n            <td>{{Verlauf}}</td>\n          </tr>\n          {{/Verlauf}}\n          {{#Funktion}}\n          <tr class=\"uafi-element\" id=\"Funktion\">\n            <td><i>Funktion</i></td>\n            <td>{{Funktion}}</td>\n          </tr>\n          {{/Funktion}}\n          {{#Innervation}}\n          <tr class=\"uafi-element\" id=\"Innervation\">\n            <td><i>Innervation</i></td>\n            <td>{{Innervation}}</td>\n          </tr>\n          {{/Innervation}}\n          {{#Äste}}\n          <tr class=\"uafi-element\" id=\"Äste\">\n            <td><i>Äste</i></td>\n            <td>{{Äste}}</td>\n          </tr>\n          {{/Äste}}\n        </table>\n      </div>\n\n      <script>\n        // iterate over all uafi-elements and hide only the one\n        // that is equal to the card's answer (i.e., value of {{Card}})\n        var uafiElements = document.getElementsByClassName(\"uafi-element\");\n        for (var i = 0; i < uafiElements.length; i++) {\n          if (((\"{{Card}}\").startsWith(uafiElements[i].id))) {\n            uafiElements[i].remove()\n          }\n        }\n      </script>\n    </span>\n\n    {{#AMBOSS-Link}}\n    <span id=\"hint-amboss\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:AMBOSS-Link}}\">\n        <button id=\"button-amboss\" class=\"button-general\">\n          <img src=\"__amboss.svg\" style=\"height: 10px;\"> AMBOSS&#8203;\n        </button>\n      </a>\n    </span>\n    {{/AMBOSS-Link}}\n\n    {{#Thieme via medici-Link}}\n    <span id=\"hint-thieme\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Thieme via medici-Link}}\">\n        <button id=\"button-thieme\" class=\"button-general\">\n          <img id=\"button-thieme-img\" src=\"__thieme-heart.svg\" style=\"height: 10px;\"> Thieme via medici\n        </button>\n      </a>\n    </span>\n    {{/Thieme via medici-Link}}\n\n    {{#Meditricks}}\n    <span id=\"hint-meditricks\" class=\"hintBtn\" data-name=\"Meditricks\" style=\"display: none;\">\n      <button id=\"button-meditricks\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-meditricks'); event.stopPropagation()\">\n        <img src=\"__meditricks.svg\" style=\"height: 10px;\"> Meditricks\n      </button>\n      <div dir=\"auto\" id=\"meditricks\" class=\"hints\" style=\"display: none;\">{{edit:Meditricks}}</div>\n    </span>\n    {{/Meditricks}}\n\n    {{#weitere Links}}\n    <span id=\"hint-linkcontainer\" class=\"hintBtn\" data-name=\"linkContainer\" style=\"display: none;\">\n      <button id=\"button-linkcontainer\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-linkcontainer'); event.stopPropagation()\">\n        <img src=\"__internet.svg\" style=\"height: 10px;\"> weitere Links\n      </button>\n      <div id=\"linkcontainer\" class=\"hints\" style=\"display: none;\"></div>\n      <span id=\"linkContainerLinks\" style=\"display: none;\">{{edit:weitere Links}}</span>\n    </span>\n    {{/weitere Links}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n  try {\n    for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n      href = link.href\n      text = link.innerText\n\n      const el = document.createElement('a');\n      el.setAttribute('href', link.href);\n\n      const btn = document.createElement('button');\n      btn.classList.add('button-general');\n      btn.classList.add('expanded-button');\n\n      domain = href.replace(/.+\\/\\/|(www|flexikon|register|de|next|com).|\\..+/g, '');\n      domainDict = {\n        \"amboss\": \"__amboss.svg\",\n        \"wikipedia\": \"__wikipedia.svg\",\n        \"doccheck\": \"__doccheck.png\",\n        \"notfallguru\": \"__notfallguru.svg\",\n        \"awmf\": \"__awmf.svg\",\n        \"gelbe-liste\": \"__gelbe-liste.png\",\n        \"embryotox\": \"__embryotox.svg\",\n        \"radiopaedia\": \"__radiopaedia.png\",\n        \"orphanet\": \"__orphanet.png\",\n      }\n      if (domain in domainDict) {\n        icon = domainDict[domain]\n      } else {\n        icon = \"__internet.svg\"\n      }\n\n      const img = document.createElement('img');\n      img.setAttribute('src', icon);\n      img.setAttribute('style', 'height: 10px;');\n\n      btn.appendChild(img);\n      btn.innerHTML = btn.innerHTML + \" \" + text;\n\n      el.appendChild(btn);\n\n      document.getElementById(\"linkcontainer\").appendChild(el)\n    }\n  }\n  catch (err) {\n    console.log(err)\n  }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-uafi\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- AUTOFLIP BACK SCRIPT -->\n<script>\n  // autoflip hides card in front template\n  document.getElementById(\"qa\").style.removeProperty(\"display\")\n</script>\n\n<!-- CLOZE ONE BY ONE SCRIPT -->\n<style>\n  .cloze-replacer:hover {\n    cursor: pointer;\n  }\n\n  .cloze-hidden {\n    display: none;\n  }\n\n  .cloze-replacer .hidden {\n    display: none;\n  }\n\n  #extra.hidden {\n    display: none;\n  }\n</style>\n\n<!--\n Based on the AnKing Notetype, but expanded and modified by phyn.\n Credit to the original authors, except where modified or otherwise indicated.\n-->\n\n<script>\n    (function () {\n      // enables cloze one-by-one even when one-by-one field is empty\n      // minNumberOfClozes is still considered in this case\n      // overridden in importance by selectiveOneByOne\n      var clozeOneByOneEnabled = true;\n\n      // remove the clickAnywhere function from global scope\n      document.documentElement.removeAttribute(\"onclick\")\n\n      // --- CHECK IF ONE BY ONE IS GENERALLY ENABLED FOR THIS NOTE ---\n      var oneByOneFieldNotEmpty = \"{{One by one}}\" !== \"\";\n      try {\n        clozeOneByOneEnabled = alwaysOneByOne || oneByOneFieldNotEmpty;\n      } catch (exception) {\n        console.log(exception)\n      }\n\n      /**\n   * helper functions to show / hide fields containing additional information\n   */\n      const showExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const hideExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const buttonIds = [\n        \"hint-zusatz\",\n        \"hint-definition\",\n        \"hint-hammer\",\n        \"hint-klinik\",\n        \"hint-praeparat\",\n        \"hint-microscope\",\n        \"hint-smartzoom\",\n        \"hint-histotrainer\",\n        \"hint-uafi\",\n        \"hint-merksprueche\",\n        \"hint-memes\",\n        \"hint-image\",\n        \"hint-amboss\",\n        \"hint-thieme\",\n        \"hint-meditricks\",\n        \"hint-linkcontainer\",\n      ];\n\n      const showExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document\n              .getElementById(buttonIds[button])\n              .style.removeProperty(\"display\");\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n      const hideExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document.getElementById(buttonIds[button]).style.display = \"none\";\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n\n      // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n      /**\n       * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n       */\n      const getCardNumber = function () {\n        clz = document.body.className;\n        const regex = /card(\\d+)/gm;\n\n        let clz2;\n        try {\n          clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n        } catch (e) {\n          clz2 = \"\";\n        }\n        const regex2 = /.*?Cloze(\\d+)/gm;\n\n        let m;\n\n        if ((m = regex2.exec(clz2)) !== null) {\n          return m[1];\n        } else if ((m = regex.exec(clz)) !== null) {\n          return m[1];\n        } else {\n          // Should only fire if card is not cloze\n          console.error(\"Cannot find cardN class of body element!\");\n          return \"0\";\n        }\n      }\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (!clozeOneByOneEnabled) {\n        showExtra()\n        showExtraButtons()\n        document.getElementById(\"onebyone-buttons\").style.display = \"none\"\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n        return\n      }\n\n      // Needed for amboss to recognize first word in .cloze-hidden\n      const CLOZE_REPLACER_SEP = \"<span class='hidden'> </span>\"\n\n      const hideAllCloze = function (initial) {\n        let clozes = document.getElementsByClassName(\"cloze\")\n        let count = 0 // hidden cloze count\n        for (const cloze of clozes) {\n          const existingHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n          if (existingHidden) {\n            revealCloze(cloze);\n          }\n          if (cloze.offsetWidth === 0) {\n            continue\n          }\n          const clozeReplacer = document.createElement(\"span\")\n          const clozeHidden = document.createElement(\"span\")\n          clozeReplacer.classList.add(\"cloze-replacer\")\n          clozeHidden.classList.add(\"cloze-hidden\")\n          while (cloze.childNodes.length > 0) {\n            clozeHidden.appendChild(cloze.childNodes[0])\n          }\n          cloze.appendChild(clozeReplacer)\n          cloze.appendChild(clozeHidden)\n\n          var clozeHints = Persistence.getItem(\"clozeHints\");\n          if (clozeHints && clozeHints[count]) {\n            clozeReplacer.classList.add(\"cloze-hint\")\n            clozeReplacer.innerHTML = clozeHints[count] + CLOZE_REPLACER_SEP\n          } else {\n            clozeReplacer.innerHTML = clozeHider(cloze) + CLOZE_REPLACER_SEP\n          }\n          count += 1\n          document.getElementById(\"button-reveal-next\").style.display = \"inline-block\";\n          if (initial) {\n            cloze.addEventListener(\"touchend\", revealClozeClicked)\n            cloze.addEventListener(\"click\", revealClozeClicked)\n            cloze.classList.add(\"one-by-one\");\n          }\n        }\n\n        // Hide #extra until all clozes are shown\n        const extra = document.getElementById(\"extra\");\n        if (extra) {\n          extra.classList.add(\"hidden\");\n        }\n\n        hideExtra();\n        hideExtraButtons();\n        if (revealAnywhere) {\n          document.documentElement.setAttribute(\"onclick\", \"revealNextCloze(); event.stopPropagation()\")\n        }\n\n\n        // Also hide autoReveal fields\n        for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n          const container = document.querySelector(`[data-name=\"${field}\"]`)\n          if (container) {\n            const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n            if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n              // const link = container.getElementsByTagName(\"a\")[0]\n              const button = container.getElementsByTagName(\"button\")[0]\n              const hint = container.getElementsByTagName(\"div\")[0]\n              button.classList.remove(\"expanded-button\")\n              hint.style.display = \"none\"\n              // link.style.display = \"\"\n            }\n          }\n        }\n      }\n\n      const revealCloze = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        cloze.removeChild(clozeReplacer)\n        cloze.removeChild(clozeHidden)\n        while (clozeHidden.childNodes.length > 0) {\n          cloze.appendChild(clozeHidden.childNodes[0])\n        }\n        maybeRevealExtraField()\n      }\n\n      const revealClozeWord = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        let range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundSpace = setRangeEnd(range, clozeHidden, \"beforeFirstSpace\")\n        if (!foundSpace) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        let fragment = range.extractContents()\n        cloze.insertBefore(fragment, clozeReplacer)\n        // Extract whitespaces after word\n        range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundWord = setRangeEnd(range, clozeHidden, \"beforeFirstChar\")\n        if (!foundWord) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        fragment = range.extractContents();\n        cloze.insertBefore(fragment, clozeReplacer)\n        if (!foundWord) {\n          cloze.removeChild(clozeHidden)\n          cloze.removeChild(clozeReplacer)\n          maybeRevealExtraField()\n          return\n        }\n        clozeReplacer.innerHTML = clozeHider(clozeHidden) + CLOZE_REPLACER_SEP\n        if (clozeReplacer.classList.contains(\"cloze-hint\")) [\n          clozeReplacer.classList.remove(\"cloze-hint\")\n        ]\n        maybeRevealExtraField()\n      }\n\n      const revealNextClozeOf = (type) => {\n        const nextHidden = document.querySelectorAll(\".cloze-hidden\")\n        const nextNextHidden = nextHidden.length > 1 ? true : false\n        if (!nextNextHidden) {\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\";\n        }\n        if (!nextHidden) {\n          return\n        }\n        const cloze = clozeElOfClozeHidden(nextHidden[0]);\n        if (type === \"word\") {\n          revealClozeWord(cloze)\n        } else if (type === \"cloze\") {\n          revealCloze(cloze)\n        } else {\n          console.error(\"Invalid type: \" + type)\n        }\n      }\n\n      const revealClozeClicked = function (ev) {\n        let elem = ev.currentTarget\n        if (!ev.altKey && (revealNextClozeMode !== \"word\")) {\n          revealCloze(elem)\n        } else {\n          revealClozeWord(elem)\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      }\n\n      window.revealNextCloze = function () {\n        revealNextClozeOf(revealNextClozeMode)\n      }\n\n      window.toggleAllCloze = function () {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length > 0) {\n          for (const elem of elems) {\n            const cloze = clozeElOfClozeHidden(elem)\n            revealCloze(cloze)\n          }\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\"\n        } else {\n          hideAllCloze(initial = false)\n        }\n      }\n\n      const clozeElOfClozeHidden = (cloze) => {\n        while (!cloze.classList.contains(\"cloze\")) {\n          cloze = cloze.parentElement;\n        }\n        return cloze;\n      }\n\n      const maybeRevealExtraField = () => {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length == 0) {\n          const extra = document.getElementById(\"extra\")\n          if (extra) {\n            extra.classList.remove(\"hidden\")\n          }\n\n          showExtra();\n          showExtraButtons();\n          document.documentElement.removeAttribute(\"onclick\")\n\n          // Also reveal autoReveal fields\n          for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n            const container = document.querySelector(`[data-name=\"${field}\"]`)\n            if (container) {\n              const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n              if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n                // const link = container.getElementsByTagName(\"a\")[0]\n                const button = container.getElementsByTagName(\"button\")[0]\n                const hint = container.getElementsByTagName(\"div\")[0]\n                button.classList.add(\"expanded-button\")\n                hint.style.display = \"block\"\n                // link.style.display = \"none\"\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * mode: 'beforeFirstSpace' or 'beforeFirstChar'\n       * Return `true` if it exists and setEnd() was called, otherwise `false`\n       */\n      const setRangeEnd = function (range, node, mode) {\n        if (node.nodeType === Node.TEXT_NODE) {\n          const regex = mode === 'beforeFirstSpace' ? /\\s/ : /\\S/\n          const match = node.textContent.match(regex)\n          if (match) {\n            if (match.index === 0) {\n              while (node.previousSibling === null) {\n                node = node.parentElement\n              }\n              range.setEndBefore(node)\n            } else {\n              range.setEnd(node, match.index);\n            }\n            return true;\n          } else {\n            return false;\n          }\n        } else if (mode === 'beforeFirstChar' && isCharNode(node)) {\n          range.setEndBefore(node)\n          return true\n        } else if (!ignoreSpaceInNode(node)) {\n          for (const child of node.childNodes) {\n            if (setRangeEnd(range, child, mode)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }\n\n      const ignoreSpaceInNode = function (node) {\n        return node.tagName === \"MJX-ASSISTIVE-MML\"\n      }\n\n      const isCharNode = function (node) {\n        return [\"IMG\", \"MJX-CONTAINER\"].includes(node.tagName)\n      }\n\n      hideAllCloze(initial = true)\n\n      let isShowNextShortcut = shortcutMatcher(window.revealNextShortcut)\n      let isShowWordShortcut = shortcutMatcher(window.revealNextWordShortcut)\n      let isToggleAllShortcut = shortcutMatcher(window.toggleAllShortcut)\n      ankingAddEventListener(\"keydown\", (ev) => {\n        let next = isShowNextShortcut(ev)\n        let word = isShowWordShortcut(ev)\n        let all = isToggleAllShortcut(ev)\n        if (next) {\n          revealNextClozeOf(\"cloze\")\n        } else if (word) {\n          revealNextClozeOf(\"word\")\n        } else if (all) {\n          toggleAllCloze()\n        } else {\n          return;\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      });\n    })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- MEDITRICKS SNIPPETS DATA -->\n<div id=\"meditricks-mtsp-values\" style=\"display:none;\">\n  <div id=\"meditricks-mtsp-nfname\">_meditricks_nf_v1000_ankizin</div>\n  <div id=\"meditricks-mtsp-nid\">{{Note ID}}</div>\n</div>\n<script src=\"_meditricks_mtsp_scripts_v1000_ankizin.js\"></script>\n<link href=\"_meditricks_mtsp_styles_v1000_ankizin.css\" rel=\"stylesheet\" />\n\n<!-- include \"_meditricks_mtsp_nf_v1000_ankizin.js\" -->\n<!-- include \"_meditricks_mtsp_scripts_v1000_iframe.map\" -->\n<!-- include \"_meditricks_mtsp_mtlogo.webp\" -->\n<!-- include \"_meditricks_mtsp_mt-loading.png\" -->\n<!-- include \"_meditricks_mtsp_mt-loading_night.png\" -->\n\n<!-- //MEDITRICKS SNIPPETS DATA -->\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>",
      "bqfmt": "{{Muskel / Leitungsbahn}}",
      "bafmt": "{{Ansatz}}",
      "bfont": "Helvetica",
      "bsize": 12
    },
    {
      "name": "AnsatzCloze3",
      "ord": 11,
      "qfmt": "<!-- version f0935e4 -->\n{{#Ansatz}}\n{{#AnsatzCloze3}}\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TIMER CONFIG  ##############\n  // Timer config (timer length, timer finished message)\n  var minutes = 0\n  var seconds = 15\n  var timeOverMsg = \"<span style='color:#CC5B5B'>!!!</span>\"\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  // Auto flip to back when One by one mode.\n  var autoflip = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Wo liegt der <i>Ansatz</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" data-card=\"{{Card}}\"><br>{{Ansatz}}</div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\"></div>\n\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<script>\n  //DONT FADE BETWEEN CARDS\n  qFade = 0;\n  if (typeof anki !== 'undefined') anki.qFade = qFade;\n</script>\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    if (!indentation) { return; }\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- CLOZE ONE BY ONE FRONT -->\n<div id=\"one-by-one\" style=\"display: none;\"></div>\n\n<script>\n  /**\n   * Based on the AnKing Notetype, but expanded and modified by phyn.\n   * Credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  Persistence.clear();\n\n  // check if OneByOne is generally enabled for this card\n  var oneByOneFieldEmpty = selectiveOneByOne ? \"{{One by one}}\" === \"\" : true;\n  var clozeOneByOneEnabled = alwaysOneByOne ? true : !oneByOneFieldEmpty;\n\n  // avoid flickering. Must unset this in the back.\n  document.getElementById(\"qa\").style.display = \"none\";\n  var clozeHints = [];\n\n  if (clozeOneByOneEnabled) {\n    // collect hints from front side (independent of whether or not OneByOne is enabled)\n    document.getElementById(\"qa\").classList.add('one-by-one');\n    // Save cloze hints to display in the back\n    var clozes = document.getElementsByClassName(\"cloze\")\n    for (var i = 0; i < clozes.length; i++) {\n      clozes[i].classList.add(\"one-by-one\");\n      if (clozes[i].innerHTML === \"[...]\") {\n        clozeHints.push(\"\")\n      } else {\n        clozeHints.push(clozes[i].innerHTML)\n      }\n    }\n\n    // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n    /**\n     * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n     */\n    const getCardNumber = function () {\n      clz = document.body.className;\n      const regex = /card(\\d+)/gm;\n\n      let clz2;\n      try {\n        clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n      } catch (e) {\n        clz2 = \"\";\n      }\n      const regex2 = /.*?Cloze(\\d+)/gm;\n\n      let m;\n\n      if ((m = regex2.exec(clz2)) !== null) {\n        return m[1];\n      } else if ((m = regex.exec(clz)) !== null) {\n        return m[1];\n      } else {\n        // Should only fire if card is not cloze\n        console.error(\"Cannot find cardN class of body element!\");\n        return \"0\";\n      }\n    }\n\n    var alreadyRendered = false;\n\n    function processSelective1b1() {\n      if (alreadyRendered) return;\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (autoflip && clozeOneByOneEnabled) {\n        if (window.pycmd || window.showAnswer) {\n          // avoid flickering. Must unset this in the back.\n          document.getElementById(\"qa\").style.display = \"none\";\n        }\n        if (window.pycmd) {\n          pycmd(\"ans\")\n        } else if (window.showAnswer) {\n          showAnswer()\n        }\n      } else {\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n      }\n      // AnkiMobile JS API doesn't have one for show answer.\n      // Best alternative is to use Taps/Swipes to show answer.\n\n      alreadyRendered = true;\n    }\n\n    function delayedProcessSelective1b1() {\n      if (window.requestAnimationFrame) window.requestAnimationFrame(processSelective1b1); // less flickering\n      else window.setTimeout(processSelective1b1, 0);\n    };\n\n    window.onload = delayedProcessSelective1b1;\n    if (document.readyState === \"complete\") {\n      delayedProcessSelective1b1();\n    }\n    else {\n      document.addEventListener(\"DOMContentLoaded\", delayedProcessSelective1b1);\n    }\n\n    // Observe document.body class changes to trigger re-rendering.\n    // This is useful, because Anki doesn’t always start with an up-to-date class list:\n    // https://forums.ankiweb.net/t/card-card-classes-only-injected-separately-now/27387.\n    const observer = new MutationObserver(function (mutationsList, observer) {\n      for (let mutation of mutationsList) {\n        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {\n          delayedProcessSelective1b1();\n        }\n      }\n    });\n    observer.observe(document.body, { attributes: true });\n  }\n  Persistence.setItem(\"clozeHints\", clozeHints);\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>\n\n\n{{/AnsatzCloze3}}\n{{/Ansatz}}",
      "afmt": "<!-- version f0935e4 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n<div id=\"back\"></div>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Eigene Notizen & Bilder\": \"Alt + 1\",\n    \"Eigene Prüfungsfragen\": \"Alt + 2\",\n    \"Definitionen\": \"Alt + 3\",\n    \"Merksprüche\": \"Alt + 4\",\n    \"Klinik\": \"Alt + 5\",\n    \"Präparat\": \"Alt + 6\",\n    \"Memes\": \"Alt + 7\",\n    \"linkContainer\": \"Alt + L\",\n    \"Meditricks\": \"Alt + M\",\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Eigene Notizen & Bilder\": false,\n    \"Eigene Prüfungsfragen\": false,\n    \"Definitionen\": false,\n    \"Merksprüche\": false,\n    \"Klinik\": false,\n    \"Präparat\": false,\n    \"Memes\": false,\n    \"linkContainer\": true,\n    \"Meditricks\": false,\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  var revealNextShortcut = \"N\"\n  var revealNextWordShortcut = \"Shift + N\"\n  var toggleAllShortcut = \",\"\n\n  // Enables revealing of next Cloze by simply clicking / tapping anywhere on the card (except the buttons)\n  var revealAnywhere = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // Changes how \"Reveal Next\" and clicking behaves. Either \"cloze\" or \"word\".\n  // \"word\" reveals word by word. \n  var revealNextClozeMode = \"cloze\"\n\n  // Changes how fields with additional information are displayed.\n  // true displays fields with additional information only if all clozes are revealed.\n  var hideAdditional = true;\n  var hideAdditionalButtons = true;\n\n  // What cloze is hidden with\n  var clozeHider = (elem) => \"[&nbsp;_&nbsp;]\"\n  /*\n  You can replace the above line with below examples. '█' or '_' works well for hiding clozes.\n  \n  // Fixed length:\n  var clozeHider = (elem) => \"███\"\n  // Replace each character with \"█\":\n  var clozeHider = (elem) => \"█\".repeat(elem.textContent.length)\n  // Show whitespaces:\n  var clozeHider = (elem) => \"[\" + elem.textContent.split(\" \").map((t) => \"█\".repeat(t.length)).join(\" \") + \"]\"\n  // Color-filled box (doesn't hide images):\n  var clozeHider = (elem) => `<span style=\"background-color: red; color: transparent;\">${elem.innerHTML}</span>`\n  */\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Wo liegt der <i>Ansatz</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" class=\"clozefield\" data-card=\"{{Card}}\"><br>{{Ansatz}}</div>\n\n    <!-- ClOZE ONE BY ONE BUTTONS -->\n    <div id=\"onebyone-buttons\" class=\"onebyone\">\n      <br>\n      <button id=\"button-reveal-next\" class=\"button-general button-one-by-one\"\n        onclick=\"revealNextCloze(); event.stopPropagation()\">Reveal Next</button>\n      <button id=\"button-toggle-all\" class=\"button-general button-one-by-one\"\n        onclick=\"toggleAllCloze(); event.stopPropagation()\">Toggle All</button>\n    </div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- BUTTON FIELDS -->\n    {{#Eigene Notizen & Bilder}}\n    <span id=\"hint-zusatz\" class=\"hintBtn\" data-name=\"Eigene Notizen & Bilder\" style=\"display: none;\">\n      <button id=\"button-zusatz\" class=\"button-general\" onclick=\"toggleHintBtn('hint-zusatz'); event.stopPropagation()\">\n        <img src=\"__zusatz.svg\" style=\"height: 10px;\"> Eigene Notizen & Bilder\n      </button>\n      <div dir=\"auto\" id=\"zusatz\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Notizen & Bilder}}</div>\n    </span>\n    {{/Eigene Notizen & Bilder}}\n\n    {{#Eigene Prüfungsfragen}}\n    <span id=\"hint-hammer\" class=\"hintBtn\" data-name=\"Eigene Prüfungsfragen\" style=\"display: none;\">\n      <button id=\"button-hammer\" class=\"button-general\" onclick=\"toggleHintBtn('hint-hammer'); event.stopPropagation()\">\n        <img src=\"__hammer.svg\" style=\"height: 10px;\"> Eigene Prüfungsfragen\n      </button>\n      <div dir=\"auto\" id=\"hammer\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Prüfungsfragen}}</div>\n    </span>\n    {{/Eigene Prüfungsfragen}}\n\n    {{#Definitionen}}\n    <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Definitionen\" style=\"display: none;\">\n      <button id=\"button-definition\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Definitionen\n      </button>\n      <div dir=\"auto\" id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Definitionen}}</div>\n    </span>\n    {{/Definitionen}}\n\n    {{#Merksprüche}}\n    <span id=\"hint-merksprueche\" class=\"hintBtn\" data-name=\"Merksprüche\" style=\"display: none;\">\n      <button id=\"button-merksprueche\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-merksprueche'); event.stopPropagation()\">\n        <img src=\"__merkhilfe.svg\" style=\"height: 10px;\"> Merksprüche\n      </button>\n      <div dir=\"auto\" id=\"merksprueche\" class=\"hints\" style=\"display: none;\">{{edit:Merksprüche}}</div>\n    </span>\n    {{/Merksprüche}}\n\n    {{#Klinik}}\n    <span id=\"hint-klinik\" class=\"hintBtn\" data-name=\"Klinik\" style=\"display: none;\">\n      <button id=\"button-klinik\" class=\"button-general\" onclick=\"toggleHintBtn('hint-klinik'); event.stopPropagation()\">\n        <img src=\"__stethoscope.svg\" style=\"height: 10px;\"> Klinik\n      </button>\n      <div dir=\"auto\" id=\"klinik\" class=\"hints\" style=\"display: none;\">{{edit:Klinik}}</div>\n    </span>\n    {{/Klinik}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-praeparat\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n        </button>\n      </a>\n    </span>\n    {{/Präparat}}\n\n    {{#Virtuelle Mikroskopie}}\n    <span id=\"hint-microscope-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Virtuelle Mikroskopie}}\">\n        <button id=\"button-microscope\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Virtuelle Mikroskopie\n        </button>\n      </a>\n    </span>\n    {{/Virtuelle Mikroskopie}}\n\n    {{#Smart Zoom}}\n    <span id=\"hint-smartzoom-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-smartzoom\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Smart Zoom\n        </button>\n      </a>\n    </span>\n    {{/Smart Zoom}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat\" class=\"hintBtn\" data-name=\"Präparat\" style=\"display: none;\">\n      <button id=\"button-praeparat\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-praeparat'); event.stopPropagation()\">\n        <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n      </button>\n      <div dir=\"auto\" id=\"praeparat\" class=\"hints\" style=\"display: none;\">{{edit:Präparat}}</div>\n    </span>\n    {{/Präparat}}\n\n    {{#Memes}}\n    <span id=\"hint-memes\" class=\"hintBtn\" data-name=\"Memes\" style=\"display: none;\">\n      <button id=\"button-memes\" class=\"button-general\" onclick=\"toggleHintBtn('hint-memes'); event.stopPropagation()\">\n        <img src=\"__sonstiges.svg\" style=\"height: 10px;\"> Memes\n      </button>\n      <div dir=\"auto\" id=\"memes\" class=\"hints\" style=\"display: none;\">{{edit:Memes}}</div>\n    </span>\n    {{/Memes}}\n\n    <!-- LINEBREAKS IF BUTTONS EXIST -->\n    <script>\n      var array = [`{{Eigene Notizen & Bilder}}`, `{{Eigene Prüfungsfragen}}`, `{{Definitionen}}`, `{{Merksprüche}}`, `{{Klinik}}`, `{{Präparat}}`, `{{Memes}}`];\n      var anyistrue = (element) => element;\n      if (array.some(anyistrue)) {\n        document.getElementById(\"linebreaksIfButtons\").innerHTML = \"<br>\";\n      }\n    </script>\n    <div id=\"linebreaksIfButtons\"></div>\n\n    <!-- Extra field -->\n    {{#Extra}}\n    <div id=\"extra\" style=\"display: none;\">\n      <br>{{edit:Extra}}<br><br>\n    </div>\n    {{/Extra}}\n\n    <!-- Image field -->\n    {{#Bild}}\n    <div id=\"image\" style=\"display: none;\">\n      {{edit:Bild}}<br><br></div>\n    {{/Bild}}\n    {{^Bild}}\n    <span id=\"image\" style=\"display: none;\"></span>\n    {{/Bild}}\n    {{#Bild}}\n    <span id=\"hint-image\" style=\"display: none;\">\n      <button id=\"button-image\" class=\"button-general\"\n        onclick=\"var image = document.getElementById('image'); if (image.style.display == 'none') { image.style.display = 'block' } else { image.style.display = 'none' }; event.stopPropagation()\">\n        <img src=\"__image.svg\" style=\"height: 10px;\"> Abbildung\n      </button>\n    </span>\n    {{/Bild}}\n\n    <span id=\"hint-uafi\" class=\"hintBtn\" data-name=\"Ursprung, Ansatz, Verlauf, Funktion, Innervation, Äste\"\n      style=\"display: none;\">\n      <button id=\"button-uafi\" class=\"button-general expanded-button\"\n        onclick=\"toggleHintBtn('hint-uafi'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Weitere Informationen\n      </button>\n      <div id=\"uafi\" class=\"hints\" style=\"display: block;\">\n        <table class=\"uncloze\">\n          {{#Ursprung}}\n          <tr class=\"uafi-element\" id=\"Ursprung\">\n            <td><i>Ursprung</i></td>\n            <td>{{Ursprung}}</td>\n          </tr>\n          {{/Ursprung}}\n          {{#Ansatz}}\n          <tr class=\"uafi-element\" id=\"Ansatz\">\n            <td><i>Ansatz</i></td>\n            <td>{{Ansatz}}</td>\n          </tr>\n          {{/Ansatz}}\n          {{#Verlauf}}\n          <tr class=\"uafi-element\" id=\"Verlauf\">\n            <td><i>Verlauf</i></td>\n            <td>{{Verlauf}}</td>\n          </tr>\n          {{/Verlauf}}\n          {{#Funktion}}\n          <tr class=\"uafi-element\" id=\"Funktion\">\n            <td><i>Funktion</i></td>\n            <td>{{Funktion}}</td>\n          </tr>\n          {{/Funktion}}\n          {{#Innervation}}\n          <tr class=\"uafi-element\" id=\"Innervation\">\n            <td><i>Innervation</i></td>\n            <td>{{Innervation}}</td>\n          </tr>\n          {{/Innervation}}\n          {{#Äste}}\n          <tr class=\"uafi-element\" id=\"Äste\">\n            <td><i>Äste</i></td>\n            <td>{{Äste}}</td>\n          </tr>\n          {{/Äste}}\n        </table>\n      </div>\n\n      <script>\n        // iterate over all uafi-elements and hide only the one\n        // that is equal to the card's answer (i.e., value of {{Card}})\n        var uafiElements = document.getElementsByClassName(\"uafi-element\");\n        for (var i = 0; i < uafiElements.length; i++) {\n          if (((\"{{Card}}\").startsWith(uafiElements[i].id))) {\n            uafiElements[i].remove()\n          }\n        }\n      </script>\n    </span>\n\n    {{#AMBOSS-Link}}\n    <span id=\"hint-amboss\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:AMBOSS-Link}}\">\n        <button id=\"button-amboss\" class=\"button-general\">\n          <img src=\"__amboss.svg\" style=\"height: 10px;\"> AMBOSS&#8203;\n        </button>\n      </a>\n    </span>\n    {{/AMBOSS-Link}}\n\n    {{#Thieme via medici-Link}}\n    <span id=\"hint-thieme\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Thieme via medici-Link}}\">\n        <button id=\"button-thieme\" class=\"button-general\">\n          <img id=\"button-thieme-img\" src=\"__thieme-heart.svg\" style=\"height: 10px;\"> Thieme via medici\n        </button>\n      </a>\n    </span>\n    {{/Thieme via medici-Link}}\n\n    {{#Meditricks}}\n    <span id=\"hint-meditricks\" class=\"hintBtn\" data-name=\"Meditricks\" style=\"display: none;\">\n      <button id=\"button-meditricks\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-meditricks'); event.stopPropagation()\">\n        <img src=\"__meditricks.svg\" style=\"height: 10px;\"> Meditricks\n      </button>\n      <div dir=\"auto\" id=\"meditricks\" class=\"hints\" style=\"display: none;\">{{edit:Meditricks}}</div>\n    </span>\n    {{/Meditricks}}\n\n    {{#weitere Links}}\n    <span id=\"hint-linkcontainer\" class=\"hintBtn\" data-name=\"linkContainer\" style=\"display: none;\">\n      <button id=\"button-linkcontainer\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-linkcontainer'); event.stopPropagation()\">\n        <img src=\"__internet.svg\" style=\"height: 10px;\"> weitere Links\n      </button>\n      <div id=\"linkcontainer\" class=\"hints\" style=\"display: none;\"></div>\n      <span id=\"linkContainerLinks\" style=\"display: none;\">{{edit:weitere Links}}</span>\n    </span>\n    {{/weitere Links}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n  try {\n    for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n      href = link.href\n      text = link.innerText\n\n      const el = document.createElement('a');\n      el.setAttribute('href', link.href);\n\n      const btn = document.createElement('button');\n      btn.classList.add('button-general');\n      btn.classList.add('expanded-button');\n\n      domain = href.replace(/.+\\/\\/|(www|flexikon|register|de|next|com).|\\..+/g, '');\n      domainDict = {\n        \"amboss\": \"__amboss.svg\",\n        \"wikipedia\": \"__wikipedia.svg\",\n        \"doccheck\": \"__doccheck.png\",\n        \"notfallguru\": \"__notfallguru.svg\",\n        \"awmf\": \"__awmf.svg\",\n        \"gelbe-liste\": \"__gelbe-liste.png\",\n        \"embryotox\": \"__embryotox.svg\",\n        \"radiopaedia\": \"__radiopaedia.png\",\n        \"orphanet\": \"__orphanet.png\",\n      }\n      if (domain in domainDict) {\n        icon = domainDict[domain]\n      } else {\n        icon = \"__internet.svg\"\n      }\n\n      const img = document.createElement('img');\n      img.setAttribute('src', icon);\n      img.setAttribute('style', 'height: 10px;');\n\n      btn.appendChild(img);\n      btn.innerHTML = btn.innerHTML + \" \" + text;\n\n      el.appendChild(btn);\n\n      document.getElementById(\"linkcontainer\").appendChild(el)\n    }\n  }\n  catch (err) {\n    console.log(err)\n  }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-uafi\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- AUTOFLIP BACK SCRIPT -->\n<script>\n  // autoflip hides card in front template\n  document.getElementById(\"qa\").style.removeProperty(\"display\")\n</script>\n\n<!-- CLOZE ONE BY ONE SCRIPT -->\n<style>\n  .cloze-replacer:hover {\n    cursor: pointer;\n  }\n\n  .cloze-hidden {\n    display: none;\n  }\n\n  .cloze-replacer .hidden {\n    display: none;\n  }\n\n  #extra.hidden {\n    display: none;\n  }\n</style>\n\n<!--\n Based on the AnKing Notetype, but expanded and modified by phyn.\n Credit to the original authors, except where modified or otherwise indicated.\n-->\n\n<script>\n    (function () {\n      // enables cloze one-by-one even when one-by-one field is empty\n      // minNumberOfClozes is still considered in this case\n      // overridden in importance by selectiveOneByOne\n      var clozeOneByOneEnabled = true;\n\n      // remove the clickAnywhere function from global scope\n      document.documentElement.removeAttribute(\"onclick\")\n\n      // --- CHECK IF ONE BY ONE IS GENERALLY ENABLED FOR THIS NOTE ---\n      var oneByOneFieldNotEmpty = \"{{One by one}}\" !== \"\";\n      try {\n        clozeOneByOneEnabled = alwaysOneByOne || oneByOneFieldNotEmpty;\n      } catch (exception) {\n        console.log(exception)\n      }\n\n      /**\n   * helper functions to show / hide fields containing additional information\n   */\n      const showExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const hideExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const buttonIds = [\n        \"hint-zusatz\",\n        \"hint-definition\",\n        \"hint-hammer\",\n        \"hint-klinik\",\n        \"hint-praeparat\",\n        \"hint-microscope\",\n        \"hint-smartzoom\",\n        \"hint-histotrainer\",\n        \"hint-uafi\",\n        \"hint-merksprueche\",\n        \"hint-memes\",\n        \"hint-image\",\n        \"hint-amboss\",\n        \"hint-thieme\",\n        \"hint-meditricks\",\n        \"hint-linkcontainer\",\n      ];\n\n      const showExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document\n              .getElementById(buttonIds[button])\n              .style.removeProperty(\"display\");\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n      const hideExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document.getElementById(buttonIds[button]).style.display = \"none\";\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n\n      // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n      /**\n       * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n       */\n      const getCardNumber = function () {\n        clz = document.body.className;\n        const regex = /card(\\d+)/gm;\n\n        let clz2;\n        try {\n          clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n        } catch (e) {\n          clz2 = \"\";\n        }\n        const regex2 = /.*?Cloze(\\d+)/gm;\n\n        let m;\n\n        if ((m = regex2.exec(clz2)) !== null) {\n          return m[1];\n        } else if ((m = regex.exec(clz)) !== null) {\n          return m[1];\n        } else {\n          // Should only fire if card is not cloze\n          console.error(\"Cannot find cardN class of body element!\");\n          return \"0\";\n        }\n      }\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (!clozeOneByOneEnabled) {\n        showExtra()\n        showExtraButtons()\n        document.getElementById(\"onebyone-buttons\").style.display = \"none\"\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n        return\n      }\n\n      // Needed for amboss to recognize first word in .cloze-hidden\n      const CLOZE_REPLACER_SEP = \"<span class='hidden'> </span>\"\n\n      const hideAllCloze = function (initial) {\n        let clozes = document.getElementsByClassName(\"cloze\")\n        let count = 0 // hidden cloze count\n        for (const cloze of clozes) {\n          const existingHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n          if (existingHidden) {\n            revealCloze(cloze);\n          }\n          if (cloze.offsetWidth === 0) {\n            continue\n          }\n          const clozeReplacer = document.createElement(\"span\")\n          const clozeHidden = document.createElement(\"span\")\n          clozeReplacer.classList.add(\"cloze-replacer\")\n          clozeHidden.classList.add(\"cloze-hidden\")\n          while (cloze.childNodes.length > 0) {\n            clozeHidden.appendChild(cloze.childNodes[0])\n          }\n          cloze.appendChild(clozeReplacer)\n          cloze.appendChild(clozeHidden)\n\n          var clozeHints = Persistence.getItem(\"clozeHints\");\n          if (clozeHints && clozeHints[count]) {\n            clozeReplacer.classList.add(\"cloze-hint\")\n            clozeReplacer.innerHTML = clozeHints[count] + CLOZE_REPLACER_SEP\n          } else {\n            clozeReplacer.innerHTML = clozeHider(cloze) + CLOZE_REPLACER_SEP\n          }\n          count += 1\n          document.getElementById(\"button-reveal-next\").style.display = \"inline-block\";\n          if (initial) {\n            cloze.addEventListener(\"touchend\", revealClozeClicked)\n            cloze.addEventListener(\"click\", revealClozeClicked)\n            cloze.classList.add(\"one-by-one\");\n          }\n        }\n\n        // Hide #extra until all clozes are shown\n        const extra = document.getElementById(\"extra\");\n        if (extra) {\n          extra.classList.add(\"hidden\");\n        }\n\n        hideExtra();\n        hideExtraButtons();\n        if (revealAnywhere) {\n          document.documentElement.setAttribute(\"onclick\", \"revealNextCloze(); event.stopPropagation()\")\n        }\n\n\n        // Also hide autoReveal fields\n        for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n          const container = document.querySelector(`[data-name=\"${field}\"]`)\n          if (container) {\n            const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n            if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n              // const link = container.getElementsByTagName(\"a\")[0]\n              const button = container.getElementsByTagName(\"button\")[0]\n              const hint = container.getElementsByTagName(\"div\")[0]\n              button.classList.remove(\"expanded-button\")\n              hint.style.display = \"none\"\n              // link.style.display = \"\"\n            }\n          }\n        }\n      }\n\n      const revealCloze = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        cloze.removeChild(clozeReplacer)\n        cloze.removeChild(clozeHidden)\n        while (clozeHidden.childNodes.length > 0) {\n          cloze.appendChild(clozeHidden.childNodes[0])\n        }\n        maybeRevealExtraField()\n      }\n\n      const revealClozeWord = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        let range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundSpace = setRangeEnd(range, clozeHidden, \"beforeFirstSpace\")\n        if (!foundSpace) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        let fragment = range.extractContents()\n        cloze.insertBefore(fragment, clozeReplacer)\n        // Extract whitespaces after word\n        range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundWord = setRangeEnd(range, clozeHidden, \"beforeFirstChar\")\n        if (!foundWord) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        fragment = range.extractContents();\n        cloze.insertBefore(fragment, clozeReplacer)\n        if (!foundWord) {\n          cloze.removeChild(clozeHidden)\n          cloze.removeChild(clozeReplacer)\n          maybeRevealExtraField()\n          return\n        }\n        clozeReplacer.innerHTML = clozeHider(clozeHidden) + CLOZE_REPLACER_SEP\n        if (clozeReplacer.classList.contains(\"cloze-hint\")) [\n          clozeReplacer.classList.remove(\"cloze-hint\")\n        ]\n        maybeRevealExtraField()\n      }\n\n      const revealNextClozeOf = (type) => {\n        const nextHidden = document.querySelectorAll(\".cloze-hidden\")\n        const nextNextHidden = nextHidden.length > 1 ? true : false\n        if (!nextNextHidden) {\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\";\n        }\n        if (!nextHidden) {\n          return\n        }\n        const cloze = clozeElOfClozeHidden(nextHidden[0]);\n        if (type === \"word\") {\n          revealClozeWord(cloze)\n        } else if (type === \"cloze\") {\n          revealCloze(cloze)\n        } else {\n          console.error(\"Invalid type: \" + type)\n        }\n      }\n\n      const revealClozeClicked = function (ev) {\n        let elem = ev.currentTarget\n        if (!ev.altKey && (revealNextClozeMode !== \"word\")) {\n          revealCloze(elem)\n        } else {\n          revealClozeWord(elem)\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      }\n\n      window.revealNextCloze = function () {\n        revealNextClozeOf(revealNextClozeMode)\n      }\n\n      window.toggleAllCloze = function () {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length > 0) {\n          for (const elem of elems) {\n            const cloze = clozeElOfClozeHidden(elem)\n            revealCloze(cloze)\n          }\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\"\n        } else {\n          hideAllCloze(initial = false)\n        }\n      }\n\n      const clozeElOfClozeHidden = (cloze) => {\n        while (!cloze.classList.contains(\"cloze\")) {\n          cloze = cloze.parentElement;\n        }\n        return cloze;\n      }\n\n      const maybeRevealExtraField = () => {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length == 0) {\n          const extra = document.getElementById(\"extra\")\n          if (extra) {\n            extra.classList.remove(\"hidden\")\n          }\n\n          showExtra();\n          showExtraButtons();\n          document.documentElement.removeAttribute(\"onclick\")\n\n          // Also reveal autoReveal fields\n          for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n            const container = document.querySelector(`[data-name=\"${field}\"]`)\n            if (container) {\n              const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n              if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n                // const link = container.getElementsByTagName(\"a\")[0]\n                const button = container.getElementsByTagName(\"button\")[0]\n                const hint = container.getElementsByTagName(\"div\")[0]\n                button.classList.add(\"expanded-button\")\n                hint.style.display = \"block\"\n                // link.style.display = \"none\"\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * mode: 'beforeFirstSpace' or 'beforeFirstChar'\n       * Return `true` if it exists and setEnd() was called, otherwise `false`\n       */\n      const setRangeEnd = function (range, node, mode) {\n        if (node.nodeType === Node.TEXT_NODE) {\n          const regex = mode === 'beforeFirstSpace' ? /\\s/ : /\\S/\n          const match = node.textContent.match(regex)\n          if (match) {\n            if (match.index === 0) {\n              while (node.previousSibling === null) {\n                node = node.parentElement\n              }\n              range.setEndBefore(node)\n            } else {\n              range.setEnd(node, match.index);\n            }\n            return true;\n          } else {\n            return false;\n          }\n        } else if (mode === 'beforeFirstChar' && isCharNode(node)) {\n          range.setEndBefore(node)\n          return true\n        } else if (!ignoreSpaceInNode(node)) {\n          for (const child of node.childNodes) {\n            if (setRangeEnd(range, child, mode)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }\n\n      const ignoreSpaceInNode = function (node) {\n        return node.tagName === \"MJX-ASSISTIVE-MML\"\n      }\n\n      const isCharNode = function (node) {\n        return [\"IMG\", \"MJX-CONTAINER\"].includes(node.tagName)\n      }\n\n      hideAllCloze(initial = true)\n\n      let isShowNextShortcut = shortcutMatcher(window.revealNextShortcut)\n      let isShowWordShortcut = shortcutMatcher(window.revealNextWordShortcut)\n      let isToggleAllShortcut = shortcutMatcher(window.toggleAllShortcut)\n      ankingAddEventListener(\"keydown\", (ev) => {\n        let next = isShowNextShortcut(ev)\n        let word = isShowWordShortcut(ev)\n        let all = isToggleAllShortcut(ev)\n        if (next) {\n          revealNextClozeOf(\"cloze\")\n        } else if (word) {\n          revealNextClozeOf(\"word\")\n        } else if (all) {\n          toggleAllCloze()\n        } else {\n          return;\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      });\n    })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- MEDITRICKS SNIPPETS DATA -->\n<div id=\"meditricks-mtsp-values\" style=\"display:none;\">\n  <div id=\"meditricks-mtsp-nfname\">_meditricks_nf_v1000_ankizin</div>\n  <div id=\"meditricks-mtsp-nid\">{{Note ID}}</div>\n</div>\n<script src=\"_meditricks_mtsp_scripts_v1000_ankizin.js\"></script>\n<link href=\"_meditricks_mtsp_styles_v1000_ankizin.css\" rel=\"stylesheet\" />\n\n<!-- include \"_meditricks_mtsp_nf_v1000_ankizin.js\" -->\n<!-- include \"_meditricks_mtsp_scripts_v1000_iframe.map\" -->\n<!-- include \"_meditricks_mtsp_mtlogo.webp\" -->\n<!-- include \"_meditricks_mtsp_mt-loading.png\" -->\n<!-- include \"_meditricks_mtsp_mt-loading_night.png\" -->\n\n<!-- //MEDITRICKS SNIPPETS DATA -->\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>",
      "bqfmt": "{{Muskel / Leitungsbahn}}",
      "bafmt": "{{Ansatz}}",
      "bfont": "Helvetica",
      "bsize": 12
    },
    {
      "name": "VerlaufCloze1",
      "ord": 12,
      "qfmt": "<!-- version f0935e4 -->\n{{#Verlauf}}\n{{#VerlaufCloze1}}\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TIMER CONFIG  ##############\n  // Timer config (timer length, timer finished message)\n  var minutes = 0\n  var seconds = 15\n  var timeOverMsg = \"<span style='color:#CC5B5B'>!!!</span>\"\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  // Auto flip to back when One by one mode.\n  var autoflip = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Wie ist der <i>Verlauf</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" data-card=\"{{Card}}\"><br>{{Verlauf}}</div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\"></div>\n\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<script>\n  //DONT FADE BETWEEN CARDS\n  qFade = 0;\n  if (typeof anki !== 'undefined') anki.qFade = qFade;\n</script>\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    if (!indentation) { return; }\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- CLOZE ONE BY ONE FRONT -->\n<div id=\"one-by-one\" style=\"display: none;\"></div>\n\n<script>\n  /**\n   * Based on the AnKing Notetype, but expanded and modified by phyn.\n   * Credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  Persistence.clear();\n\n  // check if OneByOne is generally enabled for this card\n  var oneByOneFieldEmpty = selectiveOneByOne ? \"{{One by one}}\" === \"\" : true;\n  var clozeOneByOneEnabled = alwaysOneByOne ? true : !oneByOneFieldEmpty;\n\n  // avoid flickering. Must unset this in the back.\n  document.getElementById(\"qa\").style.display = \"none\";\n  var clozeHints = [];\n\n  if (clozeOneByOneEnabled) {\n    // collect hints from front side (independent of whether or not OneByOne is enabled)\n    document.getElementById(\"qa\").classList.add('one-by-one');\n    // Save cloze hints to display in the back\n    var clozes = document.getElementsByClassName(\"cloze\")\n    for (var i = 0; i < clozes.length; i++) {\n      clozes[i].classList.add(\"one-by-one\");\n      if (clozes[i].innerHTML === \"[...]\") {\n        clozeHints.push(\"\")\n      } else {\n        clozeHints.push(clozes[i].innerHTML)\n      }\n    }\n\n    // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n    /**\n     * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n     */\n    const getCardNumber = function () {\n      clz = document.body.className;\n      const regex = /card(\\d+)/gm;\n\n      let clz2;\n      try {\n        clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n      } catch (e) {\n        clz2 = \"\";\n      }\n      const regex2 = /.*?Cloze(\\d+)/gm;\n\n      let m;\n\n      if ((m = regex2.exec(clz2)) !== null) {\n        return m[1];\n      } else if ((m = regex.exec(clz)) !== null) {\n        return m[1];\n      } else {\n        // Should only fire if card is not cloze\n        console.error(\"Cannot find cardN class of body element!\");\n        return \"0\";\n      }\n    }\n\n    var alreadyRendered = false;\n\n    function processSelective1b1() {\n      if (alreadyRendered) return;\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (autoflip && clozeOneByOneEnabled) {\n        if (window.pycmd || window.showAnswer) {\n          // avoid flickering. Must unset this in the back.\n          document.getElementById(\"qa\").style.display = \"none\";\n        }\n        if (window.pycmd) {\n          pycmd(\"ans\")\n        } else if (window.showAnswer) {\n          showAnswer()\n        }\n      } else {\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n      }\n      // AnkiMobile JS API doesn't have one for show answer.\n      // Best alternative is to use Taps/Swipes to show answer.\n\n      alreadyRendered = true;\n    }\n\n    function delayedProcessSelective1b1() {\n      if (window.requestAnimationFrame) window.requestAnimationFrame(processSelective1b1); // less flickering\n      else window.setTimeout(processSelective1b1, 0);\n    };\n\n    window.onload = delayedProcessSelective1b1;\n    if (document.readyState === \"complete\") {\n      delayedProcessSelective1b1();\n    }\n    else {\n      document.addEventListener(\"DOMContentLoaded\", delayedProcessSelective1b1);\n    }\n\n    // Observe document.body class changes to trigger re-rendering.\n    // This is useful, because Anki doesn’t always start with an up-to-date class list:\n    // https://forums.ankiweb.net/t/card-card-classes-only-injected-separately-now/27387.\n    const observer = new MutationObserver(function (mutationsList, observer) {\n      for (let mutation of mutationsList) {\n        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {\n          delayedProcessSelective1b1();\n        }\n      }\n    });\n    observer.observe(document.body, { attributes: true });\n  }\n  Persistence.setItem(\"clozeHints\", clozeHints);\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>\n\n\n{{/VerlaufCloze1}}\n{{/Verlauf}}",
      "afmt": "<!-- version f0935e4 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n<div id=\"back\"></div>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Eigene Notizen & Bilder\": \"Alt + 1\",\n    \"Eigene Prüfungsfragen\": \"Alt + 2\",\n    \"Definitionen\": \"Alt + 3\",\n    \"Merksprüche\": \"Alt + 4\",\n    \"Klinik\": \"Alt + 5\",\n    \"Präparat\": \"Alt + 6\",\n    \"Memes\": \"Alt + 7\",\n    \"linkContainer\": \"Alt + L\",\n    \"Meditricks\": \"Alt + M\",\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Eigene Notizen & Bilder\": false,\n    \"Eigene Prüfungsfragen\": false,\n    \"Definitionen\": false,\n    \"Merksprüche\": false,\n    \"Klinik\": false,\n    \"Präparat\": false,\n    \"Memes\": false,\n    \"linkContainer\": true,\n    \"Meditricks\": false,\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  var revealNextShortcut = \"N\"\n  var revealNextWordShortcut = \"Shift + N\"\n  var toggleAllShortcut = \",\"\n\n  // Enables revealing of next Cloze by simply clicking / tapping anywhere on the card (except the buttons)\n  var revealAnywhere = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // Changes how \"Reveal Next\" and clicking behaves. Either \"cloze\" or \"word\".\n  // \"word\" reveals word by word. \n  var revealNextClozeMode = \"cloze\"\n\n  // Changes how fields with additional information are displayed.\n  // true displays fields with additional information only if all clozes are revealed.\n  var hideAdditional = true;\n  var hideAdditionalButtons = true;\n\n  // What cloze is hidden with\n  var clozeHider = (elem) => \"[&nbsp;_&nbsp;]\"\n  /*\n  You can replace the above line with below examples. '█' or '_' works well for hiding clozes.\n  \n  // Fixed length:\n  var clozeHider = (elem) => \"███\"\n  // Replace each character with \"█\":\n  var clozeHider = (elem) => \"█\".repeat(elem.textContent.length)\n  // Show whitespaces:\n  var clozeHider = (elem) => \"[\" + elem.textContent.split(\" \").map((t) => \"█\".repeat(t.length)).join(\" \") + \"]\"\n  // Color-filled box (doesn't hide images):\n  var clozeHider = (elem) => `<span style=\"background-color: red; color: transparent;\">${elem.innerHTML}</span>`\n  */\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Wie ist der <i>Verlauf</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" class=\"clozefield\" data-card=\"{{Card}}\"><br>{{Verlauf}}</div>\n\n    <!-- ClOZE ONE BY ONE BUTTONS -->\n    <div id=\"onebyone-buttons\" class=\"onebyone\">\n      <br>\n      <button id=\"button-reveal-next\" class=\"button-general button-one-by-one\"\n        onclick=\"revealNextCloze(); event.stopPropagation()\">Reveal Next</button>\n      <button id=\"button-toggle-all\" class=\"button-general button-one-by-one\"\n        onclick=\"toggleAllCloze(); event.stopPropagation()\">Toggle All</button>\n    </div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- BUTTON FIELDS -->\n    {{#Eigene Notizen & Bilder}}\n    <span id=\"hint-zusatz\" class=\"hintBtn\" data-name=\"Eigene Notizen & Bilder\" style=\"display: none;\">\n      <button id=\"button-zusatz\" class=\"button-general\" onclick=\"toggleHintBtn('hint-zusatz'); event.stopPropagation()\">\n        <img src=\"__zusatz.svg\" style=\"height: 10px;\"> Eigene Notizen & Bilder\n      </button>\n      <div dir=\"auto\" id=\"zusatz\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Notizen & Bilder}}</div>\n    </span>\n    {{/Eigene Notizen & Bilder}}\n\n    {{#Eigene Prüfungsfragen}}\n    <span id=\"hint-hammer\" class=\"hintBtn\" data-name=\"Eigene Prüfungsfragen\" style=\"display: none;\">\n      <button id=\"button-hammer\" class=\"button-general\" onclick=\"toggleHintBtn('hint-hammer'); event.stopPropagation()\">\n        <img src=\"__hammer.svg\" style=\"height: 10px;\"> Eigene Prüfungsfragen\n      </button>\n      <div dir=\"auto\" id=\"hammer\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Prüfungsfragen}}</div>\n    </span>\n    {{/Eigene Prüfungsfragen}}\n\n    {{#Definitionen}}\n    <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Definitionen\" style=\"display: none;\">\n      <button id=\"button-definition\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Definitionen\n      </button>\n      <div dir=\"auto\" id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Definitionen}}</div>\n    </span>\n    {{/Definitionen}}\n\n    {{#Merksprüche}}\n    <span id=\"hint-merksprueche\" class=\"hintBtn\" data-name=\"Merksprüche\" style=\"display: none;\">\n      <button id=\"button-merksprueche\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-merksprueche'); event.stopPropagation()\">\n        <img src=\"__merkhilfe.svg\" style=\"height: 10px;\"> Merksprüche\n      </button>\n      <div dir=\"auto\" id=\"merksprueche\" class=\"hints\" style=\"display: none;\">{{edit:Merksprüche}}</div>\n    </span>\n    {{/Merksprüche}}\n\n    {{#Klinik}}\n    <span id=\"hint-klinik\" class=\"hintBtn\" data-name=\"Klinik\" style=\"display: none;\">\n      <button id=\"button-klinik\" class=\"button-general\" onclick=\"toggleHintBtn('hint-klinik'); event.stopPropagation()\">\n        <img src=\"__stethoscope.svg\" style=\"height: 10px;\"> Klinik\n      </button>\n      <div dir=\"auto\" id=\"klinik\" class=\"hints\" style=\"display: none;\">{{edit:Klinik}}</div>\n    </span>\n    {{/Klinik}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-praeparat\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n        </button>\n      </a>\n    </span>\n    {{/Präparat}}\n\n    {{#Virtuelle Mikroskopie}}\n    <span id=\"hint-microscope-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Virtuelle Mikroskopie}}\">\n        <button id=\"button-microscope\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Virtuelle Mikroskopie\n        </button>\n      </a>\n    </span>\n    {{/Virtuelle Mikroskopie}}\n\n    {{#Smart Zoom}}\n    <span id=\"hint-smartzoom-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-smartzoom\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Smart Zoom\n        </button>\n      </a>\n    </span>\n    {{/Smart Zoom}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat\" class=\"hintBtn\" data-name=\"Präparat\" style=\"display: none;\">\n      <button id=\"button-praeparat\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-praeparat'); event.stopPropagation()\">\n        <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n      </button>\n      <div dir=\"auto\" id=\"praeparat\" class=\"hints\" style=\"display: none;\">{{edit:Präparat}}</div>\n    </span>\n    {{/Präparat}}\n\n    {{#Memes}}\n    <span id=\"hint-memes\" class=\"hintBtn\" data-name=\"Memes\" style=\"display: none;\">\n      <button id=\"button-memes\" class=\"button-general\" onclick=\"toggleHintBtn('hint-memes'); event.stopPropagation()\">\n        <img src=\"__sonstiges.svg\" style=\"height: 10px;\"> Memes\n      </button>\n      <div dir=\"auto\" id=\"memes\" class=\"hints\" style=\"display: none;\">{{edit:Memes}}</div>\n    </span>\n    {{/Memes}}\n\n    <!-- LINEBREAKS IF BUTTONS EXIST -->\n    <script>\n      var array = [`{{Eigene Notizen & Bilder}}`, `{{Eigene Prüfungsfragen}}`, `{{Definitionen}}`, `{{Merksprüche}}`, `{{Klinik}}`, `{{Präparat}}`, `{{Memes}}`];\n      var anyistrue = (element) => element;\n      if (array.some(anyistrue)) {\n        document.getElementById(\"linebreaksIfButtons\").innerHTML = \"<br>\";\n      }\n    </script>\n    <div id=\"linebreaksIfButtons\"></div>\n\n    <!-- Extra field -->\n    {{#Extra}}\n    <div id=\"extra\" style=\"display: none;\">\n      <br>{{edit:Extra}}<br><br>\n    </div>\n    {{/Extra}}\n\n    <!-- Image field -->\n    {{#Bild}}\n    <div id=\"image\" style=\"display: none;\">\n      {{edit:Bild}}<br><br></div>\n    {{/Bild}}\n    {{^Bild}}\n    <span id=\"image\" style=\"display: none;\"></span>\n    {{/Bild}}\n    {{#Bild}}\n    <span id=\"hint-image\" style=\"display: none;\">\n      <button id=\"button-image\" class=\"button-general\"\n        onclick=\"var image = document.getElementById('image'); if (image.style.display == 'none') { image.style.display = 'block' } else { image.style.display = 'none' }; event.stopPropagation()\">\n        <img src=\"__image.svg\" style=\"height: 10px;\"> Abbildung\n      </button>\n    </span>\n    {{/Bild}}\n\n    <span id=\"hint-uafi\" class=\"hintBtn\" data-name=\"Ursprung, Ansatz, Verlauf, Funktion, Innervation, Äste\"\n      style=\"display: none;\">\n      <button id=\"button-uafi\" class=\"button-general expanded-button\"\n        onclick=\"toggleHintBtn('hint-uafi'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Weitere Informationen\n      </button>\n      <div id=\"uafi\" class=\"hints\" style=\"display: block;\">\n        <table class=\"uncloze\">\n          {{#Ursprung}}\n          <tr class=\"uafi-element\" id=\"Ursprung\">\n            <td><i>Ursprung</i></td>\n            <td>{{Ursprung}}</td>\n          </tr>\n          {{/Ursprung}}\n          {{#Ansatz}}\n          <tr class=\"uafi-element\" id=\"Ansatz\">\n            <td><i>Ansatz</i></td>\n            <td>{{Ansatz}}</td>\n          </tr>\n          {{/Ansatz}}\n          {{#Verlauf}}\n          <tr class=\"uafi-element\" id=\"Verlauf\">\n            <td><i>Verlauf</i></td>\n            <td>{{Verlauf}}</td>\n          </tr>\n          {{/Verlauf}}\n          {{#Funktion}}\n          <tr class=\"uafi-element\" id=\"Funktion\">\n            <td><i>Funktion</i></td>\n            <td>{{Funktion}}</td>\n          </tr>\n          {{/Funktion}}\n          {{#Innervation}}\n          <tr class=\"uafi-element\" id=\"Innervation\">\n            <td><i>Innervation</i></td>\n            <td>{{Innervation}}</td>\n          </tr>\n          {{/Innervation}}\n          {{#Äste}}\n          <tr class=\"uafi-element\" id=\"Äste\">\n            <td><i>Äste</i></td>\n            <td>{{Äste}}</td>\n          </tr>\n          {{/Äste}}\n        </table>\n      </div>\n\n      <script>\n        // iterate over all uafi-elements and hide only the one\n        // that is equal to the card's answer (i.e., value of {{Card}})\n        var uafiElements = document.getElementsByClassName(\"uafi-element\");\n        for (var i = 0; i < uafiElements.length; i++) {\n          if (((\"{{Card}}\").startsWith(uafiElements[i].id))) {\n            uafiElements[i].remove()\n          }\n        }\n      </script>\n    </span>\n\n    {{#AMBOSS-Link}}\n    <span id=\"hint-amboss\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:AMBOSS-Link}}\">\n        <button id=\"button-amboss\" class=\"button-general\">\n          <img src=\"__amboss.svg\" style=\"height: 10px;\"> AMBOSS&#8203;\n        </button>\n      </a>\n    </span>\n    {{/AMBOSS-Link}}\n\n    {{#Thieme via medici-Link}}\n    <span id=\"hint-thieme\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Thieme via medici-Link}}\">\n        <button id=\"button-thieme\" class=\"button-general\">\n          <img id=\"button-thieme-img\" src=\"__thieme-heart.svg\" style=\"height: 10px;\"> Thieme via medici\n        </button>\n      </a>\n    </span>\n    {{/Thieme via medici-Link}}\n\n    {{#Meditricks}}\n    <span id=\"hint-meditricks\" class=\"hintBtn\" data-name=\"Meditricks\" style=\"display: none;\">\n      <button id=\"button-meditricks\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-meditricks'); event.stopPropagation()\">\n        <img src=\"__meditricks.svg\" style=\"height: 10px;\"> Meditricks\n      </button>\n      <div dir=\"auto\" id=\"meditricks\" class=\"hints\" style=\"display: none;\">{{edit:Meditricks}}</div>\n    </span>\n    {{/Meditricks}}\n\n    {{#weitere Links}}\n    <span id=\"hint-linkcontainer\" class=\"hintBtn\" data-name=\"linkContainer\" style=\"display: none;\">\n      <button id=\"button-linkcontainer\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-linkcontainer'); event.stopPropagation()\">\n        <img src=\"__internet.svg\" style=\"height: 10px;\"> weitere Links\n      </button>\n      <div id=\"linkcontainer\" class=\"hints\" style=\"display: none;\"></div>\n      <span id=\"linkContainerLinks\" style=\"display: none;\">{{edit:weitere Links}}</span>\n    </span>\n    {{/weitere Links}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n  try {\n    for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n      href = link.href\n      text = link.innerText\n\n      const el = document.createElement('a');\n      el.setAttribute('href', link.href);\n\n      const btn = document.createElement('button');\n      btn.classList.add('button-general');\n      btn.classList.add('expanded-button');\n\n      domain = href.replace(/.+\\/\\/|(www|flexikon|register|de|next|com).|\\..+/g, '');\n      domainDict = {\n        \"amboss\": \"__amboss.svg\",\n        \"wikipedia\": \"__wikipedia.svg\",\n        \"doccheck\": \"__doccheck.png\",\n        \"notfallguru\": \"__notfallguru.svg\",\n        \"awmf\": \"__awmf.svg\",\n        \"gelbe-liste\": \"__gelbe-liste.png\",\n        \"embryotox\": \"__embryotox.svg\",\n        \"radiopaedia\": \"__radiopaedia.png\",\n        \"orphanet\": \"__orphanet.png\",\n      }\n      if (domain in domainDict) {\n        icon = domainDict[domain]\n      } else {\n        icon = \"__internet.svg\"\n      }\n\n      const img = document.createElement('img');\n      img.setAttribute('src', icon);\n      img.setAttribute('style', 'height: 10px;');\n\n      btn.appendChild(img);\n      btn.innerHTML = btn.innerHTML + \" \" + text;\n\n      el.appendChild(btn);\n\n      document.getElementById(\"linkcontainer\").appendChild(el)\n    }\n  }\n  catch (err) {\n    console.log(err)\n  }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-uafi\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- AUTOFLIP BACK SCRIPT -->\n<script>\n  // autoflip hides card in front template\n  document.getElementById(\"qa\").style.removeProperty(\"display\")\n</script>\n\n<!-- CLOZE ONE BY ONE SCRIPT -->\n<style>\n  .cloze-replacer:hover {\n    cursor: pointer;\n  }\n\n  .cloze-hidden {\n    display: none;\n  }\n\n  .cloze-replacer .hidden {\n    display: none;\n  }\n\n  #extra.hidden {\n    display: none;\n  }\n</style>\n\n<!--\n Based on the AnKing Notetype, but expanded and modified by phyn.\n Credit to the original authors, except where modified or otherwise indicated.\n-->\n\n<script>\n    (function () {\n      // enables cloze one-by-one even when one-by-one field is empty\n      // minNumberOfClozes is still considered in this case\n      // overridden in importance by selectiveOneByOne\n      var clozeOneByOneEnabled = true;\n\n      // remove the clickAnywhere function from global scope\n      document.documentElement.removeAttribute(\"onclick\")\n\n      // --- CHECK IF ONE BY ONE IS GENERALLY ENABLED FOR THIS NOTE ---\n      var oneByOneFieldNotEmpty = \"{{One by one}}\" !== \"\";\n      try {\n        clozeOneByOneEnabled = alwaysOneByOne || oneByOneFieldNotEmpty;\n      } catch (exception) {\n        console.log(exception)\n      }\n\n      /**\n   * helper functions to show / hide fields containing additional information\n   */\n      const showExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const hideExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const buttonIds = [\n        \"hint-zusatz\",\n        \"hint-definition\",\n        \"hint-hammer\",\n        \"hint-klinik\",\n        \"hint-praeparat\",\n        \"hint-microscope\",\n        \"hint-smartzoom\",\n        \"hint-histotrainer\",\n        \"hint-uafi\",\n        \"hint-merksprueche\",\n        \"hint-memes\",\n        \"hint-image\",\n        \"hint-amboss\",\n        \"hint-thieme\",\n        \"hint-meditricks\",\n        \"hint-linkcontainer\",\n      ];\n\n      const showExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document\n              .getElementById(buttonIds[button])\n              .style.removeProperty(\"display\");\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n      const hideExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document.getElementById(buttonIds[button]).style.display = \"none\";\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n\n      // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n      /**\n       * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n       */\n      const getCardNumber = function () {\n        clz = document.body.className;\n        const regex = /card(\\d+)/gm;\n\n        let clz2;\n        try {\n          clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n        } catch (e) {\n          clz2 = \"\";\n        }\n        const regex2 = /.*?Cloze(\\d+)/gm;\n\n        let m;\n\n        if ((m = regex2.exec(clz2)) !== null) {\n          return m[1];\n        } else if ((m = regex.exec(clz)) !== null) {\n          return m[1];\n        } else {\n          // Should only fire if card is not cloze\n          console.error(\"Cannot find cardN class of body element!\");\n          return \"0\";\n        }\n      }\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (!clozeOneByOneEnabled) {\n        showExtra()\n        showExtraButtons()\n        document.getElementById(\"onebyone-buttons\").style.display = \"none\"\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n        return\n      }\n\n      // Needed for amboss to recognize first word in .cloze-hidden\n      const CLOZE_REPLACER_SEP = \"<span class='hidden'> </span>\"\n\n      const hideAllCloze = function (initial) {\n        let clozes = document.getElementsByClassName(\"cloze\")\n        let count = 0 // hidden cloze count\n        for (const cloze of clozes) {\n          const existingHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n          if (existingHidden) {\n            revealCloze(cloze);\n          }\n          if (cloze.offsetWidth === 0) {\n            continue\n          }\n          const clozeReplacer = document.createElement(\"span\")\n          const clozeHidden = document.createElement(\"span\")\n          clozeReplacer.classList.add(\"cloze-replacer\")\n          clozeHidden.classList.add(\"cloze-hidden\")\n          while (cloze.childNodes.length > 0) {\n            clozeHidden.appendChild(cloze.childNodes[0])\n          }\n          cloze.appendChild(clozeReplacer)\n          cloze.appendChild(clozeHidden)\n\n          var clozeHints = Persistence.getItem(\"clozeHints\");\n          if (clozeHints && clozeHints[count]) {\n            clozeReplacer.classList.add(\"cloze-hint\")\n            clozeReplacer.innerHTML = clozeHints[count] + CLOZE_REPLACER_SEP\n          } else {\n            clozeReplacer.innerHTML = clozeHider(cloze) + CLOZE_REPLACER_SEP\n          }\n          count += 1\n          document.getElementById(\"button-reveal-next\").style.display = \"inline-block\";\n          if (initial) {\n            cloze.addEventListener(\"touchend\", revealClozeClicked)\n            cloze.addEventListener(\"click\", revealClozeClicked)\n            cloze.classList.add(\"one-by-one\");\n          }\n        }\n\n        // Hide #extra until all clozes are shown\n        const extra = document.getElementById(\"extra\");\n        if (extra) {\n          extra.classList.add(\"hidden\");\n        }\n\n        hideExtra();\n        hideExtraButtons();\n        if (revealAnywhere) {\n          document.documentElement.setAttribute(\"onclick\", \"revealNextCloze(); event.stopPropagation()\")\n        }\n\n\n        // Also hide autoReveal fields\n        for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n          const container = document.querySelector(`[data-name=\"${field}\"]`)\n          if (container) {\n            const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n            if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n              // const link = container.getElementsByTagName(\"a\")[0]\n              const button = container.getElementsByTagName(\"button\")[0]\n              const hint = container.getElementsByTagName(\"div\")[0]\n              button.classList.remove(\"expanded-button\")\n              hint.style.display = \"none\"\n              // link.style.display = \"\"\n            }\n          }\n        }\n      }\n\n      const revealCloze = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        cloze.removeChild(clozeReplacer)\n        cloze.removeChild(clozeHidden)\n        while (clozeHidden.childNodes.length > 0) {\n          cloze.appendChild(clozeHidden.childNodes[0])\n        }\n        maybeRevealExtraField()\n      }\n\n      const revealClozeWord = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        let range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundSpace = setRangeEnd(range, clozeHidden, \"beforeFirstSpace\")\n        if (!foundSpace) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        let fragment = range.extractContents()\n        cloze.insertBefore(fragment, clozeReplacer)\n        // Extract whitespaces after word\n        range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundWord = setRangeEnd(range, clozeHidden, \"beforeFirstChar\")\n        if (!foundWord) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        fragment = range.extractContents();\n        cloze.insertBefore(fragment, clozeReplacer)\n        if (!foundWord) {\n          cloze.removeChild(clozeHidden)\n          cloze.removeChild(clozeReplacer)\n          maybeRevealExtraField()\n          return\n        }\n        clozeReplacer.innerHTML = clozeHider(clozeHidden) + CLOZE_REPLACER_SEP\n        if (clozeReplacer.classList.contains(\"cloze-hint\")) [\n          clozeReplacer.classList.remove(\"cloze-hint\")\n        ]\n        maybeRevealExtraField()\n      }\n\n      const revealNextClozeOf = (type) => {\n        const nextHidden = document.querySelectorAll(\".cloze-hidden\")\n        const nextNextHidden = nextHidden.length > 1 ? true : false\n        if (!nextNextHidden) {\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\";\n        }\n        if (!nextHidden) {\n          return\n        }\n        const cloze = clozeElOfClozeHidden(nextHidden[0]);\n        if (type === \"word\") {\n          revealClozeWord(cloze)\n        } else if (type === \"cloze\") {\n          revealCloze(cloze)\n        } else {\n          console.error(\"Invalid type: \" + type)\n        }\n      }\n\n      const revealClozeClicked = function (ev) {\n        let elem = ev.currentTarget\n        if (!ev.altKey && (revealNextClozeMode !== \"word\")) {\n          revealCloze(elem)\n        } else {\n          revealClozeWord(elem)\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      }\n\n      window.revealNextCloze = function () {\n        revealNextClozeOf(revealNextClozeMode)\n      }\n\n      window.toggleAllCloze = function () {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length > 0) {\n          for (const elem of elems) {\n            const cloze = clozeElOfClozeHidden(elem)\n            revealCloze(cloze)\n          }\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\"\n        } else {\n          hideAllCloze(initial = false)\n        }\n      }\n\n      const clozeElOfClozeHidden = (cloze) => {\n        while (!cloze.classList.contains(\"cloze\")) {\n          cloze = cloze.parentElement;\n        }\n        return cloze;\n      }\n\n      const maybeRevealExtraField = () => {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length == 0) {\n          const extra = document.getElementById(\"extra\")\n          if (extra) {\n            extra.classList.remove(\"hidden\")\n          }\n\n          showExtra();\n          showExtraButtons();\n          document.documentElement.removeAttribute(\"onclick\")\n\n          // Also reveal autoReveal fields\n          for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n            const container = document.querySelector(`[data-name=\"${field}\"]`)\n            if (container) {\n              const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n              if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n                // const link = container.getElementsByTagName(\"a\")[0]\n                const button = container.getElementsByTagName(\"button\")[0]\n                const hint = container.getElementsByTagName(\"div\")[0]\n                button.classList.add(\"expanded-button\")\n                hint.style.display = \"block\"\n                // link.style.display = \"none\"\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * mode: 'beforeFirstSpace' or 'beforeFirstChar'\n       * Return `true` if it exists and setEnd() was called, otherwise `false`\n       */\n      const setRangeEnd = function (range, node, mode) {\n        if (node.nodeType === Node.TEXT_NODE) {\n          const regex = mode === 'beforeFirstSpace' ? /\\s/ : /\\S/\n          const match = node.textContent.match(regex)\n          if (match) {\n            if (match.index === 0) {\n              while (node.previousSibling === null) {\n                node = node.parentElement\n              }\n              range.setEndBefore(node)\n            } else {\n              range.setEnd(node, match.index);\n            }\n            return true;\n          } else {\n            return false;\n          }\n        } else if (mode === 'beforeFirstChar' && isCharNode(node)) {\n          range.setEndBefore(node)\n          return true\n        } else if (!ignoreSpaceInNode(node)) {\n          for (const child of node.childNodes) {\n            if (setRangeEnd(range, child, mode)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }\n\n      const ignoreSpaceInNode = function (node) {\n        return node.tagName === \"MJX-ASSISTIVE-MML\"\n      }\n\n      const isCharNode = function (node) {\n        return [\"IMG\", \"MJX-CONTAINER\"].includes(node.tagName)\n      }\n\n      hideAllCloze(initial = true)\n\n      let isShowNextShortcut = shortcutMatcher(window.revealNextShortcut)\n      let isShowWordShortcut = shortcutMatcher(window.revealNextWordShortcut)\n      let isToggleAllShortcut = shortcutMatcher(window.toggleAllShortcut)\n      ankingAddEventListener(\"keydown\", (ev) => {\n        let next = isShowNextShortcut(ev)\n        let word = isShowWordShortcut(ev)\n        let all = isToggleAllShortcut(ev)\n        if (next) {\n          revealNextClozeOf(\"cloze\")\n        } else if (word) {\n          revealNextClozeOf(\"word\")\n        } else if (all) {\n          toggleAllCloze()\n        } else {\n          return;\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      });\n    })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- MEDITRICKS SNIPPETS DATA -->\n<div id=\"meditricks-mtsp-values\" style=\"display:none;\">\n  <div id=\"meditricks-mtsp-nfname\">_meditricks_nf_v1000_ankizin</div>\n  <div id=\"meditricks-mtsp-nid\">{{Note ID}}</div>\n</div>\n<script src=\"_meditricks_mtsp_scripts_v1000_ankizin.js\"></script>\n<link href=\"_meditricks_mtsp_styles_v1000_ankizin.css\" rel=\"stylesheet\" />\n\n<!-- include \"_meditricks_mtsp_nf_v1000_ankizin.js\" -->\n<!-- include \"_meditricks_mtsp_scripts_v1000_iframe.map\" -->\n<!-- include \"_meditricks_mtsp_mtlogo.webp\" -->\n<!-- include \"_meditricks_mtsp_mt-loading.png\" -->\n<!-- include \"_meditricks_mtsp_mt-loading_night.png\" -->\n\n<!-- //MEDITRICKS SNIPPETS DATA -->\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>",
      "bqfmt": "{{Muskel / Leitungsbahn}}",
      "bafmt": "{{Verlauf}}",
      "bfont": "Helvetica",
      "bsize": 12
    },
    {
      "name": "VerlaufCloze2",
      "ord": 13,
      "qfmt": "<!-- version f0935e4 -->\n{{#Verlauf}}\n{{#VerlaufCloze2}}\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TIMER CONFIG  ##############\n  // Timer config (timer length, timer finished message)\n  var minutes = 0\n  var seconds = 15\n  var timeOverMsg = \"<span style='color:#CC5B5B'>!!!</span>\"\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  // Auto flip to back when One by one mode.\n  var autoflip = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Wie ist der <i>Verlauf</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" data-card=\"{{Card}}\"><br>{{Verlauf}}</div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\"></div>\n\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<script>\n  //DONT FADE BETWEEN CARDS\n  qFade = 0;\n  if (typeof anki !== 'undefined') anki.qFade = qFade;\n</script>\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    if (!indentation) { return; }\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- CLOZE ONE BY ONE FRONT -->\n<div id=\"one-by-one\" style=\"display: none;\"></div>\n\n<script>\n  /**\n   * Based on the AnKing Notetype, but expanded and modified by phyn.\n   * Credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  Persistence.clear();\n\n  // check if OneByOne is generally enabled for this card\n  var oneByOneFieldEmpty = selectiveOneByOne ? \"{{One by one}}\" === \"\" : true;\n  var clozeOneByOneEnabled = alwaysOneByOne ? true : !oneByOneFieldEmpty;\n\n  // avoid flickering. Must unset this in the back.\n  document.getElementById(\"qa\").style.display = \"none\";\n  var clozeHints = [];\n\n  if (clozeOneByOneEnabled) {\n    // collect hints from front side (independent of whether or not OneByOne is enabled)\n    document.getElementById(\"qa\").classList.add('one-by-one');\n    // Save cloze hints to display in the back\n    var clozes = document.getElementsByClassName(\"cloze\")\n    for (var i = 0; i < clozes.length; i++) {\n      clozes[i].classList.add(\"one-by-one\");\n      if (clozes[i].innerHTML === \"[...]\") {\n        clozeHints.push(\"\")\n      } else {\n        clozeHints.push(clozes[i].innerHTML)\n      }\n    }\n\n    // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n    /**\n     * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n     */\n    const getCardNumber = function () {\n      clz = document.body.className;\n      const regex = /card(\\d+)/gm;\n\n      let clz2;\n      try {\n        clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n      } catch (e) {\n        clz2 = \"\";\n      }\n      const regex2 = /.*?Cloze(\\d+)/gm;\n\n      let m;\n\n      if ((m = regex2.exec(clz2)) !== null) {\n        return m[1];\n      } else if ((m = regex.exec(clz)) !== null) {\n        return m[1];\n      } else {\n        // Should only fire if card is not cloze\n        console.error(\"Cannot find cardN class of body element!\");\n        return \"0\";\n      }\n    }\n\n    var alreadyRendered = false;\n\n    function processSelective1b1() {\n      if (alreadyRendered) return;\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (autoflip && clozeOneByOneEnabled) {\n        if (window.pycmd || window.showAnswer) {\n          // avoid flickering. Must unset this in the back.\n          document.getElementById(\"qa\").style.display = \"none\";\n        }\n        if (window.pycmd) {\n          pycmd(\"ans\")\n        } else if (window.showAnswer) {\n          showAnswer()\n        }\n      } else {\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n      }\n      // AnkiMobile JS API doesn't have one for show answer.\n      // Best alternative is to use Taps/Swipes to show answer.\n\n      alreadyRendered = true;\n    }\n\n    function delayedProcessSelective1b1() {\n      if (window.requestAnimationFrame) window.requestAnimationFrame(processSelective1b1); // less flickering\n      else window.setTimeout(processSelective1b1, 0);\n    };\n\n    window.onload = delayedProcessSelective1b1;\n    if (document.readyState === \"complete\") {\n      delayedProcessSelective1b1();\n    }\n    else {\n      document.addEventListener(\"DOMContentLoaded\", delayedProcessSelective1b1);\n    }\n\n    // Observe document.body class changes to trigger re-rendering.\n    // This is useful, because Anki doesn’t always start with an up-to-date class list:\n    // https://forums.ankiweb.net/t/card-card-classes-only-injected-separately-now/27387.\n    const observer = new MutationObserver(function (mutationsList, observer) {\n      for (let mutation of mutationsList) {\n        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {\n          delayedProcessSelective1b1();\n        }\n      }\n    });\n    observer.observe(document.body, { attributes: true });\n  }\n  Persistence.setItem(\"clozeHints\", clozeHints);\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>\n\n\n{{/VerlaufCloze2}}\n{{/Verlauf}}",
      "afmt": "<!-- version f0935e4 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n<div id=\"back\"></div>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Eigene Notizen & Bilder\": \"Alt + 1\",\n    \"Eigene Prüfungsfragen\": \"Alt + 2\",\n    \"Definitionen\": \"Alt + 3\",\n    \"Merksprüche\": \"Alt + 4\",\n    \"Klinik\": \"Alt + 5\",\n    \"Präparat\": \"Alt + 6\",\n    \"Memes\": \"Alt + 7\",\n    \"linkContainer\": \"Alt + L\",\n    \"Meditricks\": \"Alt + M\",\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Eigene Notizen & Bilder\": false,\n    \"Eigene Prüfungsfragen\": false,\n    \"Definitionen\": false,\n    \"Merksprüche\": false,\n    \"Klinik\": false,\n    \"Präparat\": false,\n    \"Memes\": false,\n    \"linkContainer\": true,\n    \"Meditricks\": false,\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  var revealNextShortcut = \"N\"\n  var revealNextWordShortcut = \"Shift + N\"\n  var toggleAllShortcut = \",\"\n\n  // Enables revealing of next Cloze by simply clicking / tapping anywhere on the card (except the buttons)\n  var revealAnywhere = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // Changes how \"Reveal Next\" and clicking behaves. Either \"cloze\" or \"word\".\n  // \"word\" reveals word by word. \n  var revealNextClozeMode = \"cloze\"\n\n  // Changes how fields with additional information are displayed.\n  // true displays fields with additional information only if all clozes are revealed.\n  var hideAdditional = true;\n  var hideAdditionalButtons = true;\n\n  // What cloze is hidden with\n  var clozeHider = (elem) => \"[&nbsp;_&nbsp;]\"\n  /*\n  You can replace the above line with below examples. '█' or '_' works well for hiding clozes.\n  \n  // Fixed length:\n  var clozeHider = (elem) => \"███\"\n  // Replace each character with \"█\":\n  var clozeHider = (elem) => \"█\".repeat(elem.textContent.length)\n  // Show whitespaces:\n  var clozeHider = (elem) => \"[\" + elem.textContent.split(\" \").map((t) => \"█\".repeat(t.length)).join(\" \") + \"]\"\n  // Color-filled box (doesn't hide images):\n  var clozeHider = (elem) => `<span style=\"background-color: red; color: transparent;\">${elem.innerHTML}</span>`\n  */\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Wie ist der <i>Verlauf</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" class=\"clozefield\" data-card=\"{{Card}}\"><br>{{Verlauf}}</div>\n\n    <!-- ClOZE ONE BY ONE BUTTONS -->\n    <div id=\"onebyone-buttons\" class=\"onebyone\">\n      <br>\n      <button id=\"button-reveal-next\" class=\"button-general button-one-by-one\"\n        onclick=\"revealNextCloze(); event.stopPropagation()\">Reveal Next</button>\n      <button id=\"button-toggle-all\" class=\"button-general button-one-by-one\"\n        onclick=\"toggleAllCloze(); event.stopPropagation()\">Toggle All</button>\n    </div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- BUTTON FIELDS -->\n    {{#Eigene Notizen & Bilder}}\n    <span id=\"hint-zusatz\" class=\"hintBtn\" data-name=\"Eigene Notizen & Bilder\" style=\"display: none;\">\n      <button id=\"button-zusatz\" class=\"button-general\" onclick=\"toggleHintBtn('hint-zusatz'); event.stopPropagation()\">\n        <img src=\"__zusatz.svg\" style=\"height: 10px;\"> Eigene Notizen & Bilder\n      </button>\n      <div dir=\"auto\" id=\"zusatz\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Notizen & Bilder}}</div>\n    </span>\n    {{/Eigene Notizen & Bilder}}\n\n    {{#Eigene Prüfungsfragen}}\n    <span id=\"hint-hammer\" class=\"hintBtn\" data-name=\"Eigene Prüfungsfragen\" style=\"display: none;\">\n      <button id=\"button-hammer\" class=\"button-general\" onclick=\"toggleHintBtn('hint-hammer'); event.stopPropagation()\">\n        <img src=\"__hammer.svg\" style=\"height: 10px;\"> Eigene Prüfungsfragen\n      </button>\n      <div dir=\"auto\" id=\"hammer\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Prüfungsfragen}}</div>\n    </span>\n    {{/Eigene Prüfungsfragen}}\n\n    {{#Definitionen}}\n    <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Definitionen\" style=\"display: none;\">\n      <button id=\"button-definition\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Definitionen\n      </button>\n      <div dir=\"auto\" id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Definitionen}}</div>\n    </span>\n    {{/Definitionen}}\n\n    {{#Merksprüche}}\n    <span id=\"hint-merksprueche\" class=\"hintBtn\" data-name=\"Merksprüche\" style=\"display: none;\">\n      <button id=\"button-merksprueche\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-merksprueche'); event.stopPropagation()\">\n        <img src=\"__merkhilfe.svg\" style=\"height: 10px;\"> Merksprüche\n      </button>\n      <div dir=\"auto\" id=\"merksprueche\" class=\"hints\" style=\"display: none;\">{{edit:Merksprüche}}</div>\n    </span>\n    {{/Merksprüche}}\n\n    {{#Klinik}}\n    <span id=\"hint-klinik\" class=\"hintBtn\" data-name=\"Klinik\" style=\"display: none;\">\n      <button id=\"button-klinik\" class=\"button-general\" onclick=\"toggleHintBtn('hint-klinik'); event.stopPropagation()\">\n        <img src=\"__stethoscope.svg\" style=\"height: 10px;\"> Klinik\n      </button>\n      <div dir=\"auto\" id=\"klinik\" class=\"hints\" style=\"display: none;\">{{edit:Klinik}}</div>\n    </span>\n    {{/Klinik}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-praeparat\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n        </button>\n      </a>\n    </span>\n    {{/Präparat}}\n\n    {{#Virtuelle Mikroskopie}}\n    <span id=\"hint-microscope-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Virtuelle Mikroskopie}}\">\n        <button id=\"button-microscope\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Virtuelle Mikroskopie\n        </button>\n      </a>\n    </span>\n    {{/Virtuelle Mikroskopie}}\n\n    {{#Smart Zoom}}\n    <span id=\"hint-smartzoom-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-smartzoom\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Smart Zoom\n        </button>\n      </a>\n    </span>\n    {{/Smart Zoom}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat\" class=\"hintBtn\" data-name=\"Präparat\" style=\"display: none;\">\n      <button id=\"button-praeparat\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-praeparat'); event.stopPropagation()\">\n        <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n      </button>\n      <div dir=\"auto\" id=\"praeparat\" class=\"hints\" style=\"display: none;\">{{edit:Präparat}}</div>\n    </span>\n    {{/Präparat}}\n\n    {{#Memes}}\n    <span id=\"hint-memes\" class=\"hintBtn\" data-name=\"Memes\" style=\"display: none;\">\n      <button id=\"button-memes\" class=\"button-general\" onclick=\"toggleHintBtn('hint-memes'); event.stopPropagation()\">\n        <img src=\"__sonstiges.svg\" style=\"height: 10px;\"> Memes\n      </button>\n      <div dir=\"auto\" id=\"memes\" class=\"hints\" style=\"display: none;\">{{edit:Memes}}</div>\n    </span>\n    {{/Memes}}\n\n    <!-- LINEBREAKS IF BUTTONS EXIST -->\n    <script>\n      var array = [`{{Eigene Notizen & Bilder}}`, `{{Eigene Prüfungsfragen}}`, `{{Definitionen}}`, `{{Merksprüche}}`, `{{Klinik}}`, `{{Präparat}}`, `{{Memes}}`];\n      var anyistrue = (element) => element;\n      if (array.some(anyistrue)) {\n        document.getElementById(\"linebreaksIfButtons\").innerHTML = \"<br>\";\n      }\n    </script>\n    <div id=\"linebreaksIfButtons\"></div>\n\n    <!-- Extra field -->\n    {{#Extra}}\n    <div id=\"extra\" style=\"display: none;\">\n      <br>{{edit:Extra}}<br><br>\n    </div>\n    {{/Extra}}\n\n    <!-- Image field -->\n    {{#Bild}}\n    <div id=\"image\" style=\"display: none;\">\n      {{edit:Bild}}<br><br></div>\n    {{/Bild}}\n    {{^Bild}}\n    <span id=\"image\" style=\"display: none;\"></span>\n    {{/Bild}}\n    {{#Bild}}\n    <span id=\"hint-image\" style=\"display: none;\">\n      <button id=\"button-image\" class=\"button-general\"\n        onclick=\"var image = document.getElementById('image'); if (image.style.display == 'none') { image.style.display = 'block' } else { image.style.display = 'none' }; event.stopPropagation()\">\n        <img src=\"__image.svg\" style=\"height: 10px;\"> Abbildung\n      </button>\n    </span>\n    {{/Bild}}\n\n    <span id=\"hint-uafi\" class=\"hintBtn\" data-name=\"Ursprung, Ansatz, Verlauf, Funktion, Innervation, Äste\"\n      style=\"display: none;\">\n      <button id=\"button-uafi\" class=\"button-general expanded-button\"\n        onclick=\"toggleHintBtn('hint-uafi'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Weitere Informationen\n      </button>\n      <div id=\"uafi\" class=\"hints\" style=\"display: block;\">\n        <table class=\"uncloze\">\n          {{#Ursprung}}\n          <tr class=\"uafi-element\" id=\"Ursprung\">\n            <td><i>Ursprung</i></td>\n            <td>{{Ursprung}}</td>\n          </tr>\n          {{/Ursprung}}\n          {{#Ansatz}}\n          <tr class=\"uafi-element\" id=\"Ansatz\">\n            <td><i>Ansatz</i></td>\n            <td>{{Ansatz}}</td>\n          </tr>\n          {{/Ansatz}}\n          {{#Verlauf}}\n          <tr class=\"uafi-element\" id=\"Verlauf\">\n            <td><i>Verlauf</i></td>\n            <td>{{Verlauf}}</td>\n          </tr>\n          {{/Verlauf}}\n          {{#Funktion}}\n          <tr class=\"uafi-element\" id=\"Funktion\">\n            <td><i>Funktion</i></td>\n            <td>{{Funktion}}</td>\n          </tr>\n          {{/Funktion}}\n          {{#Innervation}}\n          <tr class=\"uafi-element\" id=\"Innervation\">\n            <td><i>Innervation</i></td>\n            <td>{{Innervation}}</td>\n          </tr>\n          {{/Innervation}}\n          {{#Äste}}\n          <tr class=\"uafi-element\" id=\"Äste\">\n            <td><i>Äste</i></td>\n            <td>{{Äste}}</td>\n          </tr>\n          {{/Äste}}\n        </table>\n      </div>\n\n      <script>\n        // iterate over all uafi-elements and hide only the one\n        // that is equal to the card's answer (i.e., value of {{Card}})\n        var uafiElements = document.getElementsByClassName(\"uafi-element\");\n        for (var i = 0; i < uafiElements.length; i++) {\n          if (((\"{{Card}}\").startsWith(uafiElements[i].id))) {\n            uafiElements[i].remove()\n          }\n        }\n      </script>\n    </span>\n\n    {{#AMBOSS-Link}}\n    <span id=\"hint-amboss\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:AMBOSS-Link}}\">\n        <button id=\"button-amboss\" class=\"button-general\">\n          <img src=\"__amboss.svg\" style=\"height: 10px;\"> AMBOSS&#8203;\n        </button>\n      </a>\n    </span>\n    {{/AMBOSS-Link}}\n\n    {{#Thieme via medici-Link}}\n    <span id=\"hint-thieme\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Thieme via medici-Link}}\">\n        <button id=\"button-thieme\" class=\"button-general\">\n          <img id=\"button-thieme-img\" src=\"__thieme-heart.svg\" style=\"height: 10px;\"> Thieme via medici\n        </button>\n      </a>\n    </span>\n    {{/Thieme via medici-Link}}\n\n    {{#Meditricks}}\n    <span id=\"hint-meditricks\" class=\"hintBtn\" data-name=\"Meditricks\" style=\"display: none;\">\n      <button id=\"button-meditricks\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-meditricks'); event.stopPropagation()\">\n        <img src=\"__meditricks.svg\" style=\"height: 10px;\"> Meditricks\n      </button>\n      <div dir=\"auto\" id=\"meditricks\" class=\"hints\" style=\"display: none;\">{{edit:Meditricks}}</div>\n    </span>\n    {{/Meditricks}}\n\n    {{#weitere Links}}\n    <span id=\"hint-linkcontainer\" class=\"hintBtn\" data-name=\"linkContainer\" style=\"display: none;\">\n      <button id=\"button-linkcontainer\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-linkcontainer'); event.stopPropagation()\">\n        <img src=\"__internet.svg\" style=\"height: 10px;\"> weitere Links\n      </button>\n      <div id=\"linkcontainer\" class=\"hints\" style=\"display: none;\"></div>\n      <span id=\"linkContainerLinks\" style=\"display: none;\">{{edit:weitere Links}}</span>\n    </span>\n    {{/weitere Links}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n  try {\n    for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n      href = link.href\n      text = link.innerText\n\n      const el = document.createElement('a');\n      el.setAttribute('href', link.href);\n\n      const btn = document.createElement('button');\n      btn.classList.add('button-general');\n      btn.classList.add('expanded-button');\n\n      domain = href.replace(/.+\\/\\/|(www|flexikon|register|de|next|com).|\\..+/g, '');\n      domainDict = {\n        \"amboss\": \"__amboss.svg\",\n        \"wikipedia\": \"__wikipedia.svg\",\n        \"doccheck\": \"__doccheck.png\",\n        \"notfallguru\": \"__notfallguru.svg\",\n        \"awmf\": \"__awmf.svg\",\n        \"gelbe-liste\": \"__gelbe-liste.png\",\n        \"embryotox\": \"__embryotox.svg\",\n        \"radiopaedia\": \"__radiopaedia.png\",\n        \"orphanet\": \"__orphanet.png\",\n      }\n      if (domain in domainDict) {\n        icon = domainDict[domain]\n      } else {\n        icon = \"__internet.svg\"\n      }\n\n      const img = document.createElement('img');\n      img.setAttribute('src', icon);\n      img.setAttribute('style', 'height: 10px;');\n\n      btn.appendChild(img);\n      btn.innerHTML = btn.innerHTML + \" \" + text;\n\n      el.appendChild(btn);\n\n      document.getElementById(\"linkcontainer\").appendChild(el)\n    }\n  }\n  catch (err) {\n    console.log(err)\n  }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-uafi\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- AUTOFLIP BACK SCRIPT -->\n<script>\n  // autoflip hides card in front template\n  document.getElementById(\"qa\").style.removeProperty(\"display\")\n</script>\n\n<!-- CLOZE ONE BY ONE SCRIPT -->\n<style>\n  .cloze-replacer:hover {\n    cursor: pointer;\n  }\n\n  .cloze-hidden {\n    display: none;\n  }\n\n  .cloze-replacer .hidden {\n    display: none;\n  }\n\n  #extra.hidden {\n    display: none;\n  }\n</style>\n\n<!--\n Based on the AnKing Notetype, but expanded and modified by phyn.\n Credit to the original authors, except where modified or otherwise indicated.\n-->\n\n<script>\n    (function () {\n      // enables cloze one-by-one even when one-by-one field is empty\n      // minNumberOfClozes is still considered in this case\n      // overridden in importance by selectiveOneByOne\n      var clozeOneByOneEnabled = true;\n\n      // remove the clickAnywhere function from global scope\n      document.documentElement.removeAttribute(\"onclick\")\n\n      // --- CHECK IF ONE BY ONE IS GENERALLY ENABLED FOR THIS NOTE ---\n      var oneByOneFieldNotEmpty = \"{{One by one}}\" !== \"\";\n      try {\n        clozeOneByOneEnabled = alwaysOneByOne || oneByOneFieldNotEmpty;\n      } catch (exception) {\n        console.log(exception)\n      }\n\n      /**\n   * helper functions to show / hide fields containing additional information\n   */\n      const showExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const hideExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const buttonIds = [\n        \"hint-zusatz\",\n        \"hint-definition\",\n        \"hint-hammer\",\n        \"hint-klinik\",\n        \"hint-praeparat\",\n        \"hint-microscope\",\n        \"hint-smartzoom\",\n        \"hint-histotrainer\",\n        \"hint-uafi\",\n        \"hint-merksprueche\",\n        \"hint-memes\",\n        \"hint-image\",\n        \"hint-amboss\",\n        \"hint-thieme\",\n        \"hint-meditricks\",\n        \"hint-linkcontainer\",\n      ];\n\n      const showExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document\n              .getElementById(buttonIds[button])\n              .style.removeProperty(\"display\");\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n      const hideExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document.getElementById(buttonIds[button]).style.display = \"none\";\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n\n      // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n      /**\n       * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n       */\n      const getCardNumber = function () {\n        clz = document.body.className;\n        const regex = /card(\\d+)/gm;\n\n        let clz2;\n        try {\n          clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n        } catch (e) {\n          clz2 = \"\";\n        }\n        const regex2 = /.*?Cloze(\\d+)/gm;\n\n        let m;\n\n        if ((m = regex2.exec(clz2)) !== null) {\n          return m[1];\n        } else if ((m = regex.exec(clz)) !== null) {\n          return m[1];\n        } else {\n          // Should only fire if card is not cloze\n          console.error(\"Cannot find cardN class of body element!\");\n          return \"0\";\n        }\n      }\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (!clozeOneByOneEnabled) {\n        showExtra()\n        showExtraButtons()\n        document.getElementById(\"onebyone-buttons\").style.display = \"none\"\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n        return\n      }\n\n      // Needed for amboss to recognize first word in .cloze-hidden\n      const CLOZE_REPLACER_SEP = \"<span class='hidden'> </span>\"\n\n      const hideAllCloze = function (initial) {\n        let clozes = document.getElementsByClassName(\"cloze\")\n        let count = 0 // hidden cloze count\n        for (const cloze of clozes) {\n          const existingHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n          if (existingHidden) {\n            revealCloze(cloze);\n          }\n          if (cloze.offsetWidth === 0) {\n            continue\n          }\n          const clozeReplacer = document.createElement(\"span\")\n          const clozeHidden = document.createElement(\"span\")\n          clozeReplacer.classList.add(\"cloze-replacer\")\n          clozeHidden.classList.add(\"cloze-hidden\")\n          while (cloze.childNodes.length > 0) {\n            clozeHidden.appendChild(cloze.childNodes[0])\n          }\n          cloze.appendChild(clozeReplacer)\n          cloze.appendChild(clozeHidden)\n\n          var clozeHints = Persistence.getItem(\"clozeHints\");\n          if (clozeHints && clozeHints[count]) {\n            clozeReplacer.classList.add(\"cloze-hint\")\n            clozeReplacer.innerHTML = clozeHints[count] + CLOZE_REPLACER_SEP\n          } else {\n            clozeReplacer.innerHTML = clozeHider(cloze) + CLOZE_REPLACER_SEP\n          }\n          count += 1\n          document.getElementById(\"button-reveal-next\").style.display = \"inline-block\";\n          if (initial) {\n            cloze.addEventListener(\"touchend\", revealClozeClicked)\n            cloze.addEventListener(\"click\", revealClozeClicked)\n            cloze.classList.add(\"one-by-one\");\n          }\n        }\n\n        // Hide #extra until all clozes are shown\n        const extra = document.getElementById(\"extra\");\n        if (extra) {\n          extra.classList.add(\"hidden\");\n        }\n\n        hideExtra();\n        hideExtraButtons();\n        if (revealAnywhere) {\n          document.documentElement.setAttribute(\"onclick\", \"revealNextCloze(); event.stopPropagation()\")\n        }\n\n\n        // Also hide autoReveal fields\n        for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n          const container = document.querySelector(`[data-name=\"${field}\"]`)\n          if (container) {\n            const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n            if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n              // const link = container.getElementsByTagName(\"a\")[0]\n              const button = container.getElementsByTagName(\"button\")[0]\n              const hint = container.getElementsByTagName(\"div\")[0]\n              button.classList.remove(\"expanded-button\")\n              hint.style.display = \"none\"\n              // link.style.display = \"\"\n            }\n          }\n        }\n      }\n\n      const revealCloze = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        cloze.removeChild(clozeReplacer)\n        cloze.removeChild(clozeHidden)\n        while (clozeHidden.childNodes.length > 0) {\n          cloze.appendChild(clozeHidden.childNodes[0])\n        }\n        maybeRevealExtraField()\n      }\n\n      const revealClozeWord = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        let range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundSpace = setRangeEnd(range, clozeHidden, \"beforeFirstSpace\")\n        if (!foundSpace) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        let fragment = range.extractContents()\n        cloze.insertBefore(fragment, clozeReplacer)\n        // Extract whitespaces after word\n        range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundWord = setRangeEnd(range, clozeHidden, \"beforeFirstChar\")\n        if (!foundWord) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        fragment = range.extractContents();\n        cloze.insertBefore(fragment, clozeReplacer)\n        if (!foundWord) {\n          cloze.removeChild(clozeHidden)\n          cloze.removeChild(clozeReplacer)\n          maybeRevealExtraField()\n          return\n        }\n        clozeReplacer.innerHTML = clozeHider(clozeHidden) + CLOZE_REPLACER_SEP\n        if (clozeReplacer.classList.contains(\"cloze-hint\")) [\n          clozeReplacer.classList.remove(\"cloze-hint\")\n        ]\n        maybeRevealExtraField()\n      }\n\n      const revealNextClozeOf = (type) => {\n        const nextHidden = document.querySelectorAll(\".cloze-hidden\")\n        const nextNextHidden = nextHidden.length > 1 ? true : false\n        if (!nextNextHidden) {\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\";\n        }\n        if (!nextHidden) {\n          return\n        }\n        const cloze = clozeElOfClozeHidden(nextHidden[0]);\n        if (type === \"word\") {\n          revealClozeWord(cloze)\n        } else if (type === \"cloze\") {\n          revealCloze(cloze)\n        } else {\n          console.error(\"Invalid type: \" + type)\n        }\n      }\n\n      const revealClozeClicked = function (ev) {\n        let elem = ev.currentTarget\n        if (!ev.altKey && (revealNextClozeMode !== \"word\")) {\n          revealCloze(elem)\n        } else {\n          revealClozeWord(elem)\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      }\n\n      window.revealNextCloze = function () {\n        revealNextClozeOf(revealNextClozeMode)\n      }\n\n      window.toggleAllCloze = function () {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length > 0) {\n          for (const elem of elems) {\n            const cloze = clozeElOfClozeHidden(elem)\n            revealCloze(cloze)\n          }\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\"\n        } else {\n          hideAllCloze(initial = false)\n        }\n      }\n\n      const clozeElOfClozeHidden = (cloze) => {\n        while (!cloze.classList.contains(\"cloze\")) {\n          cloze = cloze.parentElement;\n        }\n        return cloze;\n      }\n\n      const maybeRevealExtraField = () => {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length == 0) {\n          const extra = document.getElementById(\"extra\")\n          if (extra) {\n            extra.classList.remove(\"hidden\")\n          }\n\n          showExtra();\n          showExtraButtons();\n          document.documentElement.removeAttribute(\"onclick\")\n\n          // Also reveal autoReveal fields\n          for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n            const container = document.querySelector(`[data-name=\"${field}\"]`)\n            if (container) {\n              const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n              if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n                // const link = container.getElementsByTagName(\"a\")[0]\n                const button = container.getElementsByTagName(\"button\")[0]\n                const hint = container.getElementsByTagName(\"div\")[0]\n                button.classList.add(\"expanded-button\")\n                hint.style.display = \"block\"\n                // link.style.display = \"none\"\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * mode: 'beforeFirstSpace' or 'beforeFirstChar'\n       * Return `true` if it exists and setEnd() was called, otherwise `false`\n       */\n      const setRangeEnd = function (range, node, mode) {\n        if (node.nodeType === Node.TEXT_NODE) {\n          const regex = mode === 'beforeFirstSpace' ? /\\s/ : /\\S/\n          const match = node.textContent.match(regex)\n          if (match) {\n            if (match.index === 0) {\n              while (node.previousSibling === null) {\n                node = node.parentElement\n              }\n              range.setEndBefore(node)\n            } else {\n              range.setEnd(node, match.index);\n            }\n            return true;\n          } else {\n            return false;\n          }\n        } else if (mode === 'beforeFirstChar' && isCharNode(node)) {\n          range.setEndBefore(node)\n          return true\n        } else if (!ignoreSpaceInNode(node)) {\n          for (const child of node.childNodes) {\n            if (setRangeEnd(range, child, mode)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }\n\n      const ignoreSpaceInNode = function (node) {\n        return node.tagName === \"MJX-ASSISTIVE-MML\"\n      }\n\n      const isCharNode = function (node) {\n        return [\"IMG\", \"MJX-CONTAINER\"].includes(node.tagName)\n      }\n\n      hideAllCloze(initial = true)\n\n      let isShowNextShortcut = shortcutMatcher(window.revealNextShortcut)\n      let isShowWordShortcut = shortcutMatcher(window.revealNextWordShortcut)\n      let isToggleAllShortcut = shortcutMatcher(window.toggleAllShortcut)\n      ankingAddEventListener(\"keydown\", (ev) => {\n        let next = isShowNextShortcut(ev)\n        let word = isShowWordShortcut(ev)\n        let all = isToggleAllShortcut(ev)\n        if (next) {\n          revealNextClozeOf(\"cloze\")\n        } else if (word) {\n          revealNextClozeOf(\"word\")\n        } else if (all) {\n          toggleAllCloze()\n        } else {\n          return;\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      });\n    })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- MEDITRICKS SNIPPETS DATA -->\n<div id=\"meditricks-mtsp-values\" style=\"display:none;\">\n  <div id=\"meditricks-mtsp-nfname\">_meditricks_nf_v1000_ankizin</div>\n  <div id=\"meditricks-mtsp-nid\">{{Note ID}}</div>\n</div>\n<script src=\"_meditricks_mtsp_scripts_v1000_ankizin.js\"></script>\n<link href=\"_meditricks_mtsp_styles_v1000_ankizin.css\" rel=\"stylesheet\" />\n\n<!-- include \"_meditricks_mtsp_nf_v1000_ankizin.js\" -->\n<!-- include \"_meditricks_mtsp_scripts_v1000_iframe.map\" -->\n<!-- include \"_meditricks_mtsp_mtlogo.webp\" -->\n<!-- include \"_meditricks_mtsp_mt-loading.png\" -->\n<!-- include \"_meditricks_mtsp_mt-loading_night.png\" -->\n\n<!-- //MEDITRICKS SNIPPETS DATA -->\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>",
      "bqfmt": "{{Muskel / Leitungsbahn}}",
      "bafmt": "{{Verlauf}}",
      "bfont": "Helvetica",
      "bsize": 12
    },
    {
      "name": "VerlaufCloze3",
      "ord": 14,
      "qfmt": "<!-- version f0935e4 -->\n{{#Verlauf}}\n{{#VerlaufCloze3}}\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TIMER CONFIG  ##############\n  // Timer config (timer length, timer finished message)\n  var minutes = 0\n  var seconds = 15\n  var timeOverMsg = \"<span style='color:#CC5B5B'>!!!</span>\"\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  // Auto flip to back when One by one mode.\n  var autoflip = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Wie ist der <i>Verlauf</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" data-card=\"{{Card}}\"><br>{{Verlauf}}</div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\"></div>\n\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<script>\n  //DONT FADE BETWEEN CARDS\n  qFade = 0;\n  if (typeof anki !== 'undefined') anki.qFade = qFade;\n</script>\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    if (!indentation) { return; }\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- CLOZE ONE BY ONE FRONT -->\n<div id=\"one-by-one\" style=\"display: none;\"></div>\n\n<script>\n  /**\n   * Based on the AnKing Notetype, but expanded and modified by phyn.\n   * Credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  Persistence.clear();\n\n  // check if OneByOne is generally enabled for this card\n  var oneByOneFieldEmpty = selectiveOneByOne ? \"{{One by one}}\" === \"\" : true;\n  var clozeOneByOneEnabled = alwaysOneByOne ? true : !oneByOneFieldEmpty;\n\n  // avoid flickering. Must unset this in the back.\n  document.getElementById(\"qa\").style.display = \"none\";\n  var clozeHints = [];\n\n  if (clozeOneByOneEnabled) {\n    // collect hints from front side (independent of whether or not OneByOne is enabled)\n    document.getElementById(\"qa\").classList.add('one-by-one');\n    // Save cloze hints to display in the back\n    var clozes = document.getElementsByClassName(\"cloze\")\n    for (var i = 0; i < clozes.length; i++) {\n      clozes[i].classList.add(\"one-by-one\");\n      if (clozes[i].innerHTML === \"[...]\") {\n        clozeHints.push(\"\")\n      } else {\n        clozeHints.push(clozes[i].innerHTML)\n      }\n    }\n\n    // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n    /**\n     * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n     */\n    const getCardNumber = function () {\n      clz = document.body.className;\n      const regex = /card(\\d+)/gm;\n\n      let clz2;\n      try {\n        clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n      } catch (e) {\n        clz2 = \"\";\n      }\n      const regex2 = /.*?Cloze(\\d+)/gm;\n\n      let m;\n\n      if ((m = regex2.exec(clz2)) !== null) {\n        return m[1];\n      } else if ((m = regex.exec(clz)) !== null) {\n        return m[1];\n      } else {\n        // Should only fire if card is not cloze\n        console.error(\"Cannot find cardN class of body element!\");\n        return \"0\";\n      }\n    }\n\n    var alreadyRendered = false;\n\n    function processSelective1b1() {\n      if (alreadyRendered) return;\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (autoflip && clozeOneByOneEnabled) {\n        if (window.pycmd || window.showAnswer) {\n          // avoid flickering. Must unset this in the back.\n          document.getElementById(\"qa\").style.display = \"none\";\n        }\n        if (window.pycmd) {\n          pycmd(\"ans\")\n        } else if (window.showAnswer) {\n          showAnswer()\n        }\n      } else {\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n      }\n      // AnkiMobile JS API doesn't have one for show answer.\n      // Best alternative is to use Taps/Swipes to show answer.\n\n      alreadyRendered = true;\n    }\n\n    function delayedProcessSelective1b1() {\n      if (window.requestAnimationFrame) window.requestAnimationFrame(processSelective1b1); // less flickering\n      else window.setTimeout(processSelective1b1, 0);\n    };\n\n    window.onload = delayedProcessSelective1b1;\n    if (document.readyState === \"complete\") {\n      delayedProcessSelective1b1();\n    }\n    else {\n      document.addEventListener(\"DOMContentLoaded\", delayedProcessSelective1b1);\n    }\n\n    // Observe document.body class changes to trigger re-rendering.\n    // This is useful, because Anki doesn’t always start with an up-to-date class list:\n    // https://forums.ankiweb.net/t/card-card-classes-only-injected-separately-now/27387.\n    const observer = new MutationObserver(function (mutationsList, observer) {\n      for (let mutation of mutationsList) {\n        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {\n          delayedProcessSelective1b1();\n        }\n      }\n    });\n    observer.observe(document.body, { attributes: true });\n  }\n  Persistence.setItem(\"clozeHints\", clozeHints);\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>\n\n\n{{/VerlaufCloze3}}\n{{/Verlauf}}",
      "afmt": "<!-- version f0935e4 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n<div id=\"back\"></div>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Eigene Notizen & Bilder\": \"Alt + 1\",\n    \"Eigene Prüfungsfragen\": \"Alt + 2\",\n    \"Definitionen\": \"Alt + 3\",\n    \"Merksprüche\": \"Alt + 4\",\n    \"Klinik\": \"Alt + 5\",\n    \"Präparat\": \"Alt + 6\",\n    \"Memes\": \"Alt + 7\",\n    \"linkContainer\": \"Alt + L\",\n    \"Meditricks\": \"Alt + M\",\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Eigene Notizen & Bilder\": false,\n    \"Eigene Prüfungsfragen\": false,\n    \"Definitionen\": false,\n    \"Merksprüche\": false,\n    \"Klinik\": false,\n    \"Präparat\": false,\n    \"Memes\": false,\n    \"linkContainer\": true,\n    \"Meditricks\": false,\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  var revealNextShortcut = \"N\"\n  var revealNextWordShortcut = \"Shift + N\"\n  var toggleAllShortcut = \",\"\n\n  // Enables revealing of next Cloze by simply clicking / tapping anywhere on the card (except the buttons)\n  var revealAnywhere = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // Changes how \"Reveal Next\" and clicking behaves. Either \"cloze\" or \"word\".\n  // \"word\" reveals word by word. \n  var revealNextClozeMode = \"cloze\"\n\n  // Changes how fields with additional information are displayed.\n  // true displays fields with additional information only if all clozes are revealed.\n  var hideAdditional = true;\n  var hideAdditionalButtons = true;\n\n  // What cloze is hidden with\n  var clozeHider = (elem) => \"[&nbsp;_&nbsp;]\"\n  /*\n  You can replace the above line with below examples. '█' or '_' works well for hiding clozes.\n  \n  // Fixed length:\n  var clozeHider = (elem) => \"███\"\n  // Replace each character with \"█\":\n  var clozeHider = (elem) => \"█\".repeat(elem.textContent.length)\n  // Show whitespaces:\n  var clozeHider = (elem) => \"[\" + elem.textContent.split(\" \").map((t) => \"█\".repeat(t.length)).join(\" \") + \"]\"\n  // Color-filled box (doesn't hide images):\n  var clozeHider = (elem) => `<span style=\"background-color: red; color: transparent;\">${elem.innerHTML}</span>`\n  */\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Wie ist der <i>Verlauf</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" class=\"clozefield\" data-card=\"{{Card}}\"><br>{{Verlauf}}</div>\n\n    <!-- ClOZE ONE BY ONE BUTTONS -->\n    <div id=\"onebyone-buttons\" class=\"onebyone\">\n      <br>\n      <button id=\"button-reveal-next\" class=\"button-general button-one-by-one\"\n        onclick=\"revealNextCloze(); event.stopPropagation()\">Reveal Next</button>\n      <button id=\"button-toggle-all\" class=\"button-general button-one-by-one\"\n        onclick=\"toggleAllCloze(); event.stopPropagation()\">Toggle All</button>\n    </div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- BUTTON FIELDS -->\n    {{#Eigene Notizen & Bilder}}\n    <span id=\"hint-zusatz\" class=\"hintBtn\" data-name=\"Eigene Notizen & Bilder\" style=\"display: none;\">\n      <button id=\"button-zusatz\" class=\"button-general\" onclick=\"toggleHintBtn('hint-zusatz'); event.stopPropagation()\">\n        <img src=\"__zusatz.svg\" style=\"height: 10px;\"> Eigene Notizen & Bilder\n      </button>\n      <div dir=\"auto\" id=\"zusatz\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Notizen & Bilder}}</div>\n    </span>\n    {{/Eigene Notizen & Bilder}}\n\n    {{#Eigene Prüfungsfragen}}\n    <span id=\"hint-hammer\" class=\"hintBtn\" data-name=\"Eigene Prüfungsfragen\" style=\"display: none;\">\n      <button id=\"button-hammer\" class=\"button-general\" onclick=\"toggleHintBtn('hint-hammer'); event.stopPropagation()\">\n        <img src=\"__hammer.svg\" style=\"height: 10px;\"> Eigene Prüfungsfragen\n      </button>\n      <div dir=\"auto\" id=\"hammer\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Prüfungsfragen}}</div>\n    </span>\n    {{/Eigene Prüfungsfragen}}\n\n    {{#Definitionen}}\n    <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Definitionen\" style=\"display: none;\">\n      <button id=\"button-definition\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Definitionen\n      </button>\n      <div dir=\"auto\" id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Definitionen}}</div>\n    </span>\n    {{/Definitionen}}\n\n    {{#Merksprüche}}\n    <span id=\"hint-merksprueche\" class=\"hintBtn\" data-name=\"Merksprüche\" style=\"display: none;\">\n      <button id=\"button-merksprueche\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-merksprueche'); event.stopPropagation()\">\n        <img src=\"__merkhilfe.svg\" style=\"height: 10px;\"> Merksprüche\n      </button>\n      <div dir=\"auto\" id=\"merksprueche\" class=\"hints\" style=\"display: none;\">{{edit:Merksprüche}}</div>\n    </span>\n    {{/Merksprüche}}\n\n    {{#Klinik}}\n    <span id=\"hint-klinik\" class=\"hintBtn\" data-name=\"Klinik\" style=\"display: none;\">\n      <button id=\"button-klinik\" class=\"button-general\" onclick=\"toggleHintBtn('hint-klinik'); event.stopPropagation()\">\n        <img src=\"__stethoscope.svg\" style=\"height: 10px;\"> Klinik\n      </button>\n      <div dir=\"auto\" id=\"klinik\" class=\"hints\" style=\"display: none;\">{{edit:Klinik}}</div>\n    </span>\n    {{/Klinik}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-praeparat\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n        </button>\n      </a>\n    </span>\n    {{/Präparat}}\n\n    {{#Virtuelle Mikroskopie}}\n    <span id=\"hint-microscope-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Virtuelle Mikroskopie}}\">\n        <button id=\"button-microscope\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Virtuelle Mikroskopie\n        </button>\n      </a>\n    </span>\n    {{/Virtuelle Mikroskopie}}\n\n    {{#Smart Zoom}}\n    <span id=\"hint-smartzoom-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-smartzoom\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Smart Zoom\n        </button>\n      </a>\n    </span>\n    {{/Smart Zoom}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat\" class=\"hintBtn\" data-name=\"Präparat\" style=\"display: none;\">\n      <button id=\"button-praeparat\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-praeparat'); event.stopPropagation()\">\n        <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n      </button>\n      <div dir=\"auto\" id=\"praeparat\" class=\"hints\" style=\"display: none;\">{{edit:Präparat}}</div>\n    </span>\n    {{/Präparat}}\n\n    {{#Memes}}\n    <span id=\"hint-memes\" class=\"hintBtn\" data-name=\"Memes\" style=\"display: none;\">\n      <button id=\"button-memes\" class=\"button-general\" onclick=\"toggleHintBtn('hint-memes'); event.stopPropagation()\">\n        <img src=\"__sonstiges.svg\" style=\"height: 10px;\"> Memes\n      </button>\n      <div dir=\"auto\" id=\"memes\" class=\"hints\" style=\"display: none;\">{{edit:Memes}}</div>\n    </span>\n    {{/Memes}}\n\n    <!-- LINEBREAKS IF BUTTONS EXIST -->\n    <script>\n      var array = [`{{Eigene Notizen & Bilder}}`, `{{Eigene Prüfungsfragen}}`, `{{Definitionen}}`, `{{Merksprüche}}`, `{{Klinik}}`, `{{Präparat}}`, `{{Memes}}`];\n      var anyistrue = (element) => element;\n      if (array.some(anyistrue)) {\n        document.getElementById(\"linebreaksIfButtons\").innerHTML = \"<br>\";\n      }\n    </script>\n    <div id=\"linebreaksIfButtons\"></div>\n\n    <!-- Extra field -->\n    {{#Extra}}\n    <div id=\"extra\" style=\"display: none;\">\n      <br>{{edit:Extra}}<br><br>\n    </div>\n    {{/Extra}}\n\n    <!-- Image field -->\n    {{#Bild}}\n    <div id=\"image\" style=\"display: none;\">\n      {{edit:Bild}}<br><br></div>\n    {{/Bild}}\n    {{^Bild}}\n    <span id=\"image\" style=\"display: none;\"></span>\n    {{/Bild}}\n    {{#Bild}}\n    <span id=\"hint-image\" style=\"display: none;\">\n      <button id=\"button-image\" class=\"button-general\"\n        onclick=\"var image = document.getElementById('image'); if (image.style.display == 'none') { image.style.display = 'block' } else { image.style.display = 'none' }; event.stopPropagation()\">\n        <img src=\"__image.svg\" style=\"height: 10px;\"> Abbildung\n      </button>\n    </span>\n    {{/Bild}}\n\n    <span id=\"hint-uafi\" class=\"hintBtn\" data-name=\"Ursprung, Ansatz, Verlauf, Funktion, Innervation, Äste\"\n      style=\"display: none;\">\n      <button id=\"button-uafi\" class=\"button-general expanded-button\"\n        onclick=\"toggleHintBtn('hint-uafi'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Weitere Informationen\n      </button>\n      <div id=\"uafi\" class=\"hints\" style=\"display: block;\">\n        <table class=\"uncloze\">\n          {{#Ursprung}}\n          <tr class=\"uafi-element\" id=\"Ursprung\">\n            <td><i>Ursprung</i></td>\n            <td>{{Ursprung}}</td>\n          </tr>\n          {{/Ursprung}}\n          {{#Ansatz}}\n          <tr class=\"uafi-element\" id=\"Ansatz\">\n            <td><i>Ansatz</i></td>\n            <td>{{Ansatz}}</td>\n          </tr>\n          {{/Ansatz}}\n          {{#Verlauf}}\n          <tr class=\"uafi-element\" id=\"Verlauf\">\n            <td><i>Verlauf</i></td>\n            <td>{{Verlauf}}</td>\n          </tr>\n          {{/Verlauf}}\n          {{#Funktion}}\n          <tr class=\"uafi-element\" id=\"Funktion\">\n            <td><i>Funktion</i></td>\n            <td>{{Funktion}}</td>\n          </tr>\n          {{/Funktion}}\n          {{#Innervation}}\n          <tr class=\"uafi-element\" id=\"Innervation\">\n            <td><i>Innervation</i></td>\n            <td>{{Innervation}}</td>\n          </tr>\n          {{/Innervation}}\n          {{#Äste}}\n          <tr class=\"uafi-element\" id=\"Äste\">\n            <td><i>Äste</i></td>\n            <td>{{Äste}}</td>\n          </tr>\n          {{/Äste}}\n        </table>\n      </div>\n\n      <script>\n        // iterate over all uafi-elements and hide only the one\n        // that is equal to the card's answer (i.e., value of {{Card}})\n        var uafiElements = document.getElementsByClassName(\"uafi-element\");\n        for (var i = 0; i < uafiElements.length; i++) {\n          if (((\"{{Card}}\").startsWith(uafiElements[i].id))) {\n            uafiElements[i].remove()\n          }\n        }\n      </script>\n    </span>\n\n    {{#AMBOSS-Link}}\n    <span id=\"hint-amboss\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:AMBOSS-Link}}\">\n        <button id=\"button-amboss\" class=\"button-general\">\n          <img src=\"__amboss.svg\" style=\"height: 10px;\"> AMBOSS&#8203;\n        </button>\n      </a>\n    </span>\n    {{/AMBOSS-Link}}\n\n    {{#Thieme via medici-Link}}\n    <span id=\"hint-thieme\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Thieme via medici-Link}}\">\n        <button id=\"button-thieme\" class=\"button-general\">\n          <img id=\"button-thieme-img\" src=\"__thieme-heart.svg\" style=\"height: 10px;\"> Thieme via medici\n        </button>\n      </a>\n    </span>\n    {{/Thieme via medici-Link}}\n\n    {{#Meditricks}}\n    <span id=\"hint-meditricks\" class=\"hintBtn\" data-name=\"Meditricks\" style=\"display: none;\">\n      <button id=\"button-meditricks\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-meditricks'); event.stopPropagation()\">\n        <img src=\"__meditricks.svg\" style=\"height: 10px;\"> Meditricks\n      </button>\n      <div dir=\"auto\" id=\"meditricks\" class=\"hints\" style=\"display: none;\">{{edit:Meditricks}}</div>\n    </span>\n    {{/Meditricks}}\n\n    {{#weitere Links}}\n    <span id=\"hint-linkcontainer\" class=\"hintBtn\" data-name=\"linkContainer\" style=\"display: none;\">\n      <button id=\"button-linkcontainer\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-linkcontainer'); event.stopPropagation()\">\n        <img src=\"__internet.svg\" style=\"height: 10px;\"> weitere Links\n      </button>\n      <div id=\"linkcontainer\" class=\"hints\" style=\"display: none;\"></div>\n      <span id=\"linkContainerLinks\" style=\"display: none;\">{{edit:weitere Links}}</span>\n    </span>\n    {{/weitere Links}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n  try {\n    for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n      href = link.href\n      text = link.innerText\n\n      const el = document.createElement('a');\n      el.setAttribute('href', link.href);\n\n      const btn = document.createElement('button');\n      btn.classList.add('button-general');\n      btn.classList.add('expanded-button');\n\n      domain = href.replace(/.+\\/\\/|(www|flexikon|register|de|next|com).|\\..+/g, '');\n      domainDict = {\n        \"amboss\": \"__amboss.svg\",\n        \"wikipedia\": \"__wikipedia.svg\",\n        \"doccheck\": \"__doccheck.png\",\n        \"notfallguru\": \"__notfallguru.svg\",\n        \"awmf\": \"__awmf.svg\",\n        \"gelbe-liste\": \"__gelbe-liste.png\",\n        \"embryotox\": \"__embryotox.svg\",\n        \"radiopaedia\": \"__radiopaedia.png\",\n        \"orphanet\": \"__orphanet.png\",\n      }\n      if (domain in domainDict) {\n        icon = domainDict[domain]\n      } else {\n        icon = \"__internet.svg\"\n      }\n\n      const img = document.createElement('img');\n      img.setAttribute('src', icon);\n      img.setAttribute('style', 'height: 10px;');\n\n      btn.appendChild(img);\n      btn.innerHTML = btn.innerHTML + \" \" + text;\n\n      el.appendChild(btn);\n\n      document.getElementById(\"linkcontainer\").appendChild(el)\n    }\n  }\n  catch (err) {\n    console.log(err)\n  }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-uafi\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- AUTOFLIP BACK SCRIPT -->\n<script>\n  // autoflip hides card in front template\n  document.getElementById(\"qa\").style.removeProperty(\"display\")\n</script>\n\n<!-- CLOZE ONE BY ONE SCRIPT -->\n<style>\n  .cloze-replacer:hover {\n    cursor: pointer;\n  }\n\n  .cloze-hidden {\n    display: none;\n  }\n\n  .cloze-replacer .hidden {\n    display: none;\n  }\n\n  #extra.hidden {\n    display: none;\n  }\n</style>\n\n<!--\n Based on the AnKing Notetype, but expanded and modified by phyn.\n Credit to the original authors, except where modified or otherwise indicated.\n-->\n\n<script>\n    (function () {\n      // enables cloze one-by-one even when one-by-one field is empty\n      // minNumberOfClozes is still considered in this case\n      // overridden in importance by selectiveOneByOne\n      var clozeOneByOneEnabled = true;\n\n      // remove the clickAnywhere function from global scope\n      document.documentElement.removeAttribute(\"onclick\")\n\n      // --- CHECK IF ONE BY ONE IS GENERALLY ENABLED FOR THIS NOTE ---\n      var oneByOneFieldNotEmpty = \"{{One by one}}\" !== \"\";\n      try {\n        clozeOneByOneEnabled = alwaysOneByOne || oneByOneFieldNotEmpty;\n      } catch (exception) {\n        console.log(exception)\n      }\n\n      /**\n   * helper functions to show / hide fields containing additional information\n   */\n      const showExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const hideExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const buttonIds = [\n        \"hint-zusatz\",\n        \"hint-definition\",\n        \"hint-hammer\",\n        \"hint-klinik\",\n        \"hint-praeparat\",\n        \"hint-microscope\",\n        \"hint-smartzoom\",\n        \"hint-histotrainer\",\n        \"hint-uafi\",\n        \"hint-merksprueche\",\n        \"hint-memes\",\n        \"hint-image\",\n        \"hint-amboss\",\n        \"hint-thieme\",\n        \"hint-meditricks\",\n        \"hint-linkcontainer\",\n      ];\n\n      const showExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document\n              .getElementById(buttonIds[button])\n              .style.removeProperty(\"display\");\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n      const hideExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document.getElementById(buttonIds[button]).style.display = \"none\";\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n\n      // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n      /**\n       * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n       */\n      const getCardNumber = function () {\n        clz = document.body.className;\n        const regex = /card(\\d+)/gm;\n\n        let clz2;\n        try {\n          clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n        } catch (e) {\n          clz2 = \"\";\n        }\n        const regex2 = /.*?Cloze(\\d+)/gm;\n\n        let m;\n\n        if ((m = regex2.exec(clz2)) !== null) {\n          return m[1];\n        } else if ((m = regex.exec(clz)) !== null) {\n          return m[1];\n        } else {\n          // Should only fire if card is not cloze\n          console.error(\"Cannot find cardN class of body element!\");\n          return \"0\";\n        }\n      }\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (!clozeOneByOneEnabled) {\n        showExtra()\n        showExtraButtons()\n        document.getElementById(\"onebyone-buttons\").style.display = \"none\"\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n        return\n      }\n\n      // Needed for amboss to recognize first word in .cloze-hidden\n      const CLOZE_REPLACER_SEP = \"<span class='hidden'> </span>\"\n\n      const hideAllCloze = function (initial) {\n        let clozes = document.getElementsByClassName(\"cloze\")\n        let count = 0 // hidden cloze count\n        for (const cloze of clozes) {\n          const existingHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n          if (existingHidden) {\n            revealCloze(cloze);\n          }\n          if (cloze.offsetWidth === 0) {\n            continue\n          }\n          const clozeReplacer = document.createElement(\"span\")\n          const clozeHidden = document.createElement(\"span\")\n          clozeReplacer.classList.add(\"cloze-replacer\")\n          clozeHidden.classList.add(\"cloze-hidden\")\n          while (cloze.childNodes.length > 0) {\n            clozeHidden.appendChild(cloze.childNodes[0])\n          }\n          cloze.appendChild(clozeReplacer)\n          cloze.appendChild(clozeHidden)\n\n          var clozeHints = Persistence.getItem(\"clozeHints\");\n          if (clozeHints && clozeHints[count]) {\n            clozeReplacer.classList.add(\"cloze-hint\")\n            clozeReplacer.innerHTML = clozeHints[count] + CLOZE_REPLACER_SEP\n          } else {\n            clozeReplacer.innerHTML = clozeHider(cloze) + CLOZE_REPLACER_SEP\n          }\n          count += 1\n          document.getElementById(\"button-reveal-next\").style.display = \"inline-block\";\n          if (initial) {\n            cloze.addEventListener(\"touchend\", revealClozeClicked)\n            cloze.addEventListener(\"click\", revealClozeClicked)\n            cloze.classList.add(\"one-by-one\");\n          }\n        }\n\n        // Hide #extra until all clozes are shown\n        const extra = document.getElementById(\"extra\");\n        if (extra) {\n          extra.classList.add(\"hidden\");\n        }\n\n        hideExtra();\n        hideExtraButtons();\n        if (revealAnywhere) {\n          document.documentElement.setAttribute(\"onclick\", \"revealNextCloze(); event.stopPropagation()\")\n        }\n\n\n        // Also hide autoReveal fields\n        for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n          const container = document.querySelector(`[data-name=\"${field}\"]`)\n          if (container) {\n            const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n            if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n              // const link = container.getElementsByTagName(\"a\")[0]\n              const button = container.getElementsByTagName(\"button\")[0]\n              const hint = container.getElementsByTagName(\"div\")[0]\n              button.classList.remove(\"expanded-button\")\n              hint.style.display = \"none\"\n              // link.style.display = \"\"\n            }\n          }\n        }\n      }\n\n      const revealCloze = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        cloze.removeChild(clozeReplacer)\n        cloze.removeChild(clozeHidden)\n        while (clozeHidden.childNodes.length > 0) {\n          cloze.appendChild(clozeHidden.childNodes[0])\n        }\n        maybeRevealExtraField()\n      }\n\n      const revealClozeWord = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        let range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundSpace = setRangeEnd(range, clozeHidden, \"beforeFirstSpace\")\n        if (!foundSpace) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        let fragment = range.extractContents()\n        cloze.insertBefore(fragment, clozeReplacer)\n        // Extract whitespaces after word\n        range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundWord = setRangeEnd(range, clozeHidden, \"beforeFirstChar\")\n        if (!foundWord) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        fragment = range.extractContents();\n        cloze.insertBefore(fragment, clozeReplacer)\n        if (!foundWord) {\n          cloze.removeChild(clozeHidden)\n          cloze.removeChild(clozeReplacer)\n          maybeRevealExtraField()\n          return\n        }\n        clozeReplacer.innerHTML = clozeHider(clozeHidden) + CLOZE_REPLACER_SEP\n        if (clozeReplacer.classList.contains(\"cloze-hint\")) [\n          clozeReplacer.classList.remove(\"cloze-hint\")\n        ]\n        maybeRevealExtraField()\n      }\n\n      const revealNextClozeOf = (type) => {\n        const nextHidden = document.querySelectorAll(\".cloze-hidden\")\n        const nextNextHidden = nextHidden.length > 1 ? true : false\n        if (!nextNextHidden) {\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\";\n        }\n        if (!nextHidden) {\n          return\n        }\n        const cloze = clozeElOfClozeHidden(nextHidden[0]);\n        if (type === \"word\") {\n          revealClozeWord(cloze)\n        } else if (type === \"cloze\") {\n          revealCloze(cloze)\n        } else {\n          console.error(\"Invalid type: \" + type)\n        }\n      }\n\n      const revealClozeClicked = function (ev) {\n        let elem = ev.currentTarget\n        if (!ev.altKey && (revealNextClozeMode !== \"word\")) {\n          revealCloze(elem)\n        } else {\n          revealClozeWord(elem)\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      }\n\n      window.revealNextCloze = function () {\n        revealNextClozeOf(revealNextClozeMode)\n      }\n\n      window.toggleAllCloze = function () {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length > 0) {\n          for (const elem of elems) {\n            const cloze = clozeElOfClozeHidden(elem)\n            revealCloze(cloze)\n          }\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\"\n        } else {\n          hideAllCloze(initial = false)\n        }\n      }\n\n      const clozeElOfClozeHidden = (cloze) => {\n        while (!cloze.classList.contains(\"cloze\")) {\n          cloze = cloze.parentElement;\n        }\n        return cloze;\n      }\n\n      const maybeRevealExtraField = () => {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length == 0) {\n          const extra = document.getElementById(\"extra\")\n          if (extra) {\n            extra.classList.remove(\"hidden\")\n          }\n\n          showExtra();\n          showExtraButtons();\n          document.documentElement.removeAttribute(\"onclick\")\n\n          // Also reveal autoReveal fields\n          for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n            const container = document.querySelector(`[data-name=\"${field}\"]`)\n            if (container) {\n              const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n              if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n                // const link = container.getElementsByTagName(\"a\")[0]\n                const button = container.getElementsByTagName(\"button\")[0]\n                const hint = container.getElementsByTagName(\"div\")[0]\n                button.classList.add(\"expanded-button\")\n                hint.style.display = \"block\"\n                // link.style.display = \"none\"\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * mode: 'beforeFirstSpace' or 'beforeFirstChar'\n       * Return `true` if it exists and setEnd() was called, otherwise `false`\n       */\n      const setRangeEnd = function (range, node, mode) {\n        if (node.nodeType === Node.TEXT_NODE) {\n          const regex = mode === 'beforeFirstSpace' ? /\\s/ : /\\S/\n          const match = node.textContent.match(regex)\n          if (match) {\n            if (match.index === 0) {\n              while (node.previousSibling === null) {\n                node = node.parentElement\n              }\n              range.setEndBefore(node)\n            } else {\n              range.setEnd(node, match.index);\n            }\n            return true;\n          } else {\n            return false;\n          }\n        } else if (mode === 'beforeFirstChar' && isCharNode(node)) {\n          range.setEndBefore(node)\n          return true\n        } else if (!ignoreSpaceInNode(node)) {\n          for (const child of node.childNodes) {\n            if (setRangeEnd(range, child, mode)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }\n\n      const ignoreSpaceInNode = function (node) {\n        return node.tagName === \"MJX-ASSISTIVE-MML\"\n      }\n\n      const isCharNode = function (node) {\n        return [\"IMG\", \"MJX-CONTAINER\"].includes(node.tagName)\n      }\n\n      hideAllCloze(initial = true)\n\n      let isShowNextShortcut = shortcutMatcher(window.revealNextShortcut)\n      let isShowWordShortcut = shortcutMatcher(window.revealNextWordShortcut)\n      let isToggleAllShortcut = shortcutMatcher(window.toggleAllShortcut)\n      ankingAddEventListener(\"keydown\", (ev) => {\n        let next = isShowNextShortcut(ev)\n        let word = isShowWordShortcut(ev)\n        let all = isToggleAllShortcut(ev)\n        if (next) {\n          revealNextClozeOf(\"cloze\")\n        } else if (word) {\n          revealNextClozeOf(\"word\")\n        } else if (all) {\n          toggleAllCloze()\n        } else {\n          return;\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      });\n    })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- MEDITRICKS SNIPPETS DATA -->\n<div id=\"meditricks-mtsp-values\" style=\"display:none;\">\n  <div id=\"meditricks-mtsp-nfname\">_meditricks_nf_v1000_ankizin</div>\n  <div id=\"meditricks-mtsp-nid\">{{Note ID}}</div>\n</div>\n<script src=\"_meditricks_mtsp_scripts_v1000_ankizin.js\"></script>\n<link href=\"_meditricks_mtsp_styles_v1000_ankizin.css\" rel=\"stylesheet\" />\n\n<!-- include \"_meditricks_mtsp_nf_v1000_ankizin.js\" -->\n<!-- include \"_meditricks_mtsp_scripts_v1000_iframe.map\" -->\n<!-- include \"_meditricks_mtsp_mtlogo.webp\" -->\n<!-- include \"_meditricks_mtsp_mt-loading.png\" -->\n<!-- include \"_meditricks_mtsp_mt-loading_night.png\" -->\n\n<!-- //MEDITRICKS SNIPPETS DATA -->\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>",
      "bqfmt": "{{Muskel / Leitungsbahn}}",
      "bafmt": "{{Verlauf}}",
      "bfont": "Helvetica",
      "bsize": 12
    },
    {
      "name": "FunktionCloze1",
      "ord": 15,
      "qfmt": "<!-- version f0935e4 -->\n{{#Funktion}}\n{{#FunktionCloze1}}\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TIMER CONFIG  ##############\n  // Timer config (timer length, timer finished message)\n  var minutes = 0\n  var seconds = 15\n  var timeOverMsg = \"<span style='color:#CC5B5B'>!!!</span>\"\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  // Auto flip to back when One by one mode.\n  var autoflip = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Was ist die <i>Funktion</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" data-card=\"{{Card}}\"><br>{{Funktion}}</div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\"></div>\n\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<script>\n  //DONT FADE BETWEEN CARDS\n  qFade = 0;\n  if (typeof anki !== 'undefined') anki.qFade = qFade;\n</script>\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    if (!indentation) { return; }\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- CLOZE ONE BY ONE FRONT -->\n<div id=\"one-by-one\" style=\"display: none;\"></div>\n\n<script>\n  /**\n   * Based on the AnKing Notetype, but expanded and modified by phyn.\n   * Credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  Persistence.clear();\n\n  // check if OneByOne is generally enabled for this card\n  var oneByOneFieldEmpty = selectiveOneByOne ? \"{{One by one}}\" === \"\" : true;\n  var clozeOneByOneEnabled = alwaysOneByOne ? true : !oneByOneFieldEmpty;\n\n  // avoid flickering. Must unset this in the back.\n  document.getElementById(\"qa\").style.display = \"none\";\n  var clozeHints = [];\n\n  if (clozeOneByOneEnabled) {\n    // collect hints from front side (independent of whether or not OneByOne is enabled)\n    document.getElementById(\"qa\").classList.add('one-by-one');\n    // Save cloze hints to display in the back\n    var clozes = document.getElementsByClassName(\"cloze\")\n    for (var i = 0; i < clozes.length; i++) {\n      clozes[i].classList.add(\"one-by-one\");\n      if (clozes[i].innerHTML === \"[...]\") {\n        clozeHints.push(\"\")\n      } else {\n        clozeHints.push(clozes[i].innerHTML)\n      }\n    }\n\n    // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n    /**\n     * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n     */\n    const getCardNumber = function () {\n      clz = document.body.className;\n      const regex = /card(\\d+)/gm;\n\n      let clz2;\n      try {\n        clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n      } catch (e) {\n        clz2 = \"\";\n      }\n      const regex2 = /.*?Cloze(\\d+)/gm;\n\n      let m;\n\n      if ((m = regex2.exec(clz2)) !== null) {\n        return m[1];\n      } else if ((m = regex.exec(clz)) !== null) {\n        return m[1];\n      } else {\n        // Should only fire if card is not cloze\n        console.error(\"Cannot find cardN class of body element!\");\n        return \"0\";\n      }\n    }\n\n    var alreadyRendered = false;\n\n    function processSelective1b1() {\n      if (alreadyRendered) return;\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (autoflip && clozeOneByOneEnabled) {\n        if (window.pycmd || window.showAnswer) {\n          // avoid flickering. Must unset this in the back.\n          document.getElementById(\"qa\").style.display = \"none\";\n        }\n        if (window.pycmd) {\n          pycmd(\"ans\")\n        } else if (window.showAnswer) {\n          showAnswer()\n        }\n      } else {\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n      }\n      // AnkiMobile JS API doesn't have one for show answer.\n      // Best alternative is to use Taps/Swipes to show answer.\n\n      alreadyRendered = true;\n    }\n\n    function delayedProcessSelective1b1() {\n      if (window.requestAnimationFrame) window.requestAnimationFrame(processSelective1b1); // less flickering\n      else window.setTimeout(processSelective1b1, 0);\n    };\n\n    window.onload = delayedProcessSelective1b1;\n    if (document.readyState === \"complete\") {\n      delayedProcessSelective1b1();\n    }\n    else {\n      document.addEventListener(\"DOMContentLoaded\", delayedProcessSelective1b1);\n    }\n\n    // Observe document.body class changes to trigger re-rendering.\n    // This is useful, because Anki doesn’t always start with an up-to-date class list:\n    // https://forums.ankiweb.net/t/card-card-classes-only-injected-separately-now/27387.\n    const observer = new MutationObserver(function (mutationsList, observer) {\n      for (let mutation of mutationsList) {\n        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {\n          delayedProcessSelective1b1();\n        }\n      }\n    });\n    observer.observe(document.body, { attributes: true });\n  }\n  Persistence.setItem(\"clozeHints\", clozeHints);\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>\n\n\n{{/FunktionCloze1}}\n{{/Funktion}}",
      "afmt": "<!-- version f0935e4 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n<div id=\"back\"></div>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Eigene Notizen & Bilder\": \"Alt + 1\",\n    \"Eigene Prüfungsfragen\": \"Alt + 2\",\n    \"Definitionen\": \"Alt + 3\",\n    \"Merksprüche\": \"Alt + 4\",\n    \"Klinik\": \"Alt + 5\",\n    \"Präparat\": \"Alt + 6\",\n    \"Memes\": \"Alt + 7\",\n    \"linkContainer\": \"Alt + L\",\n    \"Meditricks\": \"Alt + M\",\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Eigene Notizen & Bilder\": false,\n    \"Eigene Prüfungsfragen\": false,\n    \"Definitionen\": false,\n    \"Merksprüche\": false,\n    \"Klinik\": false,\n    \"Präparat\": false,\n    \"Memes\": false,\n    \"linkContainer\": true,\n    \"Meditricks\": false,\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  var revealNextShortcut = \"N\"\n  var revealNextWordShortcut = \"Shift + N\"\n  var toggleAllShortcut = \",\"\n\n  // Enables revealing of next Cloze by simply clicking / tapping anywhere on the card (except the buttons)\n  var revealAnywhere = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // Changes how \"Reveal Next\" and clicking behaves. Either \"cloze\" or \"word\".\n  // \"word\" reveals word by word. \n  var revealNextClozeMode = \"cloze\"\n\n  // Changes how fields with additional information are displayed.\n  // true displays fields with additional information only if all clozes are revealed.\n  var hideAdditional = true;\n  var hideAdditionalButtons = true;\n\n  // What cloze is hidden with\n  var clozeHider = (elem) => \"[&nbsp;_&nbsp;]\"\n  /*\n  You can replace the above line with below examples. '█' or '_' works well for hiding clozes.\n  \n  // Fixed length:\n  var clozeHider = (elem) => \"███\"\n  // Replace each character with \"█\":\n  var clozeHider = (elem) => \"█\".repeat(elem.textContent.length)\n  // Show whitespaces:\n  var clozeHider = (elem) => \"[\" + elem.textContent.split(\" \").map((t) => \"█\".repeat(t.length)).join(\" \") + \"]\"\n  // Color-filled box (doesn't hide images):\n  var clozeHider = (elem) => `<span style=\"background-color: red; color: transparent;\">${elem.innerHTML}</span>`\n  */\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Was ist die <i>Funktion</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" class=\"clozefield\" data-card=\"{{Card}}\"><br>{{Funktion}}</div>\n\n    <!-- ClOZE ONE BY ONE BUTTONS -->\n    <div id=\"onebyone-buttons\" class=\"onebyone\">\n      <br>\n      <button id=\"button-reveal-next\" class=\"button-general button-one-by-one\"\n        onclick=\"revealNextCloze(); event.stopPropagation()\">Reveal Next</button>\n      <button id=\"button-toggle-all\" class=\"button-general button-one-by-one\"\n        onclick=\"toggleAllCloze(); event.stopPropagation()\">Toggle All</button>\n    </div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- BUTTON FIELDS -->\n    {{#Eigene Notizen & Bilder}}\n    <span id=\"hint-zusatz\" class=\"hintBtn\" data-name=\"Eigene Notizen & Bilder\" style=\"display: none;\">\n      <button id=\"button-zusatz\" class=\"button-general\" onclick=\"toggleHintBtn('hint-zusatz'); event.stopPropagation()\">\n        <img src=\"__zusatz.svg\" style=\"height: 10px;\"> Eigene Notizen & Bilder\n      </button>\n      <div dir=\"auto\" id=\"zusatz\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Notizen & Bilder}}</div>\n    </span>\n    {{/Eigene Notizen & Bilder}}\n\n    {{#Eigene Prüfungsfragen}}\n    <span id=\"hint-hammer\" class=\"hintBtn\" data-name=\"Eigene Prüfungsfragen\" style=\"display: none;\">\n      <button id=\"button-hammer\" class=\"button-general\" onclick=\"toggleHintBtn('hint-hammer'); event.stopPropagation()\">\n        <img src=\"__hammer.svg\" style=\"height: 10px;\"> Eigene Prüfungsfragen\n      </button>\n      <div dir=\"auto\" id=\"hammer\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Prüfungsfragen}}</div>\n    </span>\n    {{/Eigene Prüfungsfragen}}\n\n    {{#Definitionen}}\n    <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Definitionen\" style=\"display: none;\">\n      <button id=\"button-definition\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Definitionen\n      </button>\n      <div dir=\"auto\" id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Definitionen}}</div>\n    </span>\n    {{/Definitionen}}\n\n    {{#Merksprüche}}\n    <span id=\"hint-merksprueche\" class=\"hintBtn\" data-name=\"Merksprüche\" style=\"display: none;\">\n      <button id=\"button-merksprueche\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-merksprueche'); event.stopPropagation()\">\n        <img src=\"__merkhilfe.svg\" style=\"height: 10px;\"> Merksprüche\n      </button>\n      <div dir=\"auto\" id=\"merksprueche\" class=\"hints\" style=\"display: none;\">{{edit:Merksprüche}}</div>\n    </span>\n    {{/Merksprüche}}\n\n    {{#Klinik}}\n    <span id=\"hint-klinik\" class=\"hintBtn\" data-name=\"Klinik\" style=\"display: none;\">\n      <button id=\"button-klinik\" class=\"button-general\" onclick=\"toggleHintBtn('hint-klinik'); event.stopPropagation()\">\n        <img src=\"__stethoscope.svg\" style=\"height: 10px;\"> Klinik\n      </button>\n      <div dir=\"auto\" id=\"klinik\" class=\"hints\" style=\"display: none;\">{{edit:Klinik}}</div>\n    </span>\n    {{/Klinik}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-praeparat\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n        </button>\n      </a>\n    </span>\n    {{/Präparat}}\n\n    {{#Virtuelle Mikroskopie}}\n    <span id=\"hint-microscope-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Virtuelle Mikroskopie}}\">\n        <button id=\"button-microscope\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Virtuelle Mikroskopie\n        </button>\n      </a>\n    </span>\n    {{/Virtuelle Mikroskopie}}\n\n    {{#Smart Zoom}}\n    <span id=\"hint-smartzoom-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-smartzoom\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Smart Zoom\n        </button>\n      </a>\n    </span>\n    {{/Smart Zoom}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat\" class=\"hintBtn\" data-name=\"Präparat\" style=\"display: none;\">\n      <button id=\"button-praeparat\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-praeparat'); event.stopPropagation()\">\n        <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n      </button>\n      <div dir=\"auto\" id=\"praeparat\" class=\"hints\" style=\"display: none;\">{{edit:Präparat}}</div>\n    </span>\n    {{/Präparat}}\n\n    {{#Memes}}\n    <span id=\"hint-memes\" class=\"hintBtn\" data-name=\"Memes\" style=\"display: none;\">\n      <button id=\"button-memes\" class=\"button-general\" onclick=\"toggleHintBtn('hint-memes'); event.stopPropagation()\">\n        <img src=\"__sonstiges.svg\" style=\"height: 10px;\"> Memes\n      </button>\n      <div dir=\"auto\" id=\"memes\" class=\"hints\" style=\"display: none;\">{{edit:Memes}}</div>\n    </span>\n    {{/Memes}}\n\n    <!-- LINEBREAKS IF BUTTONS EXIST -->\n    <script>\n      var array = [`{{Eigene Notizen & Bilder}}`, `{{Eigene Prüfungsfragen}}`, `{{Definitionen}}`, `{{Merksprüche}}`, `{{Klinik}}`, `{{Präparat}}`, `{{Memes}}`];\n      var anyistrue = (element) => element;\n      if (array.some(anyistrue)) {\n        document.getElementById(\"linebreaksIfButtons\").innerHTML = \"<br>\";\n      }\n    </script>\n    <div id=\"linebreaksIfButtons\"></div>\n\n    <!-- Extra field -->\n    {{#Extra}}\n    <div id=\"extra\" style=\"display: none;\">\n      <br>{{edit:Extra}}<br><br>\n    </div>\n    {{/Extra}}\n\n    <!-- Image field -->\n    {{#Bild}}\n    <div id=\"image\" style=\"display: none;\">\n      {{edit:Bild}}<br><br></div>\n    {{/Bild}}\n    {{^Bild}}\n    <span id=\"image\" style=\"display: none;\"></span>\n    {{/Bild}}\n    {{#Bild}}\n    <span id=\"hint-image\" style=\"display: none;\">\n      <button id=\"button-image\" class=\"button-general\"\n        onclick=\"var image = document.getElementById('image'); if (image.style.display == 'none') { image.style.display = 'block' } else { image.style.display = 'none' }; event.stopPropagation()\">\n        <img src=\"__image.svg\" style=\"height: 10px;\"> Abbildung\n      </button>\n    </span>\n    {{/Bild}}\n\n    <span id=\"hint-uafi\" class=\"hintBtn\" data-name=\"Ursprung, Ansatz, Verlauf, Funktion, Innervation, Äste\"\n      style=\"display: none;\">\n      <button id=\"button-uafi\" class=\"button-general expanded-button\"\n        onclick=\"toggleHintBtn('hint-uafi'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Weitere Informationen\n      </button>\n      <div id=\"uafi\" class=\"hints\" style=\"display: block;\">\n        <table class=\"uncloze\">\n          {{#Ursprung}}\n          <tr class=\"uafi-element\" id=\"Ursprung\">\n            <td><i>Ursprung</i></td>\n            <td>{{Ursprung}}</td>\n          </tr>\n          {{/Ursprung}}\n          {{#Ansatz}}\n          <tr class=\"uafi-element\" id=\"Ansatz\">\n            <td><i>Ansatz</i></td>\n            <td>{{Ansatz}}</td>\n          </tr>\n          {{/Ansatz}}\n          {{#Verlauf}}\n          <tr class=\"uafi-element\" id=\"Verlauf\">\n            <td><i>Verlauf</i></td>\n            <td>{{Verlauf}}</td>\n          </tr>\n          {{/Verlauf}}\n          {{#Funktion}}\n          <tr class=\"uafi-element\" id=\"Funktion\">\n            <td><i>Funktion</i></td>\n            <td>{{Funktion}}</td>\n          </tr>\n          {{/Funktion}}\n          {{#Innervation}}\n          <tr class=\"uafi-element\" id=\"Innervation\">\n            <td><i>Innervation</i></td>\n            <td>{{Innervation}}</td>\n          </tr>\n          {{/Innervation}}\n          {{#Äste}}\n          <tr class=\"uafi-element\" id=\"Äste\">\n            <td><i>Äste</i></td>\n            <td>{{Äste}}</td>\n          </tr>\n          {{/Äste}}\n        </table>\n      </div>\n\n      <script>\n        // iterate over all uafi-elements and hide only the one\n        // that is equal to the card's answer (i.e., value of {{Card}})\n        var uafiElements = document.getElementsByClassName(\"uafi-element\");\n        for (var i = 0; i < uafiElements.length; i++) {\n          if (((\"{{Card}}\").startsWith(uafiElements[i].id))) {\n            uafiElements[i].remove()\n          }\n        }\n      </script>\n    </span>\n\n    {{#AMBOSS-Link}}\n    <span id=\"hint-amboss\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:AMBOSS-Link}}\">\n        <button id=\"button-amboss\" class=\"button-general\">\n          <img src=\"__amboss.svg\" style=\"height: 10px;\"> AMBOSS&#8203;\n        </button>\n      </a>\n    </span>\n    {{/AMBOSS-Link}}\n\n    {{#Thieme via medici-Link}}\n    <span id=\"hint-thieme\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Thieme via medici-Link}}\">\n        <button id=\"button-thieme\" class=\"button-general\">\n          <img id=\"button-thieme-img\" src=\"__thieme-heart.svg\" style=\"height: 10px;\"> Thieme via medici\n        </button>\n      </a>\n    </span>\n    {{/Thieme via medici-Link}}\n\n    {{#Meditricks}}\n    <span id=\"hint-meditricks\" class=\"hintBtn\" data-name=\"Meditricks\" style=\"display: none;\">\n      <button id=\"button-meditricks\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-meditricks'); event.stopPropagation()\">\n        <img src=\"__meditricks.svg\" style=\"height: 10px;\"> Meditricks\n      </button>\n      <div dir=\"auto\" id=\"meditricks\" class=\"hints\" style=\"display: none;\">{{edit:Meditricks}}</div>\n    </span>\n    {{/Meditricks}}\n\n    {{#weitere Links}}\n    <span id=\"hint-linkcontainer\" class=\"hintBtn\" data-name=\"linkContainer\" style=\"display: none;\">\n      <button id=\"button-linkcontainer\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-linkcontainer'); event.stopPropagation()\">\n        <img src=\"__internet.svg\" style=\"height: 10px;\"> weitere Links\n      </button>\n      <div id=\"linkcontainer\" class=\"hints\" style=\"display: none;\"></div>\n      <span id=\"linkContainerLinks\" style=\"display: none;\">{{edit:weitere Links}}</span>\n    </span>\n    {{/weitere Links}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n  try {\n    for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n      href = link.href\n      text = link.innerText\n\n      const el = document.createElement('a');\n      el.setAttribute('href', link.href);\n\n      const btn = document.createElement('button');\n      btn.classList.add('button-general');\n      btn.classList.add('expanded-button');\n\n      domain = href.replace(/.+\\/\\/|(www|flexikon|register|de|next|com).|\\..+/g, '');\n      domainDict = {\n        \"amboss\": \"__amboss.svg\",\n        \"wikipedia\": \"__wikipedia.svg\",\n        \"doccheck\": \"__doccheck.png\",\n        \"notfallguru\": \"__notfallguru.svg\",\n        \"awmf\": \"__awmf.svg\",\n        \"gelbe-liste\": \"__gelbe-liste.png\",\n        \"embryotox\": \"__embryotox.svg\",\n        \"radiopaedia\": \"__radiopaedia.png\",\n        \"orphanet\": \"__orphanet.png\",\n      }\n      if (domain in domainDict) {\n        icon = domainDict[domain]\n      } else {\n        icon = \"__internet.svg\"\n      }\n\n      const img = document.createElement('img');\n      img.setAttribute('src', icon);\n      img.setAttribute('style', 'height: 10px;');\n\n      btn.appendChild(img);\n      btn.innerHTML = btn.innerHTML + \" \" + text;\n\n      el.appendChild(btn);\n\n      document.getElementById(\"linkcontainer\").appendChild(el)\n    }\n  }\n  catch (err) {\n    console.log(err)\n  }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-uafi\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- AUTOFLIP BACK SCRIPT -->\n<script>\n  // autoflip hides card in front template\n  document.getElementById(\"qa\").style.removeProperty(\"display\")\n</script>\n\n<!-- CLOZE ONE BY ONE SCRIPT -->\n<style>\n  .cloze-replacer:hover {\n    cursor: pointer;\n  }\n\n  .cloze-hidden {\n    display: none;\n  }\n\n  .cloze-replacer .hidden {\n    display: none;\n  }\n\n  #extra.hidden {\n    display: none;\n  }\n</style>\n\n<!--\n Based on the AnKing Notetype, but expanded and modified by phyn.\n Credit to the original authors, except where modified or otherwise indicated.\n-->\n\n<script>\n    (function () {\n      // enables cloze one-by-one even when one-by-one field is empty\n      // minNumberOfClozes is still considered in this case\n      // overridden in importance by selectiveOneByOne\n      var clozeOneByOneEnabled = true;\n\n      // remove the clickAnywhere function from global scope\n      document.documentElement.removeAttribute(\"onclick\")\n\n      // --- CHECK IF ONE BY ONE IS GENERALLY ENABLED FOR THIS NOTE ---\n      var oneByOneFieldNotEmpty = \"{{One by one}}\" !== \"\";\n      try {\n        clozeOneByOneEnabled = alwaysOneByOne || oneByOneFieldNotEmpty;\n      } catch (exception) {\n        console.log(exception)\n      }\n\n      /**\n   * helper functions to show / hide fields containing additional information\n   */\n      const showExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const hideExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const buttonIds = [\n        \"hint-zusatz\",\n        \"hint-definition\",\n        \"hint-hammer\",\n        \"hint-klinik\",\n        \"hint-praeparat\",\n        \"hint-microscope\",\n        \"hint-smartzoom\",\n        \"hint-histotrainer\",\n        \"hint-uafi\",\n        \"hint-merksprueche\",\n        \"hint-memes\",\n        \"hint-image\",\n        \"hint-amboss\",\n        \"hint-thieme\",\n        \"hint-meditricks\",\n        \"hint-linkcontainer\",\n      ];\n\n      const showExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document\n              .getElementById(buttonIds[button])\n              .style.removeProperty(\"display\");\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n      const hideExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document.getElementById(buttonIds[button]).style.display = \"none\";\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n\n      // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n      /**\n       * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n       */\n      const getCardNumber = function () {\n        clz = document.body.className;\n        const regex = /card(\\d+)/gm;\n\n        let clz2;\n        try {\n          clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n        } catch (e) {\n          clz2 = \"\";\n        }\n        const regex2 = /.*?Cloze(\\d+)/gm;\n\n        let m;\n\n        if ((m = regex2.exec(clz2)) !== null) {\n          return m[1];\n        } else if ((m = regex.exec(clz)) !== null) {\n          return m[1];\n        } else {\n          // Should only fire if card is not cloze\n          console.error(\"Cannot find cardN class of body element!\");\n          return \"0\";\n        }\n      }\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (!clozeOneByOneEnabled) {\n        showExtra()\n        showExtraButtons()\n        document.getElementById(\"onebyone-buttons\").style.display = \"none\"\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n        return\n      }\n\n      // Needed for amboss to recognize first word in .cloze-hidden\n      const CLOZE_REPLACER_SEP = \"<span class='hidden'> </span>\"\n\n      const hideAllCloze = function (initial) {\n        let clozes = document.getElementsByClassName(\"cloze\")\n        let count = 0 // hidden cloze count\n        for (const cloze of clozes) {\n          const existingHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n          if (existingHidden) {\n            revealCloze(cloze);\n          }\n          if (cloze.offsetWidth === 0) {\n            continue\n          }\n          const clozeReplacer = document.createElement(\"span\")\n          const clozeHidden = document.createElement(\"span\")\n          clozeReplacer.classList.add(\"cloze-replacer\")\n          clozeHidden.classList.add(\"cloze-hidden\")\n          while (cloze.childNodes.length > 0) {\n            clozeHidden.appendChild(cloze.childNodes[0])\n          }\n          cloze.appendChild(clozeReplacer)\n          cloze.appendChild(clozeHidden)\n\n          var clozeHints = Persistence.getItem(\"clozeHints\");\n          if (clozeHints && clozeHints[count]) {\n            clozeReplacer.classList.add(\"cloze-hint\")\n            clozeReplacer.innerHTML = clozeHints[count] + CLOZE_REPLACER_SEP\n          } else {\n            clozeReplacer.innerHTML = clozeHider(cloze) + CLOZE_REPLACER_SEP\n          }\n          count += 1\n          document.getElementById(\"button-reveal-next\").style.display = \"inline-block\";\n          if (initial) {\n            cloze.addEventListener(\"touchend\", revealClozeClicked)\n            cloze.addEventListener(\"click\", revealClozeClicked)\n            cloze.classList.add(\"one-by-one\");\n          }\n        }\n\n        // Hide #extra until all clozes are shown\n        const extra = document.getElementById(\"extra\");\n        if (extra) {\n          extra.classList.add(\"hidden\");\n        }\n\n        hideExtra();\n        hideExtraButtons();\n        if (revealAnywhere) {\n          document.documentElement.setAttribute(\"onclick\", \"revealNextCloze(); event.stopPropagation()\")\n        }\n\n\n        // Also hide autoReveal fields\n        for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n          const container = document.querySelector(`[data-name=\"${field}\"]`)\n          if (container) {\n            const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n            if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n              // const link = container.getElementsByTagName(\"a\")[0]\n              const button = container.getElementsByTagName(\"button\")[0]\n              const hint = container.getElementsByTagName(\"div\")[0]\n              button.classList.remove(\"expanded-button\")\n              hint.style.display = \"none\"\n              // link.style.display = \"\"\n            }\n          }\n        }\n      }\n\n      const revealCloze = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        cloze.removeChild(clozeReplacer)\n        cloze.removeChild(clozeHidden)\n        while (clozeHidden.childNodes.length > 0) {\n          cloze.appendChild(clozeHidden.childNodes[0])\n        }\n        maybeRevealExtraField()\n      }\n\n      const revealClozeWord = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        let range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundSpace = setRangeEnd(range, clozeHidden, \"beforeFirstSpace\")\n        if (!foundSpace) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        let fragment = range.extractContents()\n        cloze.insertBefore(fragment, clozeReplacer)\n        // Extract whitespaces after word\n        range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundWord = setRangeEnd(range, clozeHidden, \"beforeFirstChar\")\n        if (!foundWord) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        fragment = range.extractContents();\n        cloze.insertBefore(fragment, clozeReplacer)\n        if (!foundWord) {\n          cloze.removeChild(clozeHidden)\n          cloze.removeChild(clozeReplacer)\n          maybeRevealExtraField()\n          return\n        }\n        clozeReplacer.innerHTML = clozeHider(clozeHidden) + CLOZE_REPLACER_SEP\n        if (clozeReplacer.classList.contains(\"cloze-hint\")) [\n          clozeReplacer.classList.remove(\"cloze-hint\")\n        ]\n        maybeRevealExtraField()\n      }\n\n      const revealNextClozeOf = (type) => {\n        const nextHidden = document.querySelectorAll(\".cloze-hidden\")\n        const nextNextHidden = nextHidden.length > 1 ? true : false\n        if (!nextNextHidden) {\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\";\n        }\n        if (!nextHidden) {\n          return\n        }\n        const cloze = clozeElOfClozeHidden(nextHidden[0]);\n        if (type === \"word\") {\n          revealClozeWord(cloze)\n        } else if (type === \"cloze\") {\n          revealCloze(cloze)\n        } else {\n          console.error(\"Invalid type: \" + type)\n        }\n      }\n\n      const revealClozeClicked = function (ev) {\n        let elem = ev.currentTarget\n        if (!ev.altKey && (revealNextClozeMode !== \"word\")) {\n          revealCloze(elem)\n        } else {\n          revealClozeWord(elem)\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      }\n\n      window.revealNextCloze = function () {\n        revealNextClozeOf(revealNextClozeMode)\n      }\n\n      window.toggleAllCloze = function () {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length > 0) {\n          for (const elem of elems) {\n            const cloze = clozeElOfClozeHidden(elem)\n            revealCloze(cloze)\n          }\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\"\n        } else {\n          hideAllCloze(initial = false)\n        }\n      }\n\n      const clozeElOfClozeHidden = (cloze) => {\n        while (!cloze.classList.contains(\"cloze\")) {\n          cloze = cloze.parentElement;\n        }\n        return cloze;\n      }\n\n      const maybeRevealExtraField = () => {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length == 0) {\n          const extra = document.getElementById(\"extra\")\n          if (extra) {\n            extra.classList.remove(\"hidden\")\n          }\n\n          showExtra();\n          showExtraButtons();\n          document.documentElement.removeAttribute(\"onclick\")\n\n          // Also reveal autoReveal fields\n          for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n            const container = document.querySelector(`[data-name=\"${field}\"]`)\n            if (container) {\n              const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n              if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n                // const link = container.getElementsByTagName(\"a\")[0]\n                const button = container.getElementsByTagName(\"button\")[0]\n                const hint = container.getElementsByTagName(\"div\")[0]\n                button.classList.add(\"expanded-button\")\n                hint.style.display = \"block\"\n                // link.style.display = \"none\"\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * mode: 'beforeFirstSpace' or 'beforeFirstChar'\n       * Return `true` if it exists and setEnd() was called, otherwise `false`\n       */\n      const setRangeEnd = function (range, node, mode) {\n        if (node.nodeType === Node.TEXT_NODE) {\n          const regex = mode === 'beforeFirstSpace' ? /\\s/ : /\\S/\n          const match = node.textContent.match(regex)\n          if (match) {\n            if (match.index === 0) {\n              while (node.previousSibling === null) {\n                node = node.parentElement\n              }\n              range.setEndBefore(node)\n            } else {\n              range.setEnd(node, match.index);\n            }\n            return true;\n          } else {\n            return false;\n          }\n        } else if (mode === 'beforeFirstChar' && isCharNode(node)) {\n          range.setEndBefore(node)\n          return true\n        } else if (!ignoreSpaceInNode(node)) {\n          for (const child of node.childNodes) {\n            if (setRangeEnd(range, child, mode)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }\n\n      const ignoreSpaceInNode = function (node) {\n        return node.tagName === \"MJX-ASSISTIVE-MML\"\n      }\n\n      const isCharNode = function (node) {\n        return [\"IMG\", \"MJX-CONTAINER\"].includes(node.tagName)\n      }\n\n      hideAllCloze(initial = true)\n\n      let isShowNextShortcut = shortcutMatcher(window.revealNextShortcut)\n      let isShowWordShortcut = shortcutMatcher(window.revealNextWordShortcut)\n      let isToggleAllShortcut = shortcutMatcher(window.toggleAllShortcut)\n      ankingAddEventListener(\"keydown\", (ev) => {\n        let next = isShowNextShortcut(ev)\n        let word = isShowWordShortcut(ev)\n        let all = isToggleAllShortcut(ev)\n        if (next) {\n          revealNextClozeOf(\"cloze\")\n        } else if (word) {\n          revealNextClozeOf(\"word\")\n        } else if (all) {\n          toggleAllCloze()\n        } else {\n          return;\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      });\n    })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- MEDITRICKS SNIPPETS DATA -->\n<div id=\"meditricks-mtsp-values\" style=\"display:none;\">\n  <div id=\"meditricks-mtsp-nfname\">_meditricks_nf_v1000_ankizin</div>\n  <div id=\"meditricks-mtsp-nid\">{{Note ID}}</div>\n</div>\n<script src=\"_meditricks_mtsp_scripts_v1000_ankizin.js\"></script>\n<link href=\"_meditricks_mtsp_styles_v1000_ankizin.css\" rel=\"stylesheet\" />\n\n<!-- include \"_meditricks_mtsp_nf_v1000_ankizin.js\" -->\n<!-- include \"_meditricks_mtsp_scripts_v1000_iframe.map\" -->\n<!-- include \"_meditricks_mtsp_mtlogo.webp\" -->\n<!-- include \"_meditricks_mtsp_mt-loading.png\" -->\n<!-- include \"_meditricks_mtsp_mt-loading_night.png\" -->\n\n<!-- //MEDITRICKS SNIPPETS DATA -->\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>",
      "bqfmt": "{{Muskel / Leitungsbahn}}",
      "bafmt": "{{Funktion}}",
      "bfont": "Helvetica",
      "bsize": 12
    },
    {
      "name": "FunktionCloze2",
      "ord": 16,
      "qfmt": "<!-- version f0935e4 -->\n{{#Funktion}}\n{{#FunktionCloze2}}\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TIMER CONFIG  ##############\n  // Timer config (timer length, timer finished message)\n  var minutes = 0\n  var seconds = 15\n  var timeOverMsg = \"<span style='color:#CC5B5B'>!!!</span>\"\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  // Auto flip to back when One by one mode.\n  var autoflip = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Was ist die <i>Funktion</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" data-card=\"{{Card}}\"><br>{{Funktion}}</div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\"></div>\n\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<script>\n  //DONT FADE BETWEEN CARDS\n  qFade = 0;\n  if (typeof anki !== 'undefined') anki.qFade = qFade;\n</script>\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    if (!indentation) { return; }\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- CLOZE ONE BY ONE FRONT -->\n<div id=\"one-by-one\" style=\"display: none;\"></div>\n\n<script>\n  /**\n   * Based on the AnKing Notetype, but expanded and modified by phyn.\n   * Credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  Persistence.clear();\n\n  // check if OneByOne is generally enabled for this card\n  var oneByOneFieldEmpty = selectiveOneByOne ? \"{{One by one}}\" === \"\" : true;\n  var clozeOneByOneEnabled = alwaysOneByOne ? true : !oneByOneFieldEmpty;\n\n  // avoid flickering. Must unset this in the back.\n  document.getElementById(\"qa\").style.display = \"none\";\n  var clozeHints = [];\n\n  if (clozeOneByOneEnabled) {\n    // collect hints from front side (independent of whether or not OneByOne is enabled)\n    document.getElementById(\"qa\").classList.add('one-by-one');\n    // Save cloze hints to display in the back\n    var clozes = document.getElementsByClassName(\"cloze\")\n    for (var i = 0; i < clozes.length; i++) {\n      clozes[i].classList.add(\"one-by-one\");\n      if (clozes[i].innerHTML === \"[...]\") {\n        clozeHints.push(\"\")\n      } else {\n        clozeHints.push(clozes[i].innerHTML)\n      }\n    }\n\n    // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n    /**\n     * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n     */\n    const getCardNumber = function () {\n      clz = document.body.className;\n      const regex = /card(\\d+)/gm;\n\n      let clz2;\n      try {\n        clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n      } catch (e) {\n        clz2 = \"\";\n      }\n      const regex2 = /.*?Cloze(\\d+)/gm;\n\n      let m;\n\n      if ((m = regex2.exec(clz2)) !== null) {\n        return m[1];\n      } else if ((m = regex.exec(clz)) !== null) {\n        return m[1];\n      } else {\n        // Should only fire if card is not cloze\n        console.error(\"Cannot find cardN class of body element!\");\n        return \"0\";\n      }\n    }\n\n    var alreadyRendered = false;\n\n    function processSelective1b1() {\n      if (alreadyRendered) return;\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (autoflip && clozeOneByOneEnabled) {\n        if (window.pycmd || window.showAnswer) {\n          // avoid flickering. Must unset this in the back.\n          document.getElementById(\"qa\").style.display = \"none\";\n        }\n        if (window.pycmd) {\n          pycmd(\"ans\")\n        } else if (window.showAnswer) {\n          showAnswer()\n        }\n      } else {\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n      }\n      // AnkiMobile JS API doesn't have one for show answer.\n      // Best alternative is to use Taps/Swipes to show answer.\n\n      alreadyRendered = true;\n    }\n\n    function delayedProcessSelective1b1() {\n      if (window.requestAnimationFrame) window.requestAnimationFrame(processSelective1b1); // less flickering\n      else window.setTimeout(processSelective1b1, 0);\n    };\n\n    window.onload = delayedProcessSelective1b1;\n    if (document.readyState === \"complete\") {\n      delayedProcessSelective1b1();\n    }\n    else {\n      document.addEventListener(\"DOMContentLoaded\", delayedProcessSelective1b1);\n    }\n\n    // Observe document.body class changes to trigger re-rendering.\n    // This is useful, because Anki doesn’t always start with an up-to-date class list:\n    // https://forums.ankiweb.net/t/card-card-classes-only-injected-separately-now/27387.\n    const observer = new MutationObserver(function (mutationsList, observer) {\n      for (let mutation of mutationsList) {\n        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {\n          delayedProcessSelective1b1();\n        }\n      }\n    });\n    observer.observe(document.body, { attributes: true });\n  }\n  Persistence.setItem(\"clozeHints\", clozeHints);\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>\n\n\n{{/FunktionCloze2}}\n{{/Funktion}}",
      "afmt": "<!-- version f0935e4 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n<div id=\"back\"></div>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Eigene Notizen & Bilder\": \"Alt + 1\",\n    \"Eigene Prüfungsfragen\": \"Alt + 2\",\n    \"Definitionen\": \"Alt + 3\",\n    \"Merksprüche\": \"Alt + 4\",\n    \"Klinik\": \"Alt + 5\",\n    \"Präparat\": \"Alt + 6\",\n    \"Memes\": \"Alt + 7\",\n    \"linkContainer\": \"Alt + L\",\n    \"Meditricks\": \"Alt + M\",\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Eigene Notizen & Bilder\": false,\n    \"Eigene Prüfungsfragen\": false,\n    \"Definitionen\": false,\n    \"Merksprüche\": false,\n    \"Klinik\": false,\n    \"Präparat\": false,\n    \"Memes\": false,\n    \"linkContainer\": true,\n    \"Meditricks\": false,\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  var revealNextShortcut = \"N\"\n  var revealNextWordShortcut = \"Shift + N\"\n  var toggleAllShortcut = \",\"\n\n  // Enables revealing of next Cloze by simply clicking / tapping anywhere on the card (except the buttons)\n  var revealAnywhere = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // Changes how \"Reveal Next\" and clicking behaves. Either \"cloze\" or \"word\".\n  // \"word\" reveals word by word. \n  var revealNextClozeMode = \"cloze\"\n\n  // Changes how fields with additional information are displayed.\n  // true displays fields with additional information only if all clozes are revealed.\n  var hideAdditional = true;\n  var hideAdditionalButtons = true;\n\n  // What cloze is hidden with\n  var clozeHider = (elem) => \"[&nbsp;_&nbsp;]\"\n  /*\n  You can replace the above line with below examples. '█' or '_' works well for hiding clozes.\n  \n  // Fixed length:\n  var clozeHider = (elem) => \"███\"\n  // Replace each character with \"█\":\n  var clozeHider = (elem) => \"█\".repeat(elem.textContent.length)\n  // Show whitespaces:\n  var clozeHider = (elem) => \"[\" + elem.textContent.split(\" \").map((t) => \"█\".repeat(t.length)).join(\" \") + \"]\"\n  // Color-filled box (doesn't hide images):\n  var clozeHider = (elem) => `<span style=\"background-color: red; color: transparent;\">${elem.innerHTML}</span>`\n  */\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Was ist die <i>Funktion</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" class=\"clozefield\" data-card=\"{{Card}}\"><br>{{Funktion}}</div>\n\n    <!-- ClOZE ONE BY ONE BUTTONS -->\n    <div id=\"onebyone-buttons\" class=\"onebyone\">\n      <br>\n      <button id=\"button-reveal-next\" class=\"button-general button-one-by-one\"\n        onclick=\"revealNextCloze(); event.stopPropagation()\">Reveal Next</button>\n      <button id=\"button-toggle-all\" class=\"button-general button-one-by-one\"\n        onclick=\"toggleAllCloze(); event.stopPropagation()\">Toggle All</button>\n    </div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- BUTTON FIELDS -->\n    {{#Eigene Notizen & Bilder}}\n    <span id=\"hint-zusatz\" class=\"hintBtn\" data-name=\"Eigene Notizen & Bilder\" style=\"display: none;\">\n      <button id=\"button-zusatz\" class=\"button-general\" onclick=\"toggleHintBtn('hint-zusatz'); event.stopPropagation()\">\n        <img src=\"__zusatz.svg\" style=\"height: 10px;\"> Eigene Notizen & Bilder\n      </button>\n      <div dir=\"auto\" id=\"zusatz\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Notizen & Bilder}}</div>\n    </span>\n    {{/Eigene Notizen & Bilder}}\n\n    {{#Eigene Prüfungsfragen}}\n    <span id=\"hint-hammer\" class=\"hintBtn\" data-name=\"Eigene Prüfungsfragen\" style=\"display: none;\">\n      <button id=\"button-hammer\" class=\"button-general\" onclick=\"toggleHintBtn('hint-hammer'); event.stopPropagation()\">\n        <img src=\"__hammer.svg\" style=\"height: 10px;\"> Eigene Prüfungsfragen\n      </button>\n      <div dir=\"auto\" id=\"hammer\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Prüfungsfragen}}</div>\n    </span>\n    {{/Eigene Prüfungsfragen}}\n\n    {{#Definitionen}}\n    <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Definitionen\" style=\"display: none;\">\n      <button id=\"button-definition\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Definitionen\n      </button>\n      <div dir=\"auto\" id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Definitionen}}</div>\n    </span>\n    {{/Definitionen}}\n\n    {{#Merksprüche}}\n    <span id=\"hint-merksprueche\" class=\"hintBtn\" data-name=\"Merksprüche\" style=\"display: none;\">\n      <button id=\"button-merksprueche\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-merksprueche'); event.stopPropagation()\">\n        <img src=\"__merkhilfe.svg\" style=\"height: 10px;\"> Merksprüche\n      </button>\n      <div dir=\"auto\" id=\"merksprueche\" class=\"hints\" style=\"display: none;\">{{edit:Merksprüche}}</div>\n    </span>\n    {{/Merksprüche}}\n\n    {{#Klinik}}\n    <span id=\"hint-klinik\" class=\"hintBtn\" data-name=\"Klinik\" style=\"display: none;\">\n      <button id=\"button-klinik\" class=\"button-general\" onclick=\"toggleHintBtn('hint-klinik'); event.stopPropagation()\">\n        <img src=\"__stethoscope.svg\" style=\"height: 10px;\"> Klinik\n      </button>\n      <div dir=\"auto\" id=\"klinik\" class=\"hints\" style=\"display: none;\">{{edit:Klinik}}</div>\n    </span>\n    {{/Klinik}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-praeparat\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n        </button>\n      </a>\n    </span>\n    {{/Präparat}}\n\n    {{#Virtuelle Mikroskopie}}\n    <span id=\"hint-microscope-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Virtuelle Mikroskopie}}\">\n        <button id=\"button-microscope\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Virtuelle Mikroskopie\n        </button>\n      </a>\n    </span>\n    {{/Virtuelle Mikroskopie}}\n\n    {{#Smart Zoom}}\n    <span id=\"hint-smartzoom-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-smartzoom\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Smart Zoom\n        </button>\n      </a>\n    </span>\n    {{/Smart Zoom}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat\" class=\"hintBtn\" data-name=\"Präparat\" style=\"display: none;\">\n      <button id=\"button-praeparat\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-praeparat'); event.stopPropagation()\">\n        <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n      </button>\n      <div dir=\"auto\" id=\"praeparat\" class=\"hints\" style=\"display: none;\">{{edit:Präparat}}</div>\n    </span>\n    {{/Präparat}}\n\n    {{#Memes}}\n    <span id=\"hint-memes\" class=\"hintBtn\" data-name=\"Memes\" style=\"display: none;\">\n      <button id=\"button-memes\" class=\"button-general\" onclick=\"toggleHintBtn('hint-memes'); event.stopPropagation()\">\n        <img src=\"__sonstiges.svg\" style=\"height: 10px;\"> Memes\n      </button>\n      <div dir=\"auto\" id=\"memes\" class=\"hints\" style=\"display: none;\">{{edit:Memes}}</div>\n    </span>\n    {{/Memes}}\n\n    <!-- LINEBREAKS IF BUTTONS EXIST -->\n    <script>\n      var array = [`{{Eigene Notizen & Bilder}}`, `{{Eigene Prüfungsfragen}}`, `{{Definitionen}}`, `{{Merksprüche}}`, `{{Klinik}}`, `{{Präparat}}`, `{{Memes}}`];\n      var anyistrue = (element) => element;\n      if (array.some(anyistrue)) {\n        document.getElementById(\"linebreaksIfButtons\").innerHTML = \"<br>\";\n      }\n    </script>\n    <div id=\"linebreaksIfButtons\"></div>\n\n    <!-- Extra field -->\n    {{#Extra}}\n    <div id=\"extra\" style=\"display: none;\">\n      <br>{{edit:Extra}}<br><br>\n    </div>\n    {{/Extra}}\n\n    <!-- Image field -->\n    {{#Bild}}\n    <div id=\"image\" style=\"display: none;\">\n      {{edit:Bild}}<br><br></div>\n    {{/Bild}}\n    {{^Bild}}\n    <span id=\"image\" style=\"display: none;\"></span>\n    {{/Bild}}\n    {{#Bild}}\n    <span id=\"hint-image\" style=\"display: none;\">\n      <button id=\"button-image\" class=\"button-general\"\n        onclick=\"var image = document.getElementById('image'); if (image.style.display == 'none') { image.style.display = 'block' } else { image.style.display = 'none' }; event.stopPropagation()\">\n        <img src=\"__image.svg\" style=\"height: 10px;\"> Abbildung\n      </button>\n    </span>\n    {{/Bild}}\n\n    <span id=\"hint-uafi\" class=\"hintBtn\" data-name=\"Ursprung, Ansatz, Verlauf, Funktion, Innervation, Äste\"\n      style=\"display: none;\">\n      <button id=\"button-uafi\" class=\"button-general expanded-button\"\n        onclick=\"toggleHintBtn('hint-uafi'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Weitere Informationen\n      </button>\n      <div id=\"uafi\" class=\"hints\" style=\"display: block;\">\n        <table class=\"uncloze\">\n          {{#Ursprung}}\n          <tr class=\"uafi-element\" id=\"Ursprung\">\n            <td><i>Ursprung</i></td>\n            <td>{{Ursprung}}</td>\n          </tr>\n          {{/Ursprung}}\n          {{#Ansatz}}\n          <tr class=\"uafi-element\" id=\"Ansatz\">\n            <td><i>Ansatz</i></td>\n            <td>{{Ansatz}}</td>\n          </tr>\n          {{/Ansatz}}\n          {{#Verlauf}}\n          <tr class=\"uafi-element\" id=\"Verlauf\">\n            <td><i>Verlauf</i></td>\n            <td>{{Verlauf}}</td>\n          </tr>\n          {{/Verlauf}}\n          {{#Funktion}}\n          <tr class=\"uafi-element\" id=\"Funktion\">\n            <td><i>Funktion</i></td>\n            <td>{{Funktion}}</td>\n          </tr>\n          {{/Funktion}}\n          {{#Innervation}}\n          <tr class=\"uafi-element\" id=\"Innervation\">\n            <td><i>Innervation</i></td>\n            <td>{{Innervation}}</td>\n          </tr>\n          {{/Innervation}}\n          {{#Äste}}\n          <tr class=\"uafi-element\" id=\"Äste\">\n            <td><i>Äste</i></td>\n            <td>{{Äste}}</td>\n          </tr>\n          {{/Äste}}\n        </table>\n      </div>\n\n      <script>\n        // iterate over all uafi-elements and hide only the one\n        // that is equal to the card's answer (i.e., value of {{Card}})\n        var uafiElements = document.getElementsByClassName(\"uafi-element\");\n        for (var i = 0; i < uafiElements.length; i++) {\n          if (((\"{{Card}}\").startsWith(uafiElements[i].id))) {\n            uafiElements[i].remove()\n          }\n        }\n      </script>\n    </span>\n\n    {{#AMBOSS-Link}}\n    <span id=\"hint-amboss\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:AMBOSS-Link}}\">\n        <button id=\"button-amboss\" class=\"button-general\">\n          <img src=\"__amboss.svg\" style=\"height: 10px;\"> AMBOSS&#8203;\n        </button>\n      </a>\n    </span>\n    {{/AMBOSS-Link}}\n\n    {{#Thieme via medici-Link}}\n    <span id=\"hint-thieme\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Thieme via medici-Link}}\">\n        <button id=\"button-thieme\" class=\"button-general\">\n          <img id=\"button-thieme-img\" src=\"__thieme-heart.svg\" style=\"height: 10px;\"> Thieme via medici\n        </button>\n      </a>\n    </span>\n    {{/Thieme via medici-Link}}\n\n    {{#Meditricks}}\n    <span id=\"hint-meditricks\" class=\"hintBtn\" data-name=\"Meditricks\" style=\"display: none;\">\n      <button id=\"button-meditricks\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-meditricks'); event.stopPropagation()\">\n        <img src=\"__meditricks.svg\" style=\"height: 10px;\"> Meditricks\n      </button>\n      <div dir=\"auto\" id=\"meditricks\" class=\"hints\" style=\"display: none;\">{{edit:Meditricks}}</div>\n    </span>\n    {{/Meditricks}}\n\n    {{#weitere Links}}\n    <span id=\"hint-linkcontainer\" class=\"hintBtn\" data-name=\"linkContainer\" style=\"display: none;\">\n      <button id=\"button-linkcontainer\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-linkcontainer'); event.stopPropagation()\">\n        <img src=\"__internet.svg\" style=\"height: 10px;\"> weitere Links\n      </button>\n      <div id=\"linkcontainer\" class=\"hints\" style=\"display: none;\"></div>\n      <span id=\"linkContainerLinks\" style=\"display: none;\">{{edit:weitere Links}}</span>\n    </span>\n    {{/weitere Links}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n  try {\n    for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n      href = link.href\n      text = link.innerText\n\n      const el = document.createElement('a');\n      el.setAttribute('href', link.href);\n\n      const btn = document.createElement('button');\n      btn.classList.add('button-general');\n      btn.classList.add('expanded-button');\n\n      domain = href.replace(/.+\\/\\/|(www|flexikon|register|de|next|com).|\\..+/g, '');\n      domainDict = {\n        \"amboss\": \"__amboss.svg\",\n        \"wikipedia\": \"__wikipedia.svg\",\n        \"doccheck\": \"__doccheck.png\",\n        \"notfallguru\": \"__notfallguru.svg\",\n        \"awmf\": \"__awmf.svg\",\n        \"gelbe-liste\": \"__gelbe-liste.png\",\n        \"embryotox\": \"__embryotox.svg\",\n        \"radiopaedia\": \"__radiopaedia.png\",\n        \"orphanet\": \"__orphanet.png\",\n      }\n      if (domain in domainDict) {\n        icon = domainDict[domain]\n      } else {\n        icon = \"__internet.svg\"\n      }\n\n      const img = document.createElement('img');\n      img.setAttribute('src', icon);\n      img.setAttribute('style', 'height: 10px;');\n\n      btn.appendChild(img);\n      btn.innerHTML = btn.innerHTML + \" \" + text;\n\n      el.appendChild(btn);\n\n      document.getElementById(\"linkcontainer\").appendChild(el)\n    }\n  }\n  catch (err) {\n    console.log(err)\n  }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-uafi\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- AUTOFLIP BACK SCRIPT -->\n<script>\n  // autoflip hides card in front template\n  document.getElementById(\"qa\").style.removeProperty(\"display\")\n</script>\n\n<!-- CLOZE ONE BY ONE SCRIPT -->\n<style>\n  .cloze-replacer:hover {\n    cursor: pointer;\n  }\n\n  .cloze-hidden {\n    display: none;\n  }\n\n  .cloze-replacer .hidden {\n    display: none;\n  }\n\n  #extra.hidden {\n    display: none;\n  }\n</style>\n\n<!--\n Based on the AnKing Notetype, but expanded and modified by phyn.\n Credit to the original authors, except where modified or otherwise indicated.\n-->\n\n<script>\n    (function () {\n      // enables cloze one-by-one even when one-by-one field is empty\n      // minNumberOfClozes is still considered in this case\n      // overridden in importance by selectiveOneByOne\n      var clozeOneByOneEnabled = true;\n\n      // remove the clickAnywhere function from global scope\n      document.documentElement.removeAttribute(\"onclick\")\n\n      // --- CHECK IF ONE BY ONE IS GENERALLY ENABLED FOR THIS NOTE ---\n      var oneByOneFieldNotEmpty = \"{{One by one}}\" !== \"\";\n      try {\n        clozeOneByOneEnabled = alwaysOneByOne || oneByOneFieldNotEmpty;\n      } catch (exception) {\n        console.log(exception)\n      }\n\n      /**\n   * helper functions to show / hide fields containing additional information\n   */\n      const showExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const hideExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const buttonIds = [\n        \"hint-zusatz\",\n        \"hint-definition\",\n        \"hint-hammer\",\n        \"hint-klinik\",\n        \"hint-praeparat\",\n        \"hint-microscope\",\n        \"hint-smartzoom\",\n        \"hint-histotrainer\",\n        \"hint-uafi\",\n        \"hint-merksprueche\",\n        \"hint-memes\",\n        \"hint-image\",\n        \"hint-amboss\",\n        \"hint-thieme\",\n        \"hint-meditricks\",\n        \"hint-linkcontainer\",\n      ];\n\n      const showExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document\n              .getElementById(buttonIds[button])\n              .style.removeProperty(\"display\");\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n      const hideExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document.getElementById(buttonIds[button]).style.display = \"none\";\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n\n      // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n      /**\n       * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n       */\n      const getCardNumber = function () {\n        clz = document.body.className;\n        const regex = /card(\\d+)/gm;\n\n        let clz2;\n        try {\n          clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n        } catch (e) {\n          clz2 = \"\";\n        }\n        const regex2 = /.*?Cloze(\\d+)/gm;\n\n        let m;\n\n        if ((m = regex2.exec(clz2)) !== null) {\n          return m[1];\n        } else if ((m = regex.exec(clz)) !== null) {\n          return m[1];\n        } else {\n          // Should only fire if card is not cloze\n          console.error(\"Cannot find cardN class of body element!\");\n          return \"0\";\n        }\n      }\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (!clozeOneByOneEnabled) {\n        showExtra()\n        showExtraButtons()\n        document.getElementById(\"onebyone-buttons\").style.display = \"none\"\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n        return\n      }\n\n      // Needed for amboss to recognize first word in .cloze-hidden\n      const CLOZE_REPLACER_SEP = \"<span class='hidden'> </span>\"\n\n      const hideAllCloze = function (initial) {\n        let clozes = document.getElementsByClassName(\"cloze\")\n        let count = 0 // hidden cloze count\n        for (const cloze of clozes) {\n          const existingHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n          if (existingHidden) {\n            revealCloze(cloze);\n          }\n          if (cloze.offsetWidth === 0) {\n            continue\n          }\n          const clozeReplacer = document.createElement(\"span\")\n          const clozeHidden = document.createElement(\"span\")\n          clozeReplacer.classList.add(\"cloze-replacer\")\n          clozeHidden.classList.add(\"cloze-hidden\")\n          while (cloze.childNodes.length > 0) {\n            clozeHidden.appendChild(cloze.childNodes[0])\n          }\n          cloze.appendChild(clozeReplacer)\n          cloze.appendChild(clozeHidden)\n\n          var clozeHints = Persistence.getItem(\"clozeHints\");\n          if (clozeHints && clozeHints[count]) {\n            clozeReplacer.classList.add(\"cloze-hint\")\n            clozeReplacer.innerHTML = clozeHints[count] + CLOZE_REPLACER_SEP\n          } else {\n            clozeReplacer.innerHTML = clozeHider(cloze) + CLOZE_REPLACER_SEP\n          }\n          count += 1\n          document.getElementById(\"button-reveal-next\").style.display = \"inline-block\";\n          if (initial) {\n            cloze.addEventListener(\"touchend\", revealClozeClicked)\n            cloze.addEventListener(\"click\", revealClozeClicked)\n            cloze.classList.add(\"one-by-one\");\n          }\n        }\n\n        // Hide #extra until all clozes are shown\n        const extra = document.getElementById(\"extra\");\n        if (extra) {\n          extra.classList.add(\"hidden\");\n        }\n\n        hideExtra();\n        hideExtraButtons();\n        if (revealAnywhere) {\n          document.documentElement.setAttribute(\"onclick\", \"revealNextCloze(); event.stopPropagation()\")\n        }\n\n\n        // Also hide autoReveal fields\n        for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n          const container = document.querySelector(`[data-name=\"${field}\"]`)\n          if (container) {\n            const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n            if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n              // const link = container.getElementsByTagName(\"a\")[0]\n              const button = container.getElementsByTagName(\"button\")[0]\n              const hint = container.getElementsByTagName(\"div\")[0]\n              button.classList.remove(\"expanded-button\")\n              hint.style.display = \"none\"\n              // link.style.display = \"\"\n            }\n          }\n        }\n      }\n\n      const revealCloze = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        cloze.removeChild(clozeReplacer)\n        cloze.removeChild(clozeHidden)\n        while (clozeHidden.childNodes.length > 0) {\n          cloze.appendChild(clozeHidden.childNodes[0])\n        }\n        maybeRevealExtraField()\n      }\n\n      const revealClozeWord = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        let range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundSpace = setRangeEnd(range, clozeHidden, \"beforeFirstSpace\")\n        if (!foundSpace) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        let fragment = range.extractContents()\n        cloze.insertBefore(fragment, clozeReplacer)\n        // Extract whitespaces after word\n        range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundWord = setRangeEnd(range, clozeHidden, \"beforeFirstChar\")\n        if (!foundWord) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        fragment = range.extractContents();\n        cloze.insertBefore(fragment, clozeReplacer)\n        if (!foundWord) {\n          cloze.removeChild(clozeHidden)\n          cloze.removeChild(clozeReplacer)\n          maybeRevealExtraField()\n          return\n        }\n        clozeReplacer.innerHTML = clozeHider(clozeHidden) + CLOZE_REPLACER_SEP\n        if (clozeReplacer.classList.contains(\"cloze-hint\")) [\n          clozeReplacer.classList.remove(\"cloze-hint\")\n        ]\n        maybeRevealExtraField()\n      }\n\n      const revealNextClozeOf = (type) => {\n        const nextHidden = document.querySelectorAll(\".cloze-hidden\")\n        const nextNextHidden = nextHidden.length > 1 ? true : false\n        if (!nextNextHidden) {\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\";\n        }\n        if (!nextHidden) {\n          return\n        }\n        const cloze = clozeElOfClozeHidden(nextHidden[0]);\n        if (type === \"word\") {\n          revealClozeWord(cloze)\n        } else if (type === \"cloze\") {\n          revealCloze(cloze)\n        } else {\n          console.error(\"Invalid type: \" + type)\n        }\n      }\n\n      const revealClozeClicked = function (ev) {\n        let elem = ev.currentTarget\n        if (!ev.altKey && (revealNextClozeMode !== \"word\")) {\n          revealCloze(elem)\n        } else {\n          revealClozeWord(elem)\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      }\n\n      window.revealNextCloze = function () {\n        revealNextClozeOf(revealNextClozeMode)\n      }\n\n      window.toggleAllCloze = function () {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length > 0) {\n          for (const elem of elems) {\n            const cloze = clozeElOfClozeHidden(elem)\n            revealCloze(cloze)\n          }\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\"\n        } else {\n          hideAllCloze(initial = false)\n        }\n      }\n\n      const clozeElOfClozeHidden = (cloze) => {\n        while (!cloze.classList.contains(\"cloze\")) {\n          cloze = cloze.parentElement;\n        }\n        return cloze;\n      }\n\n      const maybeRevealExtraField = () => {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length == 0) {\n          const extra = document.getElementById(\"extra\")\n          if (extra) {\n            extra.classList.remove(\"hidden\")\n          }\n\n          showExtra();\n          showExtraButtons();\n          document.documentElement.removeAttribute(\"onclick\")\n\n          // Also reveal autoReveal fields\n          for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n            const container = document.querySelector(`[data-name=\"${field}\"]`)\n            if (container) {\n              const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n              if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n                // const link = container.getElementsByTagName(\"a\")[0]\n                const button = container.getElementsByTagName(\"button\")[0]\n                const hint = container.getElementsByTagName(\"div\")[0]\n                button.classList.add(\"expanded-button\")\n                hint.style.display = \"block\"\n                // link.style.display = \"none\"\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * mode: 'beforeFirstSpace' or 'beforeFirstChar'\n       * Return `true` if it exists and setEnd() was called, otherwise `false`\n       */\n      const setRangeEnd = function (range, node, mode) {\n        if (node.nodeType === Node.TEXT_NODE) {\n          const regex = mode === 'beforeFirstSpace' ? /\\s/ : /\\S/\n          const match = node.textContent.match(regex)\n          if (match) {\n            if (match.index === 0) {\n              while (node.previousSibling === null) {\n                node = node.parentElement\n              }\n              range.setEndBefore(node)\n            } else {\n              range.setEnd(node, match.index);\n            }\n            return true;\n          } else {\n            return false;\n          }\n        } else if (mode === 'beforeFirstChar' && isCharNode(node)) {\n          range.setEndBefore(node)\n          return true\n        } else if (!ignoreSpaceInNode(node)) {\n          for (const child of node.childNodes) {\n            if (setRangeEnd(range, child, mode)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }\n\n      const ignoreSpaceInNode = function (node) {\n        return node.tagName === \"MJX-ASSISTIVE-MML\"\n      }\n\n      const isCharNode = function (node) {\n        return [\"IMG\", \"MJX-CONTAINER\"].includes(node.tagName)\n      }\n\n      hideAllCloze(initial = true)\n\n      let isShowNextShortcut = shortcutMatcher(window.revealNextShortcut)\n      let isShowWordShortcut = shortcutMatcher(window.revealNextWordShortcut)\n      let isToggleAllShortcut = shortcutMatcher(window.toggleAllShortcut)\n      ankingAddEventListener(\"keydown\", (ev) => {\n        let next = isShowNextShortcut(ev)\n        let word = isShowWordShortcut(ev)\n        let all = isToggleAllShortcut(ev)\n        if (next) {\n          revealNextClozeOf(\"cloze\")\n        } else if (word) {\n          revealNextClozeOf(\"word\")\n        } else if (all) {\n          toggleAllCloze()\n        } else {\n          return;\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      });\n    })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- MEDITRICKS SNIPPETS DATA -->\n<div id=\"meditricks-mtsp-values\" style=\"display:none;\">\n  <div id=\"meditricks-mtsp-nfname\">_meditricks_nf_v1000_ankizin</div>\n  <div id=\"meditricks-mtsp-nid\">{{Note ID}}</div>\n</div>\n<script src=\"_meditricks_mtsp_scripts_v1000_ankizin.js\"></script>\n<link href=\"_meditricks_mtsp_styles_v1000_ankizin.css\" rel=\"stylesheet\" />\n\n<!-- include \"_meditricks_mtsp_nf_v1000_ankizin.js\" -->\n<!-- include \"_meditricks_mtsp_scripts_v1000_iframe.map\" -->\n<!-- include \"_meditricks_mtsp_mtlogo.webp\" -->\n<!-- include \"_meditricks_mtsp_mt-loading.png\" -->\n<!-- include \"_meditricks_mtsp_mt-loading_night.png\" -->\n\n<!-- //MEDITRICKS SNIPPETS DATA -->\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>",
      "bqfmt": "{{Muskel / Leitungsbahn}}",
      "bafmt": "{{Funktion}}",
      "bfont": "Helvetica",
      "bsize": 12
    },
    {
      "name": "FunktionCloze3",
      "ord": 17,
      "qfmt": "<!-- version f0935e4 -->\n{{#Funktion}}\n{{#FunktionCloze3}}\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TIMER CONFIG  ##############\n  // Timer config (timer length, timer finished message)\n  var minutes = 0\n  var seconds = 15\n  var timeOverMsg = \"<span style='color:#CC5B5B'>!!!</span>\"\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  // Auto flip to back when One by one mode.\n  var autoflip = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Was ist die <i>Funktion</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" data-card=\"{{Card}}\"><br>{{Funktion}}</div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\"></div>\n\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<script>\n  //DONT FADE BETWEEN CARDS\n  qFade = 0;\n  if (typeof anki !== 'undefined') anki.qFade = qFade;\n</script>\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    if (!indentation) { return; }\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- CLOZE ONE BY ONE FRONT -->\n<div id=\"one-by-one\" style=\"display: none;\"></div>\n\n<script>\n  /**\n   * Based on the AnKing Notetype, but expanded and modified by phyn.\n   * Credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  Persistence.clear();\n\n  // check if OneByOne is generally enabled for this card\n  var oneByOneFieldEmpty = selectiveOneByOne ? \"{{One by one}}\" === \"\" : true;\n  var clozeOneByOneEnabled = alwaysOneByOne ? true : !oneByOneFieldEmpty;\n\n  // avoid flickering. Must unset this in the back.\n  document.getElementById(\"qa\").style.display = \"none\";\n  var clozeHints = [];\n\n  if (clozeOneByOneEnabled) {\n    // collect hints from front side (independent of whether or not OneByOne is enabled)\n    document.getElementById(\"qa\").classList.add('one-by-one');\n    // Save cloze hints to display in the back\n    var clozes = document.getElementsByClassName(\"cloze\")\n    for (var i = 0; i < clozes.length; i++) {\n      clozes[i].classList.add(\"one-by-one\");\n      if (clozes[i].innerHTML === \"[...]\") {\n        clozeHints.push(\"\")\n      } else {\n        clozeHints.push(clozes[i].innerHTML)\n      }\n    }\n\n    // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n    /**\n     * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n     */\n    const getCardNumber = function () {\n      clz = document.body.className;\n      const regex = /card(\\d+)/gm;\n\n      let clz2;\n      try {\n        clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n      } catch (e) {\n        clz2 = \"\";\n      }\n      const regex2 = /.*?Cloze(\\d+)/gm;\n\n      let m;\n\n      if ((m = regex2.exec(clz2)) !== null) {\n        return m[1];\n      } else if ((m = regex.exec(clz)) !== null) {\n        return m[1];\n      } else {\n        // Should only fire if card is not cloze\n        console.error(\"Cannot find cardN class of body element!\");\n        return \"0\";\n      }\n    }\n\n    var alreadyRendered = false;\n\n    function processSelective1b1() {\n      if (alreadyRendered) return;\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (autoflip && clozeOneByOneEnabled) {\n        if (window.pycmd || window.showAnswer) {\n          // avoid flickering. Must unset this in the back.\n          document.getElementById(\"qa\").style.display = \"none\";\n        }\n        if (window.pycmd) {\n          pycmd(\"ans\")\n        } else if (window.showAnswer) {\n          showAnswer()\n        }\n      } else {\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n      }\n      // AnkiMobile JS API doesn't have one for show answer.\n      // Best alternative is to use Taps/Swipes to show answer.\n\n      alreadyRendered = true;\n    }\n\n    function delayedProcessSelective1b1() {\n      if (window.requestAnimationFrame) window.requestAnimationFrame(processSelective1b1); // less flickering\n      else window.setTimeout(processSelective1b1, 0);\n    };\n\n    window.onload = delayedProcessSelective1b1;\n    if (document.readyState === \"complete\") {\n      delayedProcessSelective1b1();\n    }\n    else {\n      document.addEventListener(\"DOMContentLoaded\", delayedProcessSelective1b1);\n    }\n\n    // Observe document.body class changes to trigger re-rendering.\n    // This is useful, because Anki doesn’t always start with an up-to-date class list:\n    // https://forums.ankiweb.net/t/card-card-classes-only-injected-separately-now/27387.\n    const observer = new MutationObserver(function (mutationsList, observer) {\n      for (let mutation of mutationsList) {\n        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {\n          delayedProcessSelective1b1();\n        }\n      }\n    });\n    observer.observe(document.body, { attributes: true });\n  }\n  Persistence.setItem(\"clozeHints\", clozeHints);\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>\n\n\n{{/FunktionCloze3}}\n{{/Funktion}}",
      "afmt": "<!-- version f0935e4 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n<div id=\"back\"></div>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Eigene Notizen & Bilder\": \"Alt + 1\",\n    \"Eigene Prüfungsfragen\": \"Alt + 2\",\n    \"Definitionen\": \"Alt + 3\",\n    \"Merksprüche\": \"Alt + 4\",\n    \"Klinik\": \"Alt + 5\",\n    \"Präparat\": \"Alt + 6\",\n    \"Memes\": \"Alt + 7\",\n    \"linkContainer\": \"Alt + L\",\n    \"Meditricks\": \"Alt + M\",\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Eigene Notizen & Bilder\": false,\n    \"Eigene Prüfungsfragen\": false,\n    \"Definitionen\": false,\n    \"Merksprüche\": false,\n    \"Klinik\": false,\n    \"Präparat\": false,\n    \"Memes\": false,\n    \"linkContainer\": true,\n    \"Meditricks\": false,\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  var revealNextShortcut = \"N\"\n  var revealNextWordShortcut = \"Shift + N\"\n  var toggleAllShortcut = \",\"\n\n  // Enables revealing of next Cloze by simply clicking / tapping anywhere on the card (except the buttons)\n  var revealAnywhere = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // Changes how \"Reveal Next\" and clicking behaves. Either \"cloze\" or \"word\".\n  // \"word\" reveals word by word. \n  var revealNextClozeMode = \"cloze\"\n\n  // Changes how fields with additional information are displayed.\n  // true displays fields with additional information only if all clozes are revealed.\n  var hideAdditional = true;\n  var hideAdditionalButtons = true;\n\n  // What cloze is hidden with\n  var clozeHider = (elem) => \"[&nbsp;_&nbsp;]\"\n  /*\n  You can replace the above line with below examples. '█' or '_' works well for hiding clozes.\n  \n  // Fixed length:\n  var clozeHider = (elem) => \"███\"\n  // Replace each character with \"█\":\n  var clozeHider = (elem) => \"█\".repeat(elem.textContent.length)\n  // Show whitespaces:\n  var clozeHider = (elem) => \"[\" + elem.textContent.split(\" \").map((t) => \"█\".repeat(t.length)).join(\" \") + \"]\"\n  // Color-filled box (doesn't hide images):\n  var clozeHider = (elem) => `<span style=\"background-color: red; color: transparent;\">${elem.innerHTML}</span>`\n  */\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Was ist die <i>Funktion</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" class=\"clozefield\" data-card=\"{{Card}}\"><br>{{Funktion}}</div>\n\n    <!-- ClOZE ONE BY ONE BUTTONS -->\n    <div id=\"onebyone-buttons\" class=\"onebyone\">\n      <br>\n      <button id=\"button-reveal-next\" class=\"button-general button-one-by-one\"\n        onclick=\"revealNextCloze(); event.stopPropagation()\">Reveal Next</button>\n      <button id=\"button-toggle-all\" class=\"button-general button-one-by-one\"\n        onclick=\"toggleAllCloze(); event.stopPropagation()\">Toggle All</button>\n    </div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- BUTTON FIELDS -->\n    {{#Eigene Notizen & Bilder}}\n    <span id=\"hint-zusatz\" class=\"hintBtn\" data-name=\"Eigene Notizen & Bilder\" style=\"display: none;\">\n      <button id=\"button-zusatz\" class=\"button-general\" onclick=\"toggleHintBtn('hint-zusatz'); event.stopPropagation()\">\n        <img src=\"__zusatz.svg\" style=\"height: 10px;\"> Eigene Notizen & Bilder\n      </button>\n      <div dir=\"auto\" id=\"zusatz\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Notizen & Bilder}}</div>\n    </span>\n    {{/Eigene Notizen & Bilder}}\n\n    {{#Eigene Prüfungsfragen}}\n    <span id=\"hint-hammer\" class=\"hintBtn\" data-name=\"Eigene Prüfungsfragen\" style=\"display: none;\">\n      <button id=\"button-hammer\" class=\"button-general\" onclick=\"toggleHintBtn('hint-hammer'); event.stopPropagation()\">\n        <img src=\"__hammer.svg\" style=\"height: 10px;\"> Eigene Prüfungsfragen\n      </button>\n      <div dir=\"auto\" id=\"hammer\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Prüfungsfragen}}</div>\n    </span>\n    {{/Eigene Prüfungsfragen}}\n\n    {{#Definitionen}}\n    <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Definitionen\" style=\"display: none;\">\n      <button id=\"button-definition\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Definitionen\n      </button>\n      <div dir=\"auto\" id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Definitionen}}</div>\n    </span>\n    {{/Definitionen}}\n\n    {{#Merksprüche}}\n    <span id=\"hint-merksprueche\" class=\"hintBtn\" data-name=\"Merksprüche\" style=\"display: none;\">\n      <button id=\"button-merksprueche\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-merksprueche'); event.stopPropagation()\">\n        <img src=\"__merkhilfe.svg\" style=\"height: 10px;\"> Merksprüche\n      </button>\n      <div dir=\"auto\" id=\"merksprueche\" class=\"hints\" style=\"display: none;\">{{edit:Merksprüche}}</div>\n    </span>\n    {{/Merksprüche}}\n\n    {{#Klinik}}\n    <span id=\"hint-klinik\" class=\"hintBtn\" data-name=\"Klinik\" style=\"display: none;\">\n      <button id=\"button-klinik\" class=\"button-general\" onclick=\"toggleHintBtn('hint-klinik'); event.stopPropagation()\">\n        <img src=\"__stethoscope.svg\" style=\"height: 10px;\"> Klinik\n      </button>\n      <div dir=\"auto\" id=\"klinik\" class=\"hints\" style=\"display: none;\">{{edit:Klinik}}</div>\n    </span>\n    {{/Klinik}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-praeparat\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n        </button>\n      </a>\n    </span>\n    {{/Präparat}}\n\n    {{#Virtuelle Mikroskopie}}\n    <span id=\"hint-microscope-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Virtuelle Mikroskopie}}\">\n        <button id=\"button-microscope\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Virtuelle Mikroskopie\n        </button>\n      </a>\n    </span>\n    {{/Virtuelle Mikroskopie}}\n\n    {{#Smart Zoom}}\n    <span id=\"hint-smartzoom-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-smartzoom\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Smart Zoom\n        </button>\n      </a>\n    </span>\n    {{/Smart Zoom}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat\" class=\"hintBtn\" data-name=\"Präparat\" style=\"display: none;\">\n      <button id=\"button-praeparat\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-praeparat'); event.stopPropagation()\">\n        <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n      </button>\n      <div dir=\"auto\" id=\"praeparat\" class=\"hints\" style=\"display: none;\">{{edit:Präparat}}</div>\n    </span>\n    {{/Präparat}}\n\n    {{#Memes}}\n    <span id=\"hint-memes\" class=\"hintBtn\" data-name=\"Memes\" style=\"display: none;\">\n      <button id=\"button-memes\" class=\"button-general\" onclick=\"toggleHintBtn('hint-memes'); event.stopPropagation()\">\n        <img src=\"__sonstiges.svg\" style=\"height: 10px;\"> Memes\n      </button>\n      <div dir=\"auto\" id=\"memes\" class=\"hints\" style=\"display: none;\">{{edit:Memes}}</div>\n    </span>\n    {{/Memes}}\n\n    <!-- LINEBREAKS IF BUTTONS EXIST -->\n    <script>\n      var array = [`{{Eigene Notizen & Bilder}}`, `{{Eigene Prüfungsfragen}}`, `{{Definitionen}}`, `{{Merksprüche}}`, `{{Klinik}}`, `{{Präparat}}`, `{{Memes}}`];\n      var anyistrue = (element) => element;\n      if (array.some(anyistrue)) {\n        document.getElementById(\"linebreaksIfButtons\").innerHTML = \"<br>\";\n      }\n    </script>\n    <div id=\"linebreaksIfButtons\"></div>\n\n    <!-- Extra field -->\n    {{#Extra}}\n    <div id=\"extra\" style=\"display: none;\">\n      <br>{{edit:Extra}}<br><br>\n    </div>\n    {{/Extra}}\n\n    <!-- Image field -->\n    {{#Bild}}\n    <div id=\"image\" style=\"display: none;\">\n      {{edit:Bild}}<br><br></div>\n    {{/Bild}}\n    {{^Bild}}\n    <span id=\"image\" style=\"display: none;\"></span>\n    {{/Bild}}\n    {{#Bild}}\n    <span id=\"hint-image\" style=\"display: none;\">\n      <button id=\"button-image\" class=\"button-general\"\n        onclick=\"var image = document.getElementById('image'); if (image.style.display == 'none') { image.style.display = 'block' } else { image.style.display = 'none' }; event.stopPropagation()\">\n        <img src=\"__image.svg\" style=\"height: 10px;\"> Abbildung\n      </button>\n    </span>\n    {{/Bild}}\n\n    <span id=\"hint-uafi\" class=\"hintBtn\" data-name=\"Ursprung, Ansatz, Verlauf, Funktion, Innervation, Äste\"\n      style=\"display: none;\">\n      <button id=\"button-uafi\" class=\"button-general expanded-button\"\n        onclick=\"toggleHintBtn('hint-uafi'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Weitere Informationen\n      </button>\n      <div id=\"uafi\" class=\"hints\" style=\"display: block;\">\n        <table class=\"uncloze\">\n          {{#Ursprung}}\n          <tr class=\"uafi-element\" id=\"Ursprung\">\n            <td><i>Ursprung</i></td>\n            <td>{{Ursprung}}</td>\n          </tr>\n          {{/Ursprung}}\n          {{#Ansatz}}\n          <tr class=\"uafi-element\" id=\"Ansatz\">\n            <td><i>Ansatz</i></td>\n            <td>{{Ansatz}}</td>\n          </tr>\n          {{/Ansatz}}\n          {{#Verlauf}}\n          <tr class=\"uafi-element\" id=\"Verlauf\">\n            <td><i>Verlauf</i></td>\n            <td>{{Verlauf}}</td>\n          </tr>\n          {{/Verlauf}}\n          {{#Funktion}}\n          <tr class=\"uafi-element\" id=\"Funktion\">\n            <td><i>Funktion</i></td>\n            <td>{{Funktion}}</td>\n          </tr>\n          {{/Funktion}}\n          {{#Innervation}}\n          <tr class=\"uafi-element\" id=\"Innervation\">\n            <td><i>Innervation</i></td>\n            <td>{{Innervation}}</td>\n          </tr>\n          {{/Innervation}}\n          {{#Äste}}\n          <tr class=\"uafi-element\" id=\"Äste\">\n            <td><i>Äste</i></td>\n            <td>{{Äste}}</td>\n          </tr>\n          {{/Äste}}\n        </table>\n      </div>\n\n      <script>\n        // iterate over all uafi-elements and hide only the one\n        // that is equal to the card's answer (i.e., value of {{Card}})\n        var uafiElements = document.getElementsByClassName(\"uafi-element\");\n        for (var i = 0; i < uafiElements.length; i++) {\n          if (((\"{{Card}}\").startsWith(uafiElements[i].id))) {\n            uafiElements[i].remove()\n          }\n        }\n      </script>\n    </span>\n\n    {{#AMBOSS-Link}}\n    <span id=\"hint-amboss\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:AMBOSS-Link}}\">\n        <button id=\"button-amboss\" class=\"button-general\">\n          <img src=\"__amboss.svg\" style=\"height: 10px;\"> AMBOSS&#8203;\n        </button>\n      </a>\n    </span>\n    {{/AMBOSS-Link}}\n\n    {{#Thieme via medici-Link}}\n    <span id=\"hint-thieme\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Thieme via medici-Link}}\">\n        <button id=\"button-thieme\" class=\"button-general\">\n          <img id=\"button-thieme-img\" src=\"__thieme-heart.svg\" style=\"height: 10px;\"> Thieme via medici\n        </button>\n      </a>\n    </span>\n    {{/Thieme via medici-Link}}\n\n    {{#Meditricks}}\n    <span id=\"hint-meditricks\" class=\"hintBtn\" data-name=\"Meditricks\" style=\"display: none;\">\n      <button id=\"button-meditricks\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-meditricks'); event.stopPropagation()\">\n        <img src=\"__meditricks.svg\" style=\"height: 10px;\"> Meditricks\n      </button>\n      <div dir=\"auto\" id=\"meditricks\" class=\"hints\" style=\"display: none;\">{{edit:Meditricks}}</div>\n    </span>\n    {{/Meditricks}}\n\n    {{#weitere Links}}\n    <span id=\"hint-linkcontainer\" class=\"hintBtn\" data-name=\"linkContainer\" style=\"display: none;\">\n      <button id=\"button-linkcontainer\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-linkcontainer'); event.stopPropagation()\">\n        <img src=\"__internet.svg\" style=\"height: 10px;\"> weitere Links\n      </button>\n      <div id=\"linkcontainer\" class=\"hints\" style=\"display: none;\"></div>\n      <span id=\"linkContainerLinks\" style=\"display: none;\">{{edit:weitere Links}}</span>\n    </span>\n    {{/weitere Links}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n  try {\n    for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n      href = link.href\n      text = link.innerText\n\n      const el = document.createElement('a');\n      el.setAttribute('href', link.href);\n\n      const btn = document.createElement('button');\n      btn.classList.add('button-general');\n      btn.classList.add('expanded-button');\n\n      domain = href.replace(/.+\\/\\/|(www|flexikon|register|de|next|com).|\\..+/g, '');\n      domainDict = {\n        \"amboss\": \"__amboss.svg\",\n        \"wikipedia\": \"__wikipedia.svg\",\n        \"doccheck\": \"__doccheck.png\",\n        \"notfallguru\": \"__notfallguru.svg\",\n        \"awmf\": \"__awmf.svg\",\n        \"gelbe-liste\": \"__gelbe-liste.png\",\n        \"embryotox\": \"__embryotox.svg\",\n        \"radiopaedia\": \"__radiopaedia.png\",\n        \"orphanet\": \"__orphanet.png\",\n      }\n      if (domain in domainDict) {\n        icon = domainDict[domain]\n      } else {\n        icon = \"__internet.svg\"\n      }\n\n      const img = document.createElement('img');\n      img.setAttribute('src', icon);\n      img.setAttribute('style', 'height: 10px;');\n\n      btn.appendChild(img);\n      btn.innerHTML = btn.innerHTML + \" \" + text;\n\n      el.appendChild(btn);\n\n      document.getElementById(\"linkcontainer\").appendChild(el)\n    }\n  }\n  catch (err) {\n    console.log(err)\n  }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-uafi\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- AUTOFLIP BACK SCRIPT -->\n<script>\n  // autoflip hides card in front template\n  document.getElementById(\"qa\").style.removeProperty(\"display\")\n</script>\n\n<!-- CLOZE ONE BY ONE SCRIPT -->\n<style>\n  .cloze-replacer:hover {\n    cursor: pointer;\n  }\n\n  .cloze-hidden {\n    display: none;\n  }\n\n  .cloze-replacer .hidden {\n    display: none;\n  }\n\n  #extra.hidden {\n    display: none;\n  }\n</style>\n\n<!--\n Based on the AnKing Notetype, but expanded and modified by phyn.\n Credit to the original authors, except where modified or otherwise indicated.\n-->\n\n<script>\n    (function () {\n      // enables cloze one-by-one even when one-by-one field is empty\n      // minNumberOfClozes is still considered in this case\n      // overridden in importance by selectiveOneByOne\n      var clozeOneByOneEnabled = true;\n\n      // remove the clickAnywhere function from global scope\n      document.documentElement.removeAttribute(\"onclick\")\n\n      // --- CHECK IF ONE BY ONE IS GENERALLY ENABLED FOR THIS NOTE ---\n      var oneByOneFieldNotEmpty = \"{{One by one}}\" !== \"\";\n      try {\n        clozeOneByOneEnabled = alwaysOneByOne || oneByOneFieldNotEmpty;\n      } catch (exception) {\n        console.log(exception)\n      }\n\n      /**\n   * helper functions to show / hide fields containing additional information\n   */\n      const showExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const hideExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const buttonIds = [\n        \"hint-zusatz\",\n        \"hint-definition\",\n        \"hint-hammer\",\n        \"hint-klinik\",\n        \"hint-praeparat\",\n        \"hint-microscope\",\n        \"hint-smartzoom\",\n        \"hint-histotrainer\",\n        \"hint-uafi\",\n        \"hint-merksprueche\",\n        \"hint-memes\",\n        \"hint-image\",\n        \"hint-amboss\",\n        \"hint-thieme\",\n        \"hint-meditricks\",\n        \"hint-linkcontainer\",\n      ];\n\n      const showExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document\n              .getElementById(buttonIds[button])\n              .style.removeProperty(\"display\");\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n      const hideExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document.getElementById(buttonIds[button]).style.display = \"none\";\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n\n      // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n      /**\n       * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n       */\n      const getCardNumber = function () {\n        clz = document.body.className;\n        const regex = /card(\\d+)/gm;\n\n        let clz2;\n        try {\n          clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n        } catch (e) {\n          clz2 = \"\";\n        }\n        const regex2 = /.*?Cloze(\\d+)/gm;\n\n        let m;\n\n        if ((m = regex2.exec(clz2)) !== null) {\n          return m[1];\n        } else if ((m = regex.exec(clz)) !== null) {\n          return m[1];\n        } else {\n          // Should only fire if card is not cloze\n          console.error(\"Cannot find cardN class of body element!\");\n          return \"0\";\n        }\n      }\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (!clozeOneByOneEnabled) {\n        showExtra()\n        showExtraButtons()\n        document.getElementById(\"onebyone-buttons\").style.display = \"none\"\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n        return\n      }\n\n      // Needed for amboss to recognize first word in .cloze-hidden\n      const CLOZE_REPLACER_SEP = \"<span class='hidden'> </span>\"\n\n      const hideAllCloze = function (initial) {\n        let clozes = document.getElementsByClassName(\"cloze\")\n        let count = 0 // hidden cloze count\n        for (const cloze of clozes) {\n          const existingHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n          if (existingHidden) {\n            revealCloze(cloze);\n          }\n          if (cloze.offsetWidth === 0) {\n            continue\n          }\n          const clozeReplacer = document.createElement(\"span\")\n          const clozeHidden = document.createElement(\"span\")\n          clozeReplacer.classList.add(\"cloze-replacer\")\n          clozeHidden.classList.add(\"cloze-hidden\")\n          while (cloze.childNodes.length > 0) {\n            clozeHidden.appendChild(cloze.childNodes[0])\n          }\n          cloze.appendChild(clozeReplacer)\n          cloze.appendChild(clozeHidden)\n\n          var clozeHints = Persistence.getItem(\"clozeHints\");\n          if (clozeHints && clozeHints[count]) {\n            clozeReplacer.classList.add(\"cloze-hint\")\n            clozeReplacer.innerHTML = clozeHints[count] + CLOZE_REPLACER_SEP\n          } else {\n            clozeReplacer.innerHTML = clozeHider(cloze) + CLOZE_REPLACER_SEP\n          }\n          count += 1\n          document.getElementById(\"button-reveal-next\").style.display = \"inline-block\";\n          if (initial) {\n            cloze.addEventListener(\"touchend\", revealClozeClicked)\n            cloze.addEventListener(\"click\", revealClozeClicked)\n            cloze.classList.add(\"one-by-one\");\n          }\n        }\n\n        // Hide #extra until all clozes are shown\n        const extra = document.getElementById(\"extra\");\n        if (extra) {\n          extra.classList.add(\"hidden\");\n        }\n\n        hideExtra();\n        hideExtraButtons();\n        if (revealAnywhere) {\n          document.documentElement.setAttribute(\"onclick\", \"revealNextCloze(); event.stopPropagation()\")\n        }\n\n\n        // Also hide autoReveal fields\n        for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n          const container = document.querySelector(`[data-name=\"${field}\"]`)\n          if (container) {\n            const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n            if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n              // const link = container.getElementsByTagName(\"a\")[0]\n              const button = container.getElementsByTagName(\"button\")[0]\n              const hint = container.getElementsByTagName(\"div\")[0]\n              button.classList.remove(\"expanded-button\")\n              hint.style.display = \"none\"\n              // link.style.display = \"\"\n            }\n          }\n        }\n      }\n\n      const revealCloze = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        cloze.removeChild(clozeReplacer)\n        cloze.removeChild(clozeHidden)\n        while (clozeHidden.childNodes.length > 0) {\n          cloze.appendChild(clozeHidden.childNodes[0])\n        }\n        maybeRevealExtraField()\n      }\n\n      const revealClozeWord = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        let range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundSpace = setRangeEnd(range, clozeHidden, \"beforeFirstSpace\")\n        if (!foundSpace) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        let fragment = range.extractContents()\n        cloze.insertBefore(fragment, clozeReplacer)\n        // Extract whitespaces after word\n        range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundWord = setRangeEnd(range, clozeHidden, \"beforeFirstChar\")\n        if (!foundWord) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        fragment = range.extractContents();\n        cloze.insertBefore(fragment, clozeReplacer)\n        if (!foundWord) {\n          cloze.removeChild(clozeHidden)\n          cloze.removeChild(clozeReplacer)\n          maybeRevealExtraField()\n          return\n        }\n        clozeReplacer.innerHTML = clozeHider(clozeHidden) + CLOZE_REPLACER_SEP\n        if (clozeReplacer.classList.contains(\"cloze-hint\")) [\n          clozeReplacer.classList.remove(\"cloze-hint\")\n        ]\n        maybeRevealExtraField()\n      }\n\n      const revealNextClozeOf = (type) => {\n        const nextHidden = document.querySelectorAll(\".cloze-hidden\")\n        const nextNextHidden = nextHidden.length > 1 ? true : false\n        if (!nextNextHidden) {\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\";\n        }\n        if (!nextHidden) {\n          return\n        }\n        const cloze = clozeElOfClozeHidden(nextHidden[0]);\n        if (type === \"word\") {\n          revealClozeWord(cloze)\n        } else if (type === \"cloze\") {\n          revealCloze(cloze)\n        } else {\n          console.error(\"Invalid type: \" + type)\n        }\n      }\n\n      const revealClozeClicked = function (ev) {\n        let elem = ev.currentTarget\n        if (!ev.altKey && (revealNextClozeMode !== \"word\")) {\n          revealCloze(elem)\n        } else {\n          revealClozeWord(elem)\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      }\n\n      window.revealNextCloze = function () {\n        revealNextClozeOf(revealNextClozeMode)\n      }\n\n      window.toggleAllCloze = function () {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length > 0) {\n          for (const elem of elems) {\n            const cloze = clozeElOfClozeHidden(elem)\n            revealCloze(cloze)\n          }\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\"\n        } else {\n          hideAllCloze(initial = false)\n        }\n      }\n\n      const clozeElOfClozeHidden = (cloze) => {\n        while (!cloze.classList.contains(\"cloze\")) {\n          cloze = cloze.parentElement;\n        }\n        return cloze;\n      }\n\n      const maybeRevealExtraField = () => {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length == 0) {\n          const extra = document.getElementById(\"extra\")\n          if (extra) {\n            extra.classList.remove(\"hidden\")\n          }\n\n          showExtra();\n          showExtraButtons();\n          document.documentElement.removeAttribute(\"onclick\")\n\n          // Also reveal autoReveal fields\n          for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n            const container = document.querySelector(`[data-name=\"${field}\"]`)\n            if (container) {\n              const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n              if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n                // const link = container.getElementsByTagName(\"a\")[0]\n                const button = container.getElementsByTagName(\"button\")[0]\n                const hint = container.getElementsByTagName(\"div\")[0]\n                button.classList.add(\"expanded-button\")\n                hint.style.display = \"block\"\n                // link.style.display = \"none\"\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * mode: 'beforeFirstSpace' or 'beforeFirstChar'\n       * Return `true` if it exists and setEnd() was called, otherwise `false`\n       */\n      const setRangeEnd = function (range, node, mode) {\n        if (node.nodeType === Node.TEXT_NODE) {\n          const regex = mode === 'beforeFirstSpace' ? /\\s/ : /\\S/\n          const match = node.textContent.match(regex)\n          if (match) {\n            if (match.index === 0) {\n              while (node.previousSibling === null) {\n                node = node.parentElement\n              }\n              range.setEndBefore(node)\n            } else {\n              range.setEnd(node, match.index);\n            }\n            return true;\n          } else {\n            return false;\n          }\n        } else if (mode === 'beforeFirstChar' && isCharNode(node)) {\n          range.setEndBefore(node)\n          return true\n        } else if (!ignoreSpaceInNode(node)) {\n          for (const child of node.childNodes) {\n            if (setRangeEnd(range, child, mode)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }\n\n      const ignoreSpaceInNode = function (node) {\n        return node.tagName === \"MJX-ASSISTIVE-MML\"\n      }\n\n      const isCharNode = function (node) {\n        return [\"IMG\", \"MJX-CONTAINER\"].includes(node.tagName)\n      }\n\n      hideAllCloze(initial = true)\n\n      let isShowNextShortcut = shortcutMatcher(window.revealNextShortcut)\n      let isShowWordShortcut = shortcutMatcher(window.revealNextWordShortcut)\n      let isToggleAllShortcut = shortcutMatcher(window.toggleAllShortcut)\n      ankingAddEventListener(\"keydown\", (ev) => {\n        let next = isShowNextShortcut(ev)\n        let word = isShowWordShortcut(ev)\n        let all = isToggleAllShortcut(ev)\n        if (next) {\n          revealNextClozeOf(\"cloze\")\n        } else if (word) {\n          revealNextClozeOf(\"word\")\n        } else if (all) {\n          toggleAllCloze()\n        } else {\n          return;\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      });\n    })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- MEDITRICKS SNIPPETS DATA -->\n<div id=\"meditricks-mtsp-values\" style=\"display:none;\">\n  <div id=\"meditricks-mtsp-nfname\">_meditricks_nf_v1000_ankizin</div>\n  <div id=\"meditricks-mtsp-nid\">{{Note ID}}</div>\n</div>\n<script src=\"_meditricks_mtsp_scripts_v1000_ankizin.js\"></script>\n<link href=\"_meditricks_mtsp_styles_v1000_ankizin.css\" rel=\"stylesheet\" />\n\n<!-- include \"_meditricks_mtsp_nf_v1000_ankizin.js\" -->\n<!-- include \"_meditricks_mtsp_scripts_v1000_iframe.map\" -->\n<!-- include \"_meditricks_mtsp_mtlogo.webp\" -->\n<!-- include \"_meditricks_mtsp_mt-loading.png\" -->\n<!-- include \"_meditricks_mtsp_mt-loading_night.png\" -->\n\n<!-- //MEDITRICKS SNIPPETS DATA -->\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>",
      "bqfmt": "{{Muskel / Leitungsbahn}}",
      "bafmt": "{{Funktion}}",
      "bfont": "Helvetica",
      "bsize": 12
    },
    {
      "name": "InnervationCloze1",
      "ord": 18,
      "qfmt": "<!-- version f0935e4 -->\n{{#Innervation}}\n{{#InnervationCloze1}}\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TIMER CONFIG  ##############\n  // Timer config (timer length, timer finished message)\n  var minutes = 0\n  var seconds = 15\n  var timeOverMsg = \"<span style='color:#CC5B5B'>!!!</span>\"\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  // Auto flip to back when One by one mode.\n  var autoflip = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Was ist die <i>Innervation</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" data-card=\"{{Card}}\"><br>{{Innervation}}</div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\"></div>\n\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<script>\n  //DONT FADE BETWEEN CARDS\n  qFade = 0;\n  if (typeof anki !== 'undefined') anki.qFade = qFade;\n</script>\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    if (!indentation) { return; }\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- CLOZE ONE BY ONE FRONT -->\n<div id=\"one-by-one\" style=\"display: none;\"></div>\n\n<script>\n  /**\n   * Based on the AnKing Notetype, but expanded and modified by phyn.\n   * Credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  Persistence.clear();\n\n  // check if OneByOne is generally enabled for this card\n  var oneByOneFieldEmpty = selectiveOneByOne ? \"{{One by one}}\" === \"\" : true;\n  var clozeOneByOneEnabled = alwaysOneByOne ? true : !oneByOneFieldEmpty;\n\n  // avoid flickering. Must unset this in the back.\n  document.getElementById(\"qa\").style.display = \"none\";\n  var clozeHints = [];\n\n  if (clozeOneByOneEnabled) {\n    // collect hints from front side (independent of whether or not OneByOne is enabled)\n    document.getElementById(\"qa\").classList.add('one-by-one');\n    // Save cloze hints to display in the back\n    var clozes = document.getElementsByClassName(\"cloze\")\n    for (var i = 0; i < clozes.length; i++) {\n      clozes[i].classList.add(\"one-by-one\");\n      if (clozes[i].innerHTML === \"[...]\") {\n        clozeHints.push(\"\")\n      } else {\n        clozeHints.push(clozes[i].innerHTML)\n      }\n    }\n\n    // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n    /**\n     * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n     */\n    const getCardNumber = function () {\n      clz = document.body.className;\n      const regex = /card(\\d+)/gm;\n\n      let clz2;\n      try {\n        clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n      } catch (e) {\n        clz2 = \"\";\n      }\n      const regex2 = /.*?Cloze(\\d+)/gm;\n\n      let m;\n\n      if ((m = regex2.exec(clz2)) !== null) {\n        return m[1];\n      } else if ((m = regex.exec(clz)) !== null) {\n        return m[1];\n      } else {\n        // Should only fire if card is not cloze\n        console.error(\"Cannot find cardN class of body element!\");\n        return \"0\";\n      }\n    }\n\n    var alreadyRendered = false;\n\n    function processSelective1b1() {\n      if (alreadyRendered) return;\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (autoflip && clozeOneByOneEnabled) {\n        if (window.pycmd || window.showAnswer) {\n          // avoid flickering. Must unset this in the back.\n          document.getElementById(\"qa\").style.display = \"none\";\n        }\n        if (window.pycmd) {\n          pycmd(\"ans\")\n        } else if (window.showAnswer) {\n          showAnswer()\n        }\n      } else {\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n      }\n      // AnkiMobile JS API doesn't have one for show answer.\n      // Best alternative is to use Taps/Swipes to show answer.\n\n      alreadyRendered = true;\n    }\n\n    function delayedProcessSelective1b1() {\n      if (window.requestAnimationFrame) window.requestAnimationFrame(processSelective1b1); // less flickering\n      else window.setTimeout(processSelective1b1, 0);\n    };\n\n    window.onload = delayedProcessSelective1b1;\n    if (document.readyState === \"complete\") {\n      delayedProcessSelective1b1();\n    }\n    else {\n      document.addEventListener(\"DOMContentLoaded\", delayedProcessSelective1b1);\n    }\n\n    // Observe document.body class changes to trigger re-rendering.\n    // This is useful, because Anki doesn’t always start with an up-to-date class list:\n    // https://forums.ankiweb.net/t/card-card-classes-only-injected-separately-now/27387.\n    const observer = new MutationObserver(function (mutationsList, observer) {\n      for (let mutation of mutationsList) {\n        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {\n          delayedProcessSelective1b1();\n        }\n      }\n    });\n    observer.observe(document.body, { attributes: true });\n  }\n  Persistence.setItem(\"clozeHints\", clozeHints);\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>\n\n\n{{/InnervationCloze1}}\n{{/Innervation}}",
      "afmt": "<!-- version f0935e4 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n<div id=\"back\"></div>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Eigene Notizen & Bilder\": \"Alt + 1\",\n    \"Eigene Prüfungsfragen\": \"Alt + 2\",\n    \"Definitionen\": \"Alt + 3\",\n    \"Merksprüche\": \"Alt + 4\",\n    \"Klinik\": \"Alt + 5\",\n    \"Präparat\": \"Alt + 6\",\n    \"Memes\": \"Alt + 7\",\n    \"linkContainer\": \"Alt + L\",\n    \"Meditricks\": \"Alt + M\",\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Eigene Notizen & Bilder\": false,\n    \"Eigene Prüfungsfragen\": false,\n    \"Definitionen\": false,\n    \"Merksprüche\": false,\n    \"Klinik\": false,\n    \"Präparat\": false,\n    \"Memes\": false,\n    \"linkContainer\": true,\n    \"Meditricks\": false,\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  var revealNextShortcut = \"N\"\n  var revealNextWordShortcut = \"Shift + N\"\n  var toggleAllShortcut = \",\"\n\n  // Enables revealing of next Cloze by simply clicking / tapping anywhere on the card (except the buttons)\n  var revealAnywhere = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // Changes how \"Reveal Next\" and clicking behaves. Either \"cloze\" or \"word\".\n  // \"word\" reveals word by word. \n  var revealNextClozeMode = \"cloze\"\n\n  // Changes how fields with additional information are displayed.\n  // true displays fields with additional information only if all clozes are revealed.\n  var hideAdditional = true;\n  var hideAdditionalButtons = true;\n\n  // What cloze is hidden with\n  var clozeHider = (elem) => \"[&nbsp;_&nbsp;]\"\n  /*\n  You can replace the above line with below examples. '█' or '_' works well for hiding clozes.\n  \n  // Fixed length:\n  var clozeHider = (elem) => \"███\"\n  // Replace each character with \"█\":\n  var clozeHider = (elem) => \"█\".repeat(elem.textContent.length)\n  // Show whitespaces:\n  var clozeHider = (elem) => \"[\" + elem.textContent.split(\" \").map((t) => \"█\".repeat(t.length)).join(\" \") + \"]\"\n  // Color-filled box (doesn't hide images):\n  var clozeHider = (elem) => `<span style=\"background-color: red; color: transparent;\">${elem.innerHTML}</span>`\n  */\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Was ist die <i>Innervation</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" class=\"clozefield\" data-card=\"{{Card}}\"><br>{{Innervation}}</div>\n\n    <!-- ClOZE ONE BY ONE BUTTONS -->\n    <div id=\"onebyone-buttons\" class=\"onebyone\">\n      <br>\n      <button id=\"button-reveal-next\" class=\"button-general button-one-by-one\"\n        onclick=\"revealNextCloze(); event.stopPropagation()\">Reveal Next</button>\n      <button id=\"button-toggle-all\" class=\"button-general button-one-by-one\"\n        onclick=\"toggleAllCloze(); event.stopPropagation()\">Toggle All</button>\n    </div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- BUTTON FIELDS -->\n    {{#Eigene Notizen & Bilder}}\n    <span id=\"hint-zusatz\" class=\"hintBtn\" data-name=\"Eigene Notizen & Bilder\" style=\"display: none;\">\n      <button id=\"button-zusatz\" class=\"button-general\" onclick=\"toggleHintBtn('hint-zusatz'); event.stopPropagation()\">\n        <img src=\"__zusatz.svg\" style=\"height: 10px;\"> Eigene Notizen & Bilder\n      </button>\n      <div dir=\"auto\" id=\"zusatz\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Notizen & Bilder}}</div>\n    </span>\n    {{/Eigene Notizen & Bilder}}\n\n    {{#Eigene Prüfungsfragen}}\n    <span id=\"hint-hammer\" class=\"hintBtn\" data-name=\"Eigene Prüfungsfragen\" style=\"display: none;\">\n      <button id=\"button-hammer\" class=\"button-general\" onclick=\"toggleHintBtn('hint-hammer'); event.stopPropagation()\">\n        <img src=\"__hammer.svg\" style=\"height: 10px;\"> Eigene Prüfungsfragen\n      </button>\n      <div dir=\"auto\" id=\"hammer\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Prüfungsfragen}}</div>\n    </span>\n    {{/Eigene Prüfungsfragen}}\n\n    {{#Definitionen}}\n    <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Definitionen\" style=\"display: none;\">\n      <button id=\"button-definition\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Definitionen\n      </button>\n      <div dir=\"auto\" id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Definitionen}}</div>\n    </span>\n    {{/Definitionen}}\n\n    {{#Merksprüche}}\n    <span id=\"hint-merksprueche\" class=\"hintBtn\" data-name=\"Merksprüche\" style=\"display: none;\">\n      <button id=\"button-merksprueche\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-merksprueche'); event.stopPropagation()\">\n        <img src=\"__merkhilfe.svg\" style=\"height: 10px;\"> Merksprüche\n      </button>\n      <div dir=\"auto\" id=\"merksprueche\" class=\"hints\" style=\"display: none;\">{{edit:Merksprüche}}</div>\n    </span>\n    {{/Merksprüche}}\n\n    {{#Klinik}}\n    <span id=\"hint-klinik\" class=\"hintBtn\" data-name=\"Klinik\" style=\"display: none;\">\n      <button id=\"button-klinik\" class=\"button-general\" onclick=\"toggleHintBtn('hint-klinik'); event.stopPropagation()\">\n        <img src=\"__stethoscope.svg\" style=\"height: 10px;\"> Klinik\n      </button>\n      <div dir=\"auto\" id=\"klinik\" class=\"hints\" style=\"display: none;\">{{edit:Klinik}}</div>\n    </span>\n    {{/Klinik}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-praeparat\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n        </button>\n      </a>\n    </span>\n    {{/Präparat}}\n\n    {{#Virtuelle Mikroskopie}}\n    <span id=\"hint-microscope-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Virtuelle Mikroskopie}}\">\n        <button id=\"button-microscope\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Virtuelle Mikroskopie\n        </button>\n      </a>\n    </span>\n    {{/Virtuelle Mikroskopie}}\n\n    {{#Smart Zoom}}\n    <span id=\"hint-smartzoom-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-smartzoom\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Smart Zoom\n        </button>\n      </a>\n    </span>\n    {{/Smart Zoom}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat\" class=\"hintBtn\" data-name=\"Präparat\" style=\"display: none;\">\n      <button id=\"button-praeparat\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-praeparat'); event.stopPropagation()\">\n        <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n      </button>\n      <div dir=\"auto\" id=\"praeparat\" class=\"hints\" style=\"display: none;\">{{edit:Präparat}}</div>\n    </span>\n    {{/Präparat}}\n\n    {{#Memes}}\n    <span id=\"hint-memes\" class=\"hintBtn\" data-name=\"Memes\" style=\"display: none;\">\n      <button id=\"button-memes\" class=\"button-general\" onclick=\"toggleHintBtn('hint-memes'); event.stopPropagation()\">\n        <img src=\"__sonstiges.svg\" style=\"height: 10px;\"> Memes\n      </button>\n      <div dir=\"auto\" id=\"memes\" class=\"hints\" style=\"display: none;\">{{edit:Memes}}</div>\n    </span>\n    {{/Memes}}\n\n    <!-- LINEBREAKS IF BUTTONS EXIST -->\n    <script>\n      var array = [`{{Eigene Notizen & Bilder}}`, `{{Eigene Prüfungsfragen}}`, `{{Definitionen}}`, `{{Merksprüche}}`, `{{Klinik}}`, `{{Präparat}}`, `{{Memes}}`];\n      var anyistrue = (element) => element;\n      if (array.some(anyistrue)) {\n        document.getElementById(\"linebreaksIfButtons\").innerHTML = \"<br>\";\n      }\n    </script>\n    <div id=\"linebreaksIfButtons\"></div>\n\n    <!-- Extra field -->\n    {{#Extra}}\n    <div id=\"extra\" style=\"display: none;\">\n      <br>{{edit:Extra}}<br><br>\n    </div>\n    {{/Extra}}\n\n    <!-- Image field -->\n    {{#Bild}}\n    <div id=\"image\" style=\"display: none;\">\n      {{edit:Bild}}<br><br></div>\n    {{/Bild}}\n    {{^Bild}}\n    <span id=\"image\" style=\"display: none;\"></span>\n    {{/Bild}}\n    {{#Bild}}\n    <span id=\"hint-image\" style=\"display: none;\">\n      <button id=\"button-image\" class=\"button-general\"\n        onclick=\"var image = document.getElementById('image'); if (image.style.display == 'none') { image.style.display = 'block' } else { image.style.display = 'none' }; event.stopPropagation()\">\n        <img src=\"__image.svg\" style=\"height: 10px;\"> Abbildung\n      </button>\n    </span>\n    {{/Bild}}\n\n    <span id=\"hint-uafi\" class=\"hintBtn\" data-name=\"Ursprung, Ansatz, Verlauf, Funktion, Innervation, Äste\"\n      style=\"display: none;\">\n      <button id=\"button-uafi\" class=\"button-general expanded-button\"\n        onclick=\"toggleHintBtn('hint-uafi'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Weitere Informationen\n      </button>\n      <div id=\"uafi\" class=\"hints\" style=\"display: block;\">\n        <table class=\"uncloze\">\n          {{#Ursprung}}\n          <tr class=\"uafi-element\" id=\"Ursprung\">\n            <td><i>Ursprung</i></td>\n            <td>{{Ursprung}}</td>\n          </tr>\n          {{/Ursprung}}\n          {{#Ansatz}}\n          <tr class=\"uafi-element\" id=\"Ansatz\">\n            <td><i>Ansatz</i></td>\n            <td>{{Ansatz}}</td>\n          </tr>\n          {{/Ansatz}}\n          {{#Verlauf}}\n          <tr class=\"uafi-element\" id=\"Verlauf\">\n            <td><i>Verlauf</i></td>\n            <td>{{Verlauf}}</td>\n          </tr>\n          {{/Verlauf}}\n          {{#Funktion}}\n          <tr class=\"uafi-element\" id=\"Funktion\">\n            <td><i>Funktion</i></td>\n            <td>{{Funktion}}</td>\n          </tr>\n          {{/Funktion}}\n          {{#Innervation}}\n          <tr class=\"uafi-element\" id=\"Innervation\">\n            <td><i>Innervation</i></td>\n            <td>{{Innervation}}</td>\n          </tr>\n          {{/Innervation}}\n          {{#Äste}}\n          <tr class=\"uafi-element\" id=\"Äste\">\n            <td><i>Äste</i></td>\n            <td>{{Äste}}</td>\n          </tr>\n          {{/Äste}}\n        </table>\n      </div>\n\n      <script>\n        // iterate over all uafi-elements and hide only the one\n        // that is equal to the card's answer (i.e., value of {{Card}})\n        var uafiElements = document.getElementsByClassName(\"uafi-element\");\n        for (var i = 0; i < uafiElements.length; i++) {\n          if (((\"{{Card}}\").startsWith(uafiElements[i].id))) {\n            uafiElements[i].remove()\n          }\n        }\n      </script>\n    </span>\n\n    {{#AMBOSS-Link}}\n    <span id=\"hint-amboss\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:AMBOSS-Link}}\">\n        <button id=\"button-amboss\" class=\"button-general\">\n          <img src=\"__amboss.svg\" style=\"height: 10px;\"> AMBOSS&#8203;\n        </button>\n      </a>\n    </span>\n    {{/AMBOSS-Link}}\n\n    {{#Thieme via medici-Link}}\n    <span id=\"hint-thieme\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Thieme via medici-Link}}\">\n        <button id=\"button-thieme\" class=\"button-general\">\n          <img id=\"button-thieme-img\" src=\"__thieme-heart.svg\" style=\"height: 10px;\"> Thieme via medici\n        </button>\n      </a>\n    </span>\n    {{/Thieme via medici-Link}}\n\n    {{#Meditricks}}\n    <span id=\"hint-meditricks\" class=\"hintBtn\" data-name=\"Meditricks\" style=\"display: none;\">\n      <button id=\"button-meditricks\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-meditricks'); event.stopPropagation()\">\n        <img src=\"__meditricks.svg\" style=\"height: 10px;\"> Meditricks\n      </button>\n      <div dir=\"auto\" id=\"meditricks\" class=\"hints\" style=\"display: none;\">{{edit:Meditricks}}</div>\n    </span>\n    {{/Meditricks}}\n\n    {{#weitere Links}}\n    <span id=\"hint-linkcontainer\" class=\"hintBtn\" data-name=\"linkContainer\" style=\"display: none;\">\n      <button id=\"button-linkcontainer\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-linkcontainer'); event.stopPropagation()\">\n        <img src=\"__internet.svg\" style=\"height: 10px;\"> weitere Links\n      </button>\n      <div id=\"linkcontainer\" class=\"hints\" style=\"display: none;\"></div>\n      <span id=\"linkContainerLinks\" style=\"display: none;\">{{edit:weitere Links}}</span>\n    </span>\n    {{/weitere Links}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n  try {\n    for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n      href = link.href\n      text = link.innerText\n\n      const el = document.createElement('a');\n      el.setAttribute('href', link.href);\n\n      const btn = document.createElement('button');\n      btn.classList.add('button-general');\n      btn.classList.add('expanded-button');\n\n      domain = href.replace(/.+\\/\\/|(www|flexikon|register|de|next|com).|\\..+/g, '');\n      domainDict = {\n        \"amboss\": \"__amboss.svg\",\n        \"wikipedia\": \"__wikipedia.svg\",\n        \"doccheck\": \"__doccheck.png\",\n        \"notfallguru\": \"__notfallguru.svg\",\n        \"awmf\": \"__awmf.svg\",\n        \"gelbe-liste\": \"__gelbe-liste.png\",\n        \"embryotox\": \"__embryotox.svg\",\n        \"radiopaedia\": \"__radiopaedia.png\",\n        \"orphanet\": \"__orphanet.png\",\n      }\n      if (domain in domainDict) {\n        icon = domainDict[domain]\n      } else {\n        icon = \"__internet.svg\"\n      }\n\n      const img = document.createElement('img');\n      img.setAttribute('src', icon);\n      img.setAttribute('style', 'height: 10px;');\n\n      btn.appendChild(img);\n      btn.innerHTML = btn.innerHTML + \" \" + text;\n\n      el.appendChild(btn);\n\n      document.getElementById(\"linkcontainer\").appendChild(el)\n    }\n  }\n  catch (err) {\n    console.log(err)\n  }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-uafi\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- AUTOFLIP BACK SCRIPT -->\n<script>\n  // autoflip hides card in front template\n  document.getElementById(\"qa\").style.removeProperty(\"display\")\n</script>\n\n<!-- CLOZE ONE BY ONE SCRIPT -->\n<style>\n  .cloze-replacer:hover {\n    cursor: pointer;\n  }\n\n  .cloze-hidden {\n    display: none;\n  }\n\n  .cloze-replacer .hidden {\n    display: none;\n  }\n\n  #extra.hidden {\n    display: none;\n  }\n</style>\n\n<!--\n Based on the AnKing Notetype, but expanded and modified by phyn.\n Credit to the original authors, except where modified or otherwise indicated.\n-->\n\n<script>\n    (function () {\n      // enables cloze one-by-one even when one-by-one field is empty\n      // minNumberOfClozes is still considered in this case\n      // overridden in importance by selectiveOneByOne\n      var clozeOneByOneEnabled = true;\n\n      // remove the clickAnywhere function from global scope\n      document.documentElement.removeAttribute(\"onclick\")\n\n      // --- CHECK IF ONE BY ONE IS GENERALLY ENABLED FOR THIS NOTE ---\n      var oneByOneFieldNotEmpty = \"{{One by one}}\" !== \"\";\n      try {\n        clozeOneByOneEnabled = alwaysOneByOne || oneByOneFieldNotEmpty;\n      } catch (exception) {\n        console.log(exception)\n      }\n\n      /**\n   * helper functions to show / hide fields containing additional information\n   */\n      const showExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const hideExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const buttonIds = [\n        \"hint-zusatz\",\n        \"hint-definition\",\n        \"hint-hammer\",\n        \"hint-klinik\",\n        \"hint-praeparat\",\n        \"hint-microscope\",\n        \"hint-smartzoom\",\n        \"hint-histotrainer\",\n        \"hint-uafi\",\n        \"hint-merksprueche\",\n        \"hint-memes\",\n        \"hint-image\",\n        \"hint-amboss\",\n        \"hint-thieme\",\n        \"hint-meditricks\",\n        \"hint-linkcontainer\",\n      ];\n\n      const showExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document\n              .getElementById(buttonIds[button])\n              .style.removeProperty(\"display\");\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n      const hideExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document.getElementById(buttonIds[button]).style.display = \"none\";\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n\n      // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n      /**\n       * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n       */\n      const getCardNumber = function () {\n        clz = document.body.className;\n        const regex = /card(\\d+)/gm;\n\n        let clz2;\n        try {\n          clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n        } catch (e) {\n          clz2 = \"\";\n        }\n        const regex2 = /.*?Cloze(\\d+)/gm;\n\n        let m;\n\n        if ((m = regex2.exec(clz2)) !== null) {\n          return m[1];\n        } else if ((m = regex.exec(clz)) !== null) {\n          return m[1];\n        } else {\n          // Should only fire if card is not cloze\n          console.error(\"Cannot find cardN class of body element!\");\n          return \"0\";\n        }\n      }\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (!clozeOneByOneEnabled) {\n        showExtra()\n        showExtraButtons()\n        document.getElementById(\"onebyone-buttons\").style.display = \"none\"\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n        return\n      }\n\n      // Needed for amboss to recognize first word in .cloze-hidden\n      const CLOZE_REPLACER_SEP = \"<span class='hidden'> </span>\"\n\n      const hideAllCloze = function (initial) {\n        let clozes = document.getElementsByClassName(\"cloze\")\n        let count = 0 // hidden cloze count\n        for (const cloze of clozes) {\n          const existingHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n          if (existingHidden) {\n            revealCloze(cloze);\n          }\n          if (cloze.offsetWidth === 0) {\n            continue\n          }\n          const clozeReplacer = document.createElement(\"span\")\n          const clozeHidden = document.createElement(\"span\")\n          clozeReplacer.classList.add(\"cloze-replacer\")\n          clozeHidden.classList.add(\"cloze-hidden\")\n          while (cloze.childNodes.length > 0) {\n            clozeHidden.appendChild(cloze.childNodes[0])\n          }\n          cloze.appendChild(clozeReplacer)\n          cloze.appendChild(clozeHidden)\n\n          var clozeHints = Persistence.getItem(\"clozeHints\");\n          if (clozeHints && clozeHints[count]) {\n            clozeReplacer.classList.add(\"cloze-hint\")\n            clozeReplacer.innerHTML = clozeHints[count] + CLOZE_REPLACER_SEP\n          } else {\n            clozeReplacer.innerHTML = clozeHider(cloze) + CLOZE_REPLACER_SEP\n          }\n          count += 1\n          document.getElementById(\"button-reveal-next\").style.display = \"inline-block\";\n          if (initial) {\n            cloze.addEventListener(\"touchend\", revealClozeClicked)\n            cloze.addEventListener(\"click\", revealClozeClicked)\n            cloze.classList.add(\"one-by-one\");\n          }\n        }\n\n        // Hide #extra until all clozes are shown\n        const extra = document.getElementById(\"extra\");\n        if (extra) {\n          extra.classList.add(\"hidden\");\n        }\n\n        hideExtra();\n        hideExtraButtons();\n        if (revealAnywhere) {\n          document.documentElement.setAttribute(\"onclick\", \"revealNextCloze(); event.stopPropagation()\")\n        }\n\n\n        // Also hide autoReveal fields\n        for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n          const container = document.querySelector(`[data-name=\"${field}\"]`)\n          if (container) {\n            const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n            if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n              // const link = container.getElementsByTagName(\"a\")[0]\n              const button = container.getElementsByTagName(\"button\")[0]\n              const hint = container.getElementsByTagName(\"div\")[0]\n              button.classList.remove(\"expanded-button\")\n              hint.style.display = \"none\"\n              // link.style.display = \"\"\n            }\n          }\n        }\n      }\n\n      const revealCloze = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        cloze.removeChild(clozeReplacer)\n        cloze.removeChild(clozeHidden)\n        while (clozeHidden.childNodes.length > 0) {\n          cloze.appendChild(clozeHidden.childNodes[0])\n        }\n        maybeRevealExtraField()\n      }\n\n      const revealClozeWord = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        let range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundSpace = setRangeEnd(range, clozeHidden, \"beforeFirstSpace\")\n        if (!foundSpace) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        let fragment = range.extractContents()\n        cloze.insertBefore(fragment, clozeReplacer)\n        // Extract whitespaces after word\n        range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundWord = setRangeEnd(range, clozeHidden, \"beforeFirstChar\")\n        if (!foundWord) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        fragment = range.extractContents();\n        cloze.insertBefore(fragment, clozeReplacer)\n        if (!foundWord) {\n          cloze.removeChild(clozeHidden)\n          cloze.removeChild(clozeReplacer)\n          maybeRevealExtraField()\n          return\n        }\n        clozeReplacer.innerHTML = clozeHider(clozeHidden) + CLOZE_REPLACER_SEP\n        if (clozeReplacer.classList.contains(\"cloze-hint\")) [\n          clozeReplacer.classList.remove(\"cloze-hint\")\n        ]\n        maybeRevealExtraField()\n      }\n\n      const revealNextClozeOf = (type) => {\n        const nextHidden = document.querySelectorAll(\".cloze-hidden\")\n        const nextNextHidden = nextHidden.length > 1 ? true : false\n        if (!nextNextHidden) {\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\";\n        }\n        if (!nextHidden) {\n          return\n        }\n        const cloze = clozeElOfClozeHidden(nextHidden[0]);\n        if (type === \"word\") {\n          revealClozeWord(cloze)\n        } else if (type === \"cloze\") {\n          revealCloze(cloze)\n        } else {\n          console.error(\"Invalid type: \" + type)\n        }\n      }\n\n      const revealClozeClicked = function (ev) {\n        let elem = ev.currentTarget\n        if (!ev.altKey && (revealNextClozeMode !== \"word\")) {\n          revealCloze(elem)\n        } else {\n          revealClozeWord(elem)\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      }\n\n      window.revealNextCloze = function () {\n        revealNextClozeOf(revealNextClozeMode)\n      }\n\n      window.toggleAllCloze = function () {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length > 0) {\n          for (const elem of elems) {\n            const cloze = clozeElOfClozeHidden(elem)\n            revealCloze(cloze)\n          }\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\"\n        } else {\n          hideAllCloze(initial = false)\n        }\n      }\n\n      const clozeElOfClozeHidden = (cloze) => {\n        while (!cloze.classList.contains(\"cloze\")) {\n          cloze = cloze.parentElement;\n        }\n        return cloze;\n      }\n\n      const maybeRevealExtraField = () => {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length == 0) {\n          const extra = document.getElementById(\"extra\")\n          if (extra) {\n            extra.classList.remove(\"hidden\")\n          }\n\n          showExtra();\n          showExtraButtons();\n          document.documentElement.removeAttribute(\"onclick\")\n\n          // Also reveal autoReveal fields\n          for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n            const container = document.querySelector(`[data-name=\"${field}\"]`)\n            if (container) {\n              const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n              if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n                // const link = container.getElementsByTagName(\"a\")[0]\n                const button = container.getElementsByTagName(\"button\")[0]\n                const hint = container.getElementsByTagName(\"div\")[0]\n                button.classList.add(\"expanded-button\")\n                hint.style.display = \"block\"\n                // link.style.display = \"none\"\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * mode: 'beforeFirstSpace' or 'beforeFirstChar'\n       * Return `true` if it exists and setEnd() was called, otherwise `false`\n       */\n      const setRangeEnd = function (range, node, mode) {\n        if (node.nodeType === Node.TEXT_NODE) {\n          const regex = mode === 'beforeFirstSpace' ? /\\s/ : /\\S/\n          const match = node.textContent.match(regex)\n          if (match) {\n            if (match.index === 0) {\n              while (node.previousSibling === null) {\n                node = node.parentElement\n              }\n              range.setEndBefore(node)\n            } else {\n              range.setEnd(node, match.index);\n            }\n            return true;\n          } else {\n            return false;\n          }\n        } else if (mode === 'beforeFirstChar' && isCharNode(node)) {\n          range.setEndBefore(node)\n          return true\n        } else if (!ignoreSpaceInNode(node)) {\n          for (const child of node.childNodes) {\n            if (setRangeEnd(range, child, mode)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }\n\n      const ignoreSpaceInNode = function (node) {\n        return node.tagName === \"MJX-ASSISTIVE-MML\"\n      }\n\n      const isCharNode = function (node) {\n        return [\"IMG\", \"MJX-CONTAINER\"].includes(node.tagName)\n      }\n\n      hideAllCloze(initial = true)\n\n      let isShowNextShortcut = shortcutMatcher(window.revealNextShortcut)\n      let isShowWordShortcut = shortcutMatcher(window.revealNextWordShortcut)\n      let isToggleAllShortcut = shortcutMatcher(window.toggleAllShortcut)\n      ankingAddEventListener(\"keydown\", (ev) => {\n        let next = isShowNextShortcut(ev)\n        let word = isShowWordShortcut(ev)\n        let all = isToggleAllShortcut(ev)\n        if (next) {\n          revealNextClozeOf(\"cloze\")\n        } else if (word) {\n          revealNextClozeOf(\"word\")\n        } else if (all) {\n          toggleAllCloze()\n        } else {\n          return;\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      });\n    })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- MEDITRICKS SNIPPETS DATA -->\n<div id=\"meditricks-mtsp-values\" style=\"display:none;\">\n  <div id=\"meditricks-mtsp-nfname\">_meditricks_nf_v1000_ankizin</div>\n  <div id=\"meditricks-mtsp-nid\">{{Note ID}}</div>\n</div>\n<script src=\"_meditricks_mtsp_scripts_v1000_ankizin.js\"></script>\n<link href=\"_meditricks_mtsp_styles_v1000_ankizin.css\" rel=\"stylesheet\" />\n\n<!-- include \"_meditricks_mtsp_nf_v1000_ankizin.js\" -->\n<!-- include \"_meditricks_mtsp_scripts_v1000_iframe.map\" -->\n<!-- include \"_meditricks_mtsp_mtlogo.webp\" -->\n<!-- include \"_meditricks_mtsp_mt-loading.png\" -->\n<!-- include \"_meditricks_mtsp_mt-loading_night.png\" -->\n\n<!-- //MEDITRICKS SNIPPETS DATA -->\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>",
      "bqfmt": "{{Muskel / Leitungsbahn}}",
      "bafmt": "{{Innervation}}",
      "bfont": "Helvetica",
      "bsize": 12
    },
    {
      "name": "InnervationCloze2",
      "ord": 19,
      "qfmt": "<!-- version f0935e4 -->\n{{#Innervation}}\n{{#InnervationCloze2}}\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TIMER CONFIG  ##############\n  // Timer config (timer length, timer finished message)\n  var minutes = 0\n  var seconds = 15\n  var timeOverMsg = \"<span style='color:#CC5B5B'>!!!</span>\"\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  // Auto flip to back when One by one mode.\n  var autoflip = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Was ist die <i>Innervation</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" data-card=\"{{Card}}\"><br>{{Innervation}}</div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\"></div>\n\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<script>\n  //DONT FADE BETWEEN CARDS\n  qFade = 0;\n  if (typeof anki !== 'undefined') anki.qFade = qFade;\n</script>\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    if (!indentation) { return; }\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- CLOZE ONE BY ONE FRONT -->\n<div id=\"one-by-one\" style=\"display: none;\"></div>\n\n<script>\n  /**\n   * Based on the AnKing Notetype, but expanded and modified by phyn.\n   * Credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  Persistence.clear();\n\n  // check if OneByOne is generally enabled for this card\n  var oneByOneFieldEmpty = selectiveOneByOne ? \"{{One by one}}\" === \"\" : true;\n  var clozeOneByOneEnabled = alwaysOneByOne ? true : !oneByOneFieldEmpty;\n\n  // avoid flickering. Must unset this in the back.\n  document.getElementById(\"qa\").style.display = \"none\";\n  var clozeHints = [];\n\n  if (clozeOneByOneEnabled) {\n    // collect hints from front side (independent of whether or not OneByOne is enabled)\n    document.getElementById(\"qa\").classList.add('one-by-one');\n    // Save cloze hints to display in the back\n    var clozes = document.getElementsByClassName(\"cloze\")\n    for (var i = 0; i < clozes.length; i++) {\n      clozes[i].classList.add(\"one-by-one\");\n      if (clozes[i].innerHTML === \"[...]\") {\n        clozeHints.push(\"\")\n      } else {\n        clozeHints.push(clozes[i].innerHTML)\n      }\n    }\n\n    // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n    /**\n     * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n     */\n    const getCardNumber = function () {\n      clz = document.body.className;\n      const regex = /card(\\d+)/gm;\n\n      let clz2;\n      try {\n        clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n      } catch (e) {\n        clz2 = \"\";\n      }\n      const regex2 = /.*?Cloze(\\d+)/gm;\n\n      let m;\n\n      if ((m = regex2.exec(clz2)) !== null) {\n        return m[1];\n      } else if ((m = regex.exec(clz)) !== null) {\n        return m[1];\n      } else {\n        // Should only fire if card is not cloze\n        console.error(\"Cannot find cardN class of body element!\");\n        return \"0\";\n      }\n    }\n\n    var alreadyRendered = false;\n\n    function processSelective1b1() {\n      if (alreadyRendered) return;\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (autoflip && clozeOneByOneEnabled) {\n        if (window.pycmd || window.showAnswer) {\n          // avoid flickering. Must unset this in the back.\n          document.getElementById(\"qa\").style.display = \"none\";\n        }\n        if (window.pycmd) {\n          pycmd(\"ans\")\n        } else if (window.showAnswer) {\n          showAnswer()\n        }\n      } else {\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n      }\n      // AnkiMobile JS API doesn't have one for show answer.\n      // Best alternative is to use Taps/Swipes to show answer.\n\n      alreadyRendered = true;\n    }\n\n    function delayedProcessSelective1b1() {\n      if (window.requestAnimationFrame) window.requestAnimationFrame(processSelective1b1); // less flickering\n      else window.setTimeout(processSelective1b1, 0);\n    };\n\n    window.onload = delayedProcessSelective1b1;\n    if (document.readyState === \"complete\") {\n      delayedProcessSelective1b1();\n    }\n    else {\n      document.addEventListener(\"DOMContentLoaded\", delayedProcessSelective1b1);\n    }\n\n    // Observe document.body class changes to trigger re-rendering.\n    // This is useful, because Anki doesn’t always start with an up-to-date class list:\n    // https://forums.ankiweb.net/t/card-card-classes-only-injected-separately-now/27387.\n    const observer = new MutationObserver(function (mutationsList, observer) {\n      for (let mutation of mutationsList) {\n        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {\n          delayedProcessSelective1b1();\n        }\n      }\n    });\n    observer.observe(document.body, { attributes: true });\n  }\n  Persistence.setItem(\"clozeHints\", clozeHints);\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>\n\n\n{{/InnervationCloze2}}\n{{/Innervation}}",
      "afmt": "<!-- version f0935e4 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n<div id=\"back\"></div>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Eigene Notizen & Bilder\": \"Alt + 1\",\n    \"Eigene Prüfungsfragen\": \"Alt + 2\",\n    \"Definitionen\": \"Alt + 3\",\n    \"Merksprüche\": \"Alt + 4\",\n    \"Klinik\": \"Alt + 5\",\n    \"Präparat\": \"Alt + 6\",\n    \"Memes\": \"Alt + 7\",\n    \"linkContainer\": \"Alt + L\",\n    \"Meditricks\": \"Alt + M\",\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Eigene Notizen & Bilder\": false,\n    \"Eigene Prüfungsfragen\": false,\n    \"Definitionen\": false,\n    \"Merksprüche\": false,\n    \"Klinik\": false,\n    \"Präparat\": false,\n    \"Memes\": false,\n    \"linkContainer\": true,\n    \"Meditricks\": false,\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  var revealNextShortcut = \"N\"\n  var revealNextWordShortcut = \"Shift + N\"\n  var toggleAllShortcut = \",\"\n\n  // Enables revealing of next Cloze by simply clicking / tapping anywhere on the card (except the buttons)\n  var revealAnywhere = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // Changes how \"Reveal Next\" and clicking behaves. Either \"cloze\" or \"word\".\n  // \"word\" reveals word by word. \n  var revealNextClozeMode = \"cloze\"\n\n  // Changes how fields with additional information are displayed.\n  // true displays fields with additional information only if all clozes are revealed.\n  var hideAdditional = true;\n  var hideAdditionalButtons = true;\n\n  // What cloze is hidden with\n  var clozeHider = (elem) => \"[&nbsp;_&nbsp;]\"\n  /*\n  You can replace the above line with below examples. '█' or '_' works well for hiding clozes.\n  \n  // Fixed length:\n  var clozeHider = (elem) => \"███\"\n  // Replace each character with \"█\":\n  var clozeHider = (elem) => \"█\".repeat(elem.textContent.length)\n  // Show whitespaces:\n  var clozeHider = (elem) => \"[\" + elem.textContent.split(\" \").map((t) => \"█\".repeat(t.length)).join(\" \") + \"]\"\n  // Color-filled box (doesn't hide images):\n  var clozeHider = (elem) => `<span style=\"background-color: red; color: transparent;\">${elem.innerHTML}</span>`\n  */\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Was ist die <i>Innervation</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" class=\"clozefield\" data-card=\"{{Card}}\"><br>{{Innervation}}</div>\n\n    <!-- ClOZE ONE BY ONE BUTTONS -->\n    <div id=\"onebyone-buttons\" class=\"onebyone\">\n      <br>\n      <button id=\"button-reveal-next\" class=\"button-general button-one-by-one\"\n        onclick=\"revealNextCloze(); event.stopPropagation()\">Reveal Next</button>\n      <button id=\"button-toggle-all\" class=\"button-general button-one-by-one\"\n        onclick=\"toggleAllCloze(); event.stopPropagation()\">Toggle All</button>\n    </div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- BUTTON FIELDS -->\n    {{#Eigene Notizen & Bilder}}\n    <span id=\"hint-zusatz\" class=\"hintBtn\" data-name=\"Eigene Notizen & Bilder\" style=\"display: none;\">\n      <button id=\"button-zusatz\" class=\"button-general\" onclick=\"toggleHintBtn('hint-zusatz'); event.stopPropagation()\">\n        <img src=\"__zusatz.svg\" style=\"height: 10px;\"> Eigene Notizen & Bilder\n      </button>\n      <div dir=\"auto\" id=\"zusatz\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Notizen & Bilder}}</div>\n    </span>\n    {{/Eigene Notizen & Bilder}}\n\n    {{#Eigene Prüfungsfragen}}\n    <span id=\"hint-hammer\" class=\"hintBtn\" data-name=\"Eigene Prüfungsfragen\" style=\"display: none;\">\n      <button id=\"button-hammer\" class=\"button-general\" onclick=\"toggleHintBtn('hint-hammer'); event.stopPropagation()\">\n        <img src=\"__hammer.svg\" style=\"height: 10px;\"> Eigene Prüfungsfragen\n      </button>\n      <div dir=\"auto\" id=\"hammer\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Prüfungsfragen}}</div>\n    </span>\n    {{/Eigene Prüfungsfragen}}\n\n    {{#Definitionen}}\n    <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Definitionen\" style=\"display: none;\">\n      <button id=\"button-definition\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Definitionen\n      </button>\n      <div dir=\"auto\" id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Definitionen}}</div>\n    </span>\n    {{/Definitionen}}\n\n    {{#Merksprüche}}\n    <span id=\"hint-merksprueche\" class=\"hintBtn\" data-name=\"Merksprüche\" style=\"display: none;\">\n      <button id=\"button-merksprueche\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-merksprueche'); event.stopPropagation()\">\n        <img src=\"__merkhilfe.svg\" style=\"height: 10px;\"> Merksprüche\n      </button>\n      <div dir=\"auto\" id=\"merksprueche\" class=\"hints\" style=\"display: none;\">{{edit:Merksprüche}}</div>\n    </span>\n    {{/Merksprüche}}\n\n    {{#Klinik}}\n    <span id=\"hint-klinik\" class=\"hintBtn\" data-name=\"Klinik\" style=\"display: none;\">\n      <button id=\"button-klinik\" class=\"button-general\" onclick=\"toggleHintBtn('hint-klinik'); event.stopPropagation()\">\n        <img src=\"__stethoscope.svg\" style=\"height: 10px;\"> Klinik\n      </button>\n      <div dir=\"auto\" id=\"klinik\" class=\"hints\" style=\"display: none;\">{{edit:Klinik}}</div>\n    </span>\n    {{/Klinik}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-praeparat\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n        </button>\n      </a>\n    </span>\n    {{/Präparat}}\n\n    {{#Virtuelle Mikroskopie}}\n    <span id=\"hint-microscope-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Virtuelle Mikroskopie}}\">\n        <button id=\"button-microscope\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Virtuelle Mikroskopie\n        </button>\n      </a>\n    </span>\n    {{/Virtuelle Mikroskopie}}\n\n    {{#Smart Zoom}}\n    <span id=\"hint-smartzoom-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-smartzoom\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Smart Zoom\n        </button>\n      </a>\n    </span>\n    {{/Smart Zoom}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat\" class=\"hintBtn\" data-name=\"Präparat\" style=\"display: none;\">\n      <button id=\"button-praeparat\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-praeparat'); event.stopPropagation()\">\n        <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n      </button>\n      <div dir=\"auto\" id=\"praeparat\" class=\"hints\" style=\"display: none;\">{{edit:Präparat}}</div>\n    </span>\n    {{/Präparat}}\n\n    {{#Memes}}\n    <span id=\"hint-memes\" class=\"hintBtn\" data-name=\"Memes\" style=\"display: none;\">\n      <button id=\"button-memes\" class=\"button-general\" onclick=\"toggleHintBtn('hint-memes'); event.stopPropagation()\">\n        <img src=\"__sonstiges.svg\" style=\"height: 10px;\"> Memes\n      </button>\n      <div dir=\"auto\" id=\"memes\" class=\"hints\" style=\"display: none;\">{{edit:Memes}}</div>\n    </span>\n    {{/Memes}}\n\n    <!-- LINEBREAKS IF BUTTONS EXIST -->\n    <script>\n      var array = [`{{Eigene Notizen & Bilder}}`, `{{Eigene Prüfungsfragen}}`, `{{Definitionen}}`, `{{Merksprüche}}`, `{{Klinik}}`, `{{Präparat}}`, `{{Memes}}`];\n      var anyistrue = (element) => element;\n      if (array.some(anyistrue)) {\n        document.getElementById(\"linebreaksIfButtons\").innerHTML = \"<br>\";\n      }\n    </script>\n    <div id=\"linebreaksIfButtons\"></div>\n\n    <!-- Extra field -->\n    {{#Extra}}\n    <div id=\"extra\" style=\"display: none;\">\n      <br>{{edit:Extra}}<br><br>\n    </div>\n    {{/Extra}}\n\n    <!-- Image field -->\n    {{#Bild}}\n    <div id=\"image\" style=\"display: none;\">\n      {{edit:Bild}}<br><br></div>\n    {{/Bild}}\n    {{^Bild}}\n    <span id=\"image\" style=\"display: none;\"></span>\n    {{/Bild}}\n    {{#Bild}}\n    <span id=\"hint-image\" style=\"display: none;\">\n      <button id=\"button-image\" class=\"button-general\"\n        onclick=\"var image = document.getElementById('image'); if (image.style.display == 'none') { image.style.display = 'block' } else { image.style.display = 'none' }; event.stopPropagation()\">\n        <img src=\"__image.svg\" style=\"height: 10px;\"> Abbildung\n      </button>\n    </span>\n    {{/Bild}}\n\n    <span id=\"hint-uafi\" class=\"hintBtn\" data-name=\"Ursprung, Ansatz, Verlauf, Funktion, Innervation, Äste\"\n      style=\"display: none;\">\n      <button id=\"button-uafi\" class=\"button-general expanded-button\"\n        onclick=\"toggleHintBtn('hint-uafi'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Weitere Informationen\n      </button>\n      <div id=\"uafi\" class=\"hints\" style=\"display: block;\">\n        <table class=\"uncloze\">\n          {{#Ursprung}}\n          <tr class=\"uafi-element\" id=\"Ursprung\">\n            <td><i>Ursprung</i></td>\n            <td>{{Ursprung}}</td>\n          </tr>\n          {{/Ursprung}}\n          {{#Ansatz}}\n          <tr class=\"uafi-element\" id=\"Ansatz\">\n            <td><i>Ansatz</i></td>\n            <td>{{Ansatz}}</td>\n          </tr>\n          {{/Ansatz}}\n          {{#Verlauf}}\n          <tr class=\"uafi-element\" id=\"Verlauf\">\n            <td><i>Verlauf</i></td>\n            <td>{{Verlauf}}</td>\n          </tr>\n          {{/Verlauf}}\n          {{#Funktion}}\n          <tr class=\"uafi-element\" id=\"Funktion\">\n            <td><i>Funktion</i></td>\n            <td>{{Funktion}}</td>\n          </tr>\n          {{/Funktion}}\n          {{#Innervation}}\n          <tr class=\"uafi-element\" id=\"Innervation\">\n            <td><i>Innervation</i></td>\n            <td>{{Innervation}}</td>\n          </tr>\n          {{/Innervation}}\n          {{#Äste}}\n          <tr class=\"uafi-element\" id=\"Äste\">\n            <td><i>Äste</i></td>\n            <td>{{Äste}}</td>\n          </tr>\n          {{/Äste}}\n        </table>\n      </div>\n\n      <script>\n        // iterate over all uafi-elements and hide only the one\n        // that is equal to the card's answer (i.e., value of {{Card}})\n        var uafiElements = document.getElementsByClassName(\"uafi-element\");\n        for (var i = 0; i < uafiElements.length; i++) {\n          if (((\"{{Card}}\").startsWith(uafiElements[i].id))) {\n            uafiElements[i].remove()\n          }\n        }\n      </script>\n    </span>\n\n    {{#AMBOSS-Link}}\n    <span id=\"hint-amboss\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:AMBOSS-Link}}\">\n        <button id=\"button-amboss\" class=\"button-general\">\n          <img src=\"__amboss.svg\" style=\"height: 10px;\"> AMBOSS&#8203;\n        </button>\n      </a>\n    </span>\n    {{/AMBOSS-Link}}\n\n    {{#Thieme via medici-Link}}\n    <span id=\"hint-thieme\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Thieme via medici-Link}}\">\n        <button id=\"button-thieme\" class=\"button-general\">\n          <img id=\"button-thieme-img\" src=\"__thieme-heart.svg\" style=\"height: 10px;\"> Thieme via medici\n        </button>\n      </a>\n    </span>\n    {{/Thieme via medici-Link}}\n\n    {{#Meditricks}}\n    <span id=\"hint-meditricks\" class=\"hintBtn\" data-name=\"Meditricks\" style=\"display: none;\">\n      <button id=\"button-meditricks\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-meditricks'); event.stopPropagation()\">\n        <img src=\"__meditricks.svg\" style=\"height: 10px;\"> Meditricks\n      </button>\n      <div dir=\"auto\" id=\"meditricks\" class=\"hints\" style=\"display: none;\">{{edit:Meditricks}}</div>\n    </span>\n    {{/Meditricks}}\n\n    {{#weitere Links}}\n    <span id=\"hint-linkcontainer\" class=\"hintBtn\" data-name=\"linkContainer\" style=\"display: none;\">\n      <button id=\"button-linkcontainer\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-linkcontainer'); event.stopPropagation()\">\n        <img src=\"__internet.svg\" style=\"height: 10px;\"> weitere Links\n      </button>\n      <div id=\"linkcontainer\" class=\"hints\" style=\"display: none;\"></div>\n      <span id=\"linkContainerLinks\" style=\"display: none;\">{{edit:weitere Links}}</span>\n    </span>\n    {{/weitere Links}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n  try {\n    for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n      href = link.href\n      text = link.innerText\n\n      const el = document.createElement('a');\n      el.setAttribute('href', link.href);\n\n      const btn = document.createElement('button');\n      btn.classList.add('button-general');\n      btn.classList.add('expanded-button');\n\n      domain = href.replace(/.+\\/\\/|(www|flexikon|register|de|next|com).|\\..+/g, '');\n      domainDict = {\n        \"amboss\": \"__amboss.svg\",\n        \"wikipedia\": \"__wikipedia.svg\",\n        \"doccheck\": \"__doccheck.png\",\n        \"notfallguru\": \"__notfallguru.svg\",\n        \"awmf\": \"__awmf.svg\",\n        \"gelbe-liste\": \"__gelbe-liste.png\",\n        \"embryotox\": \"__embryotox.svg\",\n        \"radiopaedia\": \"__radiopaedia.png\",\n        \"orphanet\": \"__orphanet.png\",\n      }\n      if (domain in domainDict) {\n        icon = domainDict[domain]\n      } else {\n        icon = \"__internet.svg\"\n      }\n\n      const img = document.createElement('img');\n      img.setAttribute('src', icon);\n      img.setAttribute('style', 'height: 10px;');\n\n      btn.appendChild(img);\n      btn.innerHTML = btn.innerHTML + \" \" + text;\n\n      el.appendChild(btn);\n\n      document.getElementById(\"linkcontainer\").appendChild(el)\n    }\n  }\n  catch (err) {\n    console.log(err)\n  }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-uafi\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- AUTOFLIP BACK SCRIPT -->\n<script>\n  // autoflip hides card in front template\n  document.getElementById(\"qa\").style.removeProperty(\"display\")\n</script>\n\n<!-- CLOZE ONE BY ONE SCRIPT -->\n<style>\n  .cloze-replacer:hover {\n    cursor: pointer;\n  }\n\n  .cloze-hidden {\n    display: none;\n  }\n\n  .cloze-replacer .hidden {\n    display: none;\n  }\n\n  #extra.hidden {\n    display: none;\n  }\n</style>\n\n<!--\n Based on the AnKing Notetype, but expanded and modified by phyn.\n Credit to the original authors, except where modified or otherwise indicated.\n-->\n\n<script>\n    (function () {\n      // enables cloze one-by-one even when one-by-one field is empty\n      // minNumberOfClozes is still considered in this case\n      // overridden in importance by selectiveOneByOne\n      var clozeOneByOneEnabled = true;\n\n      // remove the clickAnywhere function from global scope\n      document.documentElement.removeAttribute(\"onclick\")\n\n      // --- CHECK IF ONE BY ONE IS GENERALLY ENABLED FOR THIS NOTE ---\n      var oneByOneFieldNotEmpty = \"{{One by one}}\" !== \"\";\n      try {\n        clozeOneByOneEnabled = alwaysOneByOne || oneByOneFieldNotEmpty;\n      } catch (exception) {\n        console.log(exception)\n      }\n\n      /**\n   * helper functions to show / hide fields containing additional information\n   */\n      const showExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const hideExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const buttonIds = [\n        \"hint-zusatz\",\n        \"hint-definition\",\n        \"hint-hammer\",\n        \"hint-klinik\",\n        \"hint-praeparat\",\n        \"hint-microscope\",\n        \"hint-smartzoom\",\n        \"hint-histotrainer\",\n        \"hint-uafi\",\n        \"hint-merksprueche\",\n        \"hint-memes\",\n        \"hint-image\",\n        \"hint-amboss\",\n        \"hint-thieme\",\n        \"hint-meditricks\",\n        \"hint-linkcontainer\",\n      ];\n\n      const showExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document\n              .getElementById(buttonIds[button])\n              .style.removeProperty(\"display\");\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n      const hideExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document.getElementById(buttonIds[button]).style.display = \"none\";\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n\n      // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n      /**\n       * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n       */\n      const getCardNumber = function () {\n        clz = document.body.className;\n        const regex = /card(\\d+)/gm;\n\n        let clz2;\n        try {\n          clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n        } catch (e) {\n          clz2 = \"\";\n        }\n        const regex2 = /.*?Cloze(\\d+)/gm;\n\n        let m;\n\n        if ((m = regex2.exec(clz2)) !== null) {\n          return m[1];\n        } else if ((m = regex.exec(clz)) !== null) {\n          return m[1];\n        } else {\n          // Should only fire if card is not cloze\n          console.error(\"Cannot find cardN class of body element!\");\n          return \"0\";\n        }\n      }\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (!clozeOneByOneEnabled) {\n        showExtra()\n        showExtraButtons()\n        document.getElementById(\"onebyone-buttons\").style.display = \"none\"\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n        return\n      }\n\n      // Needed for amboss to recognize first word in .cloze-hidden\n      const CLOZE_REPLACER_SEP = \"<span class='hidden'> </span>\"\n\n      const hideAllCloze = function (initial) {\n        let clozes = document.getElementsByClassName(\"cloze\")\n        let count = 0 // hidden cloze count\n        for (const cloze of clozes) {\n          const existingHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n          if (existingHidden) {\n            revealCloze(cloze);\n          }\n          if (cloze.offsetWidth === 0) {\n            continue\n          }\n          const clozeReplacer = document.createElement(\"span\")\n          const clozeHidden = document.createElement(\"span\")\n          clozeReplacer.classList.add(\"cloze-replacer\")\n          clozeHidden.classList.add(\"cloze-hidden\")\n          while (cloze.childNodes.length > 0) {\n            clozeHidden.appendChild(cloze.childNodes[0])\n          }\n          cloze.appendChild(clozeReplacer)\n          cloze.appendChild(clozeHidden)\n\n          var clozeHints = Persistence.getItem(\"clozeHints\");\n          if (clozeHints && clozeHints[count]) {\n            clozeReplacer.classList.add(\"cloze-hint\")\n            clozeReplacer.innerHTML = clozeHints[count] + CLOZE_REPLACER_SEP\n          } else {\n            clozeReplacer.innerHTML = clozeHider(cloze) + CLOZE_REPLACER_SEP\n          }\n          count += 1\n          document.getElementById(\"button-reveal-next\").style.display = \"inline-block\";\n          if (initial) {\n            cloze.addEventListener(\"touchend\", revealClozeClicked)\n            cloze.addEventListener(\"click\", revealClozeClicked)\n            cloze.classList.add(\"one-by-one\");\n          }\n        }\n\n        // Hide #extra until all clozes are shown\n        const extra = document.getElementById(\"extra\");\n        if (extra) {\n          extra.classList.add(\"hidden\");\n        }\n\n        hideExtra();\n        hideExtraButtons();\n        if (revealAnywhere) {\n          document.documentElement.setAttribute(\"onclick\", \"revealNextCloze(); event.stopPropagation()\")\n        }\n\n\n        // Also hide autoReveal fields\n        for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n          const container = document.querySelector(`[data-name=\"${field}\"]`)\n          if (container) {\n            const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n            if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n              // const link = container.getElementsByTagName(\"a\")[0]\n              const button = container.getElementsByTagName(\"button\")[0]\n              const hint = container.getElementsByTagName(\"div\")[0]\n              button.classList.remove(\"expanded-button\")\n              hint.style.display = \"none\"\n              // link.style.display = \"\"\n            }\n          }\n        }\n      }\n\n      const revealCloze = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        cloze.removeChild(clozeReplacer)\n        cloze.removeChild(clozeHidden)\n        while (clozeHidden.childNodes.length > 0) {\n          cloze.appendChild(clozeHidden.childNodes[0])\n        }\n        maybeRevealExtraField()\n      }\n\n      const revealClozeWord = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        let range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundSpace = setRangeEnd(range, clozeHidden, \"beforeFirstSpace\")\n        if (!foundSpace) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        let fragment = range.extractContents()\n        cloze.insertBefore(fragment, clozeReplacer)\n        // Extract whitespaces after word\n        range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundWord = setRangeEnd(range, clozeHidden, \"beforeFirstChar\")\n        if (!foundWord) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        fragment = range.extractContents();\n        cloze.insertBefore(fragment, clozeReplacer)\n        if (!foundWord) {\n          cloze.removeChild(clozeHidden)\n          cloze.removeChild(clozeReplacer)\n          maybeRevealExtraField()\n          return\n        }\n        clozeReplacer.innerHTML = clozeHider(clozeHidden) + CLOZE_REPLACER_SEP\n        if (clozeReplacer.classList.contains(\"cloze-hint\")) [\n          clozeReplacer.classList.remove(\"cloze-hint\")\n        ]\n        maybeRevealExtraField()\n      }\n\n      const revealNextClozeOf = (type) => {\n        const nextHidden = document.querySelectorAll(\".cloze-hidden\")\n        const nextNextHidden = nextHidden.length > 1 ? true : false\n        if (!nextNextHidden) {\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\";\n        }\n        if (!nextHidden) {\n          return\n        }\n        const cloze = clozeElOfClozeHidden(nextHidden[0]);\n        if (type === \"word\") {\n          revealClozeWord(cloze)\n        } else if (type === \"cloze\") {\n          revealCloze(cloze)\n        } else {\n          console.error(\"Invalid type: \" + type)\n        }\n      }\n\n      const revealClozeClicked = function (ev) {\n        let elem = ev.currentTarget\n        if (!ev.altKey && (revealNextClozeMode !== \"word\")) {\n          revealCloze(elem)\n        } else {\n          revealClozeWord(elem)\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      }\n\n      window.revealNextCloze = function () {\n        revealNextClozeOf(revealNextClozeMode)\n      }\n\n      window.toggleAllCloze = function () {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length > 0) {\n          for (const elem of elems) {\n            const cloze = clozeElOfClozeHidden(elem)\n            revealCloze(cloze)\n          }\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\"\n        } else {\n          hideAllCloze(initial = false)\n        }\n      }\n\n      const clozeElOfClozeHidden = (cloze) => {\n        while (!cloze.classList.contains(\"cloze\")) {\n          cloze = cloze.parentElement;\n        }\n        return cloze;\n      }\n\n      const maybeRevealExtraField = () => {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length == 0) {\n          const extra = document.getElementById(\"extra\")\n          if (extra) {\n            extra.classList.remove(\"hidden\")\n          }\n\n          showExtra();\n          showExtraButtons();\n          document.documentElement.removeAttribute(\"onclick\")\n\n          // Also reveal autoReveal fields\n          for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n            const container = document.querySelector(`[data-name=\"${field}\"]`)\n            if (container) {\n              const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n              if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n                // const link = container.getElementsByTagName(\"a\")[0]\n                const button = container.getElementsByTagName(\"button\")[0]\n                const hint = container.getElementsByTagName(\"div\")[0]\n                button.classList.add(\"expanded-button\")\n                hint.style.display = \"block\"\n                // link.style.display = \"none\"\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * mode: 'beforeFirstSpace' or 'beforeFirstChar'\n       * Return `true` if it exists and setEnd() was called, otherwise `false`\n       */\n      const setRangeEnd = function (range, node, mode) {\n        if (node.nodeType === Node.TEXT_NODE) {\n          const regex = mode === 'beforeFirstSpace' ? /\\s/ : /\\S/\n          const match = node.textContent.match(regex)\n          if (match) {\n            if (match.index === 0) {\n              while (node.previousSibling === null) {\n                node = node.parentElement\n              }\n              range.setEndBefore(node)\n            } else {\n              range.setEnd(node, match.index);\n            }\n            return true;\n          } else {\n            return false;\n          }\n        } else if (mode === 'beforeFirstChar' && isCharNode(node)) {\n          range.setEndBefore(node)\n          return true\n        } else if (!ignoreSpaceInNode(node)) {\n          for (const child of node.childNodes) {\n            if (setRangeEnd(range, child, mode)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }\n\n      const ignoreSpaceInNode = function (node) {\n        return node.tagName === \"MJX-ASSISTIVE-MML\"\n      }\n\n      const isCharNode = function (node) {\n        return [\"IMG\", \"MJX-CONTAINER\"].includes(node.tagName)\n      }\n\n      hideAllCloze(initial = true)\n\n      let isShowNextShortcut = shortcutMatcher(window.revealNextShortcut)\n      let isShowWordShortcut = shortcutMatcher(window.revealNextWordShortcut)\n      let isToggleAllShortcut = shortcutMatcher(window.toggleAllShortcut)\n      ankingAddEventListener(\"keydown\", (ev) => {\n        let next = isShowNextShortcut(ev)\n        let word = isShowWordShortcut(ev)\n        let all = isToggleAllShortcut(ev)\n        if (next) {\n          revealNextClozeOf(\"cloze\")\n        } else if (word) {\n          revealNextClozeOf(\"word\")\n        } else if (all) {\n          toggleAllCloze()\n        } else {\n          return;\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      });\n    })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- MEDITRICKS SNIPPETS DATA -->\n<div id=\"meditricks-mtsp-values\" style=\"display:none;\">\n  <div id=\"meditricks-mtsp-nfname\">_meditricks_nf_v1000_ankizin</div>\n  <div id=\"meditricks-mtsp-nid\">{{Note ID}}</div>\n</div>\n<script src=\"_meditricks_mtsp_scripts_v1000_ankizin.js\"></script>\n<link href=\"_meditricks_mtsp_styles_v1000_ankizin.css\" rel=\"stylesheet\" />\n\n<!-- include \"_meditricks_mtsp_nf_v1000_ankizin.js\" -->\n<!-- include \"_meditricks_mtsp_scripts_v1000_iframe.map\" -->\n<!-- include \"_meditricks_mtsp_mtlogo.webp\" -->\n<!-- include \"_meditricks_mtsp_mt-loading.png\" -->\n<!-- include \"_meditricks_mtsp_mt-loading_night.png\" -->\n\n<!-- //MEDITRICKS SNIPPETS DATA -->\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>",
      "bqfmt": "{{Muskel / Leitungsbahn}}",
      "bafmt": "{{Innervation}}",
      "bfont": "Helvetica",
      "bsize": 12
    },
    {
      "name": "InnervationCloze3",
      "ord": 20,
      "qfmt": "<!-- version f0935e4 -->\n{{#Innervation}}\n{{#InnervationCloze3}}\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TIMER CONFIG  ##############\n  // Timer config (timer length, timer finished message)\n  var minutes = 0\n  var seconds = 15\n  var timeOverMsg = \"<span style='color:#CC5B5B'>!!!</span>\"\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  // Auto flip to back when One by one mode.\n  var autoflip = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Was ist die <i>Innervation</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" data-card=\"{{Card}}\"><br>{{Innervation}}</div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\"></div>\n\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<script>\n  //DONT FADE BETWEEN CARDS\n  qFade = 0;\n  if (typeof anki !== 'undefined') anki.qFade = qFade;\n</script>\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    if (!indentation) { return; }\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- CLOZE ONE BY ONE FRONT -->\n<div id=\"one-by-one\" style=\"display: none;\"></div>\n\n<script>\n  /**\n   * Based on the AnKing Notetype, but expanded and modified by phyn.\n   * Credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  Persistence.clear();\n\n  // check if OneByOne is generally enabled for this card\n  var oneByOneFieldEmpty = selectiveOneByOne ? \"{{One by one}}\" === \"\" : true;\n  var clozeOneByOneEnabled = alwaysOneByOne ? true : !oneByOneFieldEmpty;\n\n  // avoid flickering. Must unset this in the back.\n  document.getElementById(\"qa\").style.display = \"none\";\n  var clozeHints = [];\n\n  if (clozeOneByOneEnabled) {\n    // collect hints from front side (independent of whether or not OneByOne is enabled)\n    document.getElementById(\"qa\").classList.add('one-by-one');\n    // Save cloze hints to display in the back\n    var clozes = document.getElementsByClassName(\"cloze\")\n    for (var i = 0; i < clozes.length; i++) {\n      clozes[i].classList.add(\"one-by-one\");\n      if (clozes[i].innerHTML === \"[...]\") {\n        clozeHints.push(\"\")\n      } else {\n        clozeHints.push(clozes[i].innerHTML)\n      }\n    }\n\n    // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n    /**\n     * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n     */\n    const getCardNumber = function () {\n      clz = document.body.className;\n      const regex = /card(\\d+)/gm;\n\n      let clz2;\n      try {\n        clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n      } catch (e) {\n        clz2 = \"\";\n      }\n      const regex2 = /.*?Cloze(\\d+)/gm;\n\n      let m;\n\n      if ((m = regex2.exec(clz2)) !== null) {\n        return m[1];\n      } else if ((m = regex.exec(clz)) !== null) {\n        return m[1];\n      } else {\n        // Should only fire if card is not cloze\n        console.error(\"Cannot find cardN class of body element!\");\n        return \"0\";\n      }\n    }\n\n    var alreadyRendered = false;\n\n    function processSelective1b1() {\n      if (alreadyRendered) return;\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (autoflip && clozeOneByOneEnabled) {\n        if (window.pycmd || window.showAnswer) {\n          // avoid flickering. Must unset this in the back.\n          document.getElementById(\"qa\").style.display = \"none\";\n        }\n        if (window.pycmd) {\n          pycmd(\"ans\")\n        } else if (window.showAnswer) {\n          showAnswer()\n        }\n      } else {\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n      }\n      // AnkiMobile JS API doesn't have one for show answer.\n      // Best alternative is to use Taps/Swipes to show answer.\n\n      alreadyRendered = true;\n    }\n\n    function delayedProcessSelective1b1() {\n      if (window.requestAnimationFrame) window.requestAnimationFrame(processSelective1b1); // less flickering\n      else window.setTimeout(processSelective1b1, 0);\n    };\n\n    window.onload = delayedProcessSelective1b1;\n    if (document.readyState === \"complete\") {\n      delayedProcessSelective1b1();\n    }\n    else {\n      document.addEventListener(\"DOMContentLoaded\", delayedProcessSelective1b1);\n    }\n\n    // Observe document.body class changes to trigger re-rendering.\n    // This is useful, because Anki doesn’t always start with an up-to-date class list:\n    // https://forums.ankiweb.net/t/card-card-classes-only-injected-separately-now/27387.\n    const observer = new MutationObserver(function (mutationsList, observer) {\n      for (let mutation of mutationsList) {\n        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {\n          delayedProcessSelective1b1();\n        }\n      }\n    });\n    observer.observe(document.body, { attributes: true });\n  }\n  Persistence.setItem(\"clozeHints\", clozeHints);\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>\n\n\n{{/InnervationCloze3}}\n{{/Innervation}}",
      "afmt": "<!-- version f0935e4 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n<div id=\"back\"></div>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Eigene Notizen & Bilder\": \"Alt + 1\",\n    \"Eigene Prüfungsfragen\": \"Alt + 2\",\n    \"Definitionen\": \"Alt + 3\",\n    \"Merksprüche\": \"Alt + 4\",\n    \"Klinik\": \"Alt + 5\",\n    \"Präparat\": \"Alt + 6\",\n    \"Memes\": \"Alt + 7\",\n    \"linkContainer\": \"Alt + L\",\n    \"Meditricks\": \"Alt + M\",\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Eigene Notizen & Bilder\": false,\n    \"Eigene Prüfungsfragen\": false,\n    \"Definitionen\": false,\n    \"Merksprüche\": false,\n    \"Klinik\": false,\n    \"Präparat\": false,\n    \"Memes\": false,\n    \"linkContainer\": true,\n    \"Meditricks\": false,\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  var revealNextShortcut = \"N\"\n  var revealNextWordShortcut = \"Shift + N\"\n  var toggleAllShortcut = \",\"\n\n  // Enables revealing of next Cloze by simply clicking / tapping anywhere on the card (except the buttons)\n  var revealAnywhere = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // Changes how \"Reveal Next\" and clicking behaves. Either \"cloze\" or \"word\".\n  // \"word\" reveals word by word. \n  var revealNextClozeMode = \"cloze\"\n\n  // Changes how fields with additional information are displayed.\n  // true displays fields with additional information only if all clozes are revealed.\n  var hideAdditional = true;\n  var hideAdditionalButtons = true;\n\n  // What cloze is hidden with\n  var clozeHider = (elem) => \"[&nbsp;_&nbsp;]\"\n  /*\n  You can replace the above line with below examples. '█' or '_' works well for hiding clozes.\n  \n  // Fixed length:\n  var clozeHider = (elem) => \"███\"\n  // Replace each character with \"█\":\n  var clozeHider = (elem) => \"█\".repeat(elem.textContent.length)\n  // Show whitespaces:\n  var clozeHider = (elem) => \"[\" + elem.textContent.split(\" \").map((t) => \"█\".repeat(t.length)).join(\" \") + \"]\"\n  // Color-filled box (doesn't hide images):\n  var clozeHider = (elem) => `<span style=\"background-color: red; color: transparent;\">${elem.innerHTML}</span>`\n  */\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Was ist die <i>Innervation</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" class=\"clozefield\" data-card=\"{{Card}}\"><br>{{Innervation}}</div>\n\n    <!-- ClOZE ONE BY ONE BUTTONS -->\n    <div id=\"onebyone-buttons\" class=\"onebyone\">\n      <br>\n      <button id=\"button-reveal-next\" class=\"button-general button-one-by-one\"\n        onclick=\"revealNextCloze(); event.stopPropagation()\">Reveal Next</button>\n      <button id=\"button-toggle-all\" class=\"button-general button-one-by-one\"\n        onclick=\"toggleAllCloze(); event.stopPropagation()\">Toggle All</button>\n    </div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- BUTTON FIELDS -->\n    {{#Eigene Notizen & Bilder}}\n    <span id=\"hint-zusatz\" class=\"hintBtn\" data-name=\"Eigene Notizen & Bilder\" style=\"display: none;\">\n      <button id=\"button-zusatz\" class=\"button-general\" onclick=\"toggleHintBtn('hint-zusatz'); event.stopPropagation()\">\n        <img src=\"__zusatz.svg\" style=\"height: 10px;\"> Eigene Notizen & Bilder\n      </button>\n      <div dir=\"auto\" id=\"zusatz\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Notizen & Bilder}}</div>\n    </span>\n    {{/Eigene Notizen & Bilder}}\n\n    {{#Eigene Prüfungsfragen}}\n    <span id=\"hint-hammer\" class=\"hintBtn\" data-name=\"Eigene Prüfungsfragen\" style=\"display: none;\">\n      <button id=\"button-hammer\" class=\"button-general\" onclick=\"toggleHintBtn('hint-hammer'); event.stopPropagation()\">\n        <img src=\"__hammer.svg\" style=\"height: 10px;\"> Eigene Prüfungsfragen\n      </button>\n      <div dir=\"auto\" id=\"hammer\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Prüfungsfragen}}</div>\n    </span>\n    {{/Eigene Prüfungsfragen}}\n\n    {{#Definitionen}}\n    <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Definitionen\" style=\"display: none;\">\n      <button id=\"button-definition\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Definitionen\n      </button>\n      <div dir=\"auto\" id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Definitionen}}</div>\n    </span>\n    {{/Definitionen}}\n\n    {{#Merksprüche}}\n    <span id=\"hint-merksprueche\" class=\"hintBtn\" data-name=\"Merksprüche\" style=\"display: none;\">\n      <button id=\"button-merksprueche\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-merksprueche'); event.stopPropagation()\">\n        <img src=\"__merkhilfe.svg\" style=\"height: 10px;\"> Merksprüche\n      </button>\n      <div dir=\"auto\" id=\"merksprueche\" class=\"hints\" style=\"display: none;\">{{edit:Merksprüche}}</div>\n    </span>\n    {{/Merksprüche}}\n\n    {{#Klinik}}\n    <span id=\"hint-klinik\" class=\"hintBtn\" data-name=\"Klinik\" style=\"display: none;\">\n      <button id=\"button-klinik\" class=\"button-general\" onclick=\"toggleHintBtn('hint-klinik'); event.stopPropagation()\">\n        <img src=\"__stethoscope.svg\" style=\"height: 10px;\"> Klinik\n      </button>\n      <div dir=\"auto\" id=\"klinik\" class=\"hints\" style=\"display: none;\">{{edit:Klinik}}</div>\n    </span>\n    {{/Klinik}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-praeparat\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n        </button>\n      </a>\n    </span>\n    {{/Präparat}}\n\n    {{#Virtuelle Mikroskopie}}\n    <span id=\"hint-microscope-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Virtuelle Mikroskopie}}\">\n        <button id=\"button-microscope\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Virtuelle Mikroskopie\n        </button>\n      </a>\n    </span>\n    {{/Virtuelle Mikroskopie}}\n\n    {{#Smart Zoom}}\n    <span id=\"hint-smartzoom-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-smartzoom\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Smart Zoom\n        </button>\n      </a>\n    </span>\n    {{/Smart Zoom}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat\" class=\"hintBtn\" data-name=\"Präparat\" style=\"display: none;\">\n      <button id=\"button-praeparat\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-praeparat'); event.stopPropagation()\">\n        <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n      </button>\n      <div dir=\"auto\" id=\"praeparat\" class=\"hints\" style=\"display: none;\">{{edit:Präparat}}</div>\n    </span>\n    {{/Präparat}}\n\n    {{#Memes}}\n    <span id=\"hint-memes\" class=\"hintBtn\" data-name=\"Memes\" style=\"display: none;\">\n      <button id=\"button-memes\" class=\"button-general\" onclick=\"toggleHintBtn('hint-memes'); event.stopPropagation()\">\n        <img src=\"__sonstiges.svg\" style=\"height: 10px;\"> Memes\n      </button>\n      <div dir=\"auto\" id=\"memes\" class=\"hints\" style=\"display: none;\">{{edit:Memes}}</div>\n    </span>\n    {{/Memes}}\n\n    <!-- LINEBREAKS IF BUTTONS EXIST -->\n    <script>\n      var array = [`{{Eigene Notizen & Bilder}}`, `{{Eigene Prüfungsfragen}}`, `{{Definitionen}}`, `{{Merksprüche}}`, `{{Klinik}}`, `{{Präparat}}`, `{{Memes}}`];\n      var anyistrue = (element) => element;\n      if (array.some(anyistrue)) {\n        document.getElementById(\"linebreaksIfButtons\").innerHTML = \"<br>\";\n      }\n    </script>\n    <div id=\"linebreaksIfButtons\"></div>\n\n    <!-- Extra field -->\n    {{#Extra}}\n    <div id=\"extra\" style=\"display: none;\">\n      <br>{{edit:Extra}}<br><br>\n    </div>\n    {{/Extra}}\n\n    <!-- Image field -->\n    {{#Bild}}\n    <div id=\"image\" style=\"display: none;\">\n      {{edit:Bild}}<br><br></div>\n    {{/Bild}}\n    {{^Bild}}\n    <span id=\"image\" style=\"display: none;\"></span>\n    {{/Bild}}\n    {{#Bild}}\n    <span id=\"hint-image\" style=\"display: none;\">\n      <button id=\"button-image\" class=\"button-general\"\n        onclick=\"var image = document.getElementById('image'); if (image.style.display == 'none') { image.style.display = 'block' } else { image.style.display = 'none' }; event.stopPropagation()\">\n        <img src=\"__image.svg\" style=\"height: 10px;\"> Abbildung\n      </button>\n    </span>\n    {{/Bild}}\n\n    <span id=\"hint-uafi\" class=\"hintBtn\" data-name=\"Ursprung, Ansatz, Verlauf, Funktion, Innervation, Äste\"\n      style=\"display: none;\">\n      <button id=\"button-uafi\" class=\"button-general expanded-button\"\n        onclick=\"toggleHintBtn('hint-uafi'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Weitere Informationen\n      </button>\n      <div id=\"uafi\" class=\"hints\" style=\"display: block;\">\n        <table class=\"uncloze\">\n          {{#Ursprung}}\n          <tr class=\"uafi-element\" id=\"Ursprung\">\n            <td><i>Ursprung</i></td>\n            <td>{{Ursprung}}</td>\n          </tr>\n          {{/Ursprung}}\n          {{#Ansatz}}\n          <tr class=\"uafi-element\" id=\"Ansatz\">\n            <td><i>Ansatz</i></td>\n            <td>{{Ansatz}}</td>\n          </tr>\n          {{/Ansatz}}\n          {{#Verlauf}}\n          <tr class=\"uafi-element\" id=\"Verlauf\">\n            <td><i>Verlauf</i></td>\n            <td>{{Verlauf}}</td>\n          </tr>\n          {{/Verlauf}}\n          {{#Funktion}}\n          <tr class=\"uafi-element\" id=\"Funktion\">\n            <td><i>Funktion</i></td>\n            <td>{{Funktion}}</td>\n          </tr>\n          {{/Funktion}}\n          {{#Innervation}}\n          <tr class=\"uafi-element\" id=\"Innervation\">\n            <td><i>Innervation</i></td>\n            <td>{{Innervation}}</td>\n          </tr>\n          {{/Innervation}}\n          {{#Äste}}\n          <tr class=\"uafi-element\" id=\"Äste\">\n            <td><i>Äste</i></td>\n            <td>{{Äste}}</td>\n          </tr>\n          {{/Äste}}\n        </table>\n      </div>\n\n      <script>\n        // iterate over all uafi-elements and hide only the one\n        // that is equal to the card's answer (i.e., value of {{Card}})\n        var uafiElements = document.getElementsByClassName(\"uafi-element\");\n        for (var i = 0; i < uafiElements.length; i++) {\n          if (((\"{{Card}}\").startsWith(uafiElements[i].id))) {\n            uafiElements[i].remove()\n          }\n        }\n      </script>\n    </span>\n\n    {{#AMBOSS-Link}}\n    <span id=\"hint-amboss\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:AMBOSS-Link}}\">\n        <button id=\"button-amboss\" class=\"button-general\">\n          <img src=\"__amboss.svg\" style=\"height: 10px;\"> AMBOSS&#8203;\n        </button>\n      </a>\n    </span>\n    {{/AMBOSS-Link}}\n\n    {{#Thieme via medici-Link}}\n    <span id=\"hint-thieme\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Thieme via medici-Link}}\">\n        <button id=\"button-thieme\" class=\"button-general\">\n          <img id=\"button-thieme-img\" src=\"__thieme-heart.svg\" style=\"height: 10px;\"> Thieme via medici\n        </button>\n      </a>\n    </span>\n    {{/Thieme via medici-Link}}\n\n    {{#Meditricks}}\n    <span id=\"hint-meditricks\" class=\"hintBtn\" data-name=\"Meditricks\" style=\"display: none;\">\n      <button id=\"button-meditricks\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-meditricks'); event.stopPropagation()\">\n        <img src=\"__meditricks.svg\" style=\"height: 10px;\"> Meditricks\n      </button>\n      <div dir=\"auto\" id=\"meditricks\" class=\"hints\" style=\"display: none;\">{{edit:Meditricks}}</div>\n    </span>\n    {{/Meditricks}}\n\n    {{#weitere Links}}\n    <span id=\"hint-linkcontainer\" class=\"hintBtn\" data-name=\"linkContainer\" style=\"display: none;\">\n      <button id=\"button-linkcontainer\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-linkcontainer'); event.stopPropagation()\">\n        <img src=\"__internet.svg\" style=\"height: 10px;\"> weitere Links\n      </button>\n      <div id=\"linkcontainer\" class=\"hints\" style=\"display: none;\"></div>\n      <span id=\"linkContainerLinks\" style=\"display: none;\">{{edit:weitere Links}}</span>\n    </span>\n    {{/weitere Links}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n  try {\n    for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n      href = link.href\n      text = link.innerText\n\n      const el = document.createElement('a');\n      el.setAttribute('href', link.href);\n\n      const btn = document.createElement('button');\n      btn.classList.add('button-general');\n      btn.classList.add('expanded-button');\n\n      domain = href.replace(/.+\\/\\/|(www|flexikon|register|de|next|com).|\\..+/g, '');\n      domainDict = {\n        \"amboss\": \"__amboss.svg\",\n        \"wikipedia\": \"__wikipedia.svg\",\n        \"doccheck\": \"__doccheck.png\",\n        \"notfallguru\": \"__notfallguru.svg\",\n        \"awmf\": \"__awmf.svg\",\n        \"gelbe-liste\": \"__gelbe-liste.png\",\n        \"embryotox\": \"__embryotox.svg\",\n        \"radiopaedia\": \"__radiopaedia.png\",\n        \"orphanet\": \"__orphanet.png\",\n      }\n      if (domain in domainDict) {\n        icon = domainDict[domain]\n      } else {\n        icon = \"__internet.svg\"\n      }\n\n      const img = document.createElement('img');\n      img.setAttribute('src', icon);\n      img.setAttribute('style', 'height: 10px;');\n\n      btn.appendChild(img);\n      btn.innerHTML = btn.innerHTML + \" \" + text;\n\n      el.appendChild(btn);\n\n      document.getElementById(\"linkcontainer\").appendChild(el)\n    }\n  }\n  catch (err) {\n    console.log(err)\n  }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-uafi\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- AUTOFLIP BACK SCRIPT -->\n<script>\n  // autoflip hides card in front template\n  document.getElementById(\"qa\").style.removeProperty(\"display\")\n</script>\n\n<!-- CLOZE ONE BY ONE SCRIPT -->\n<style>\n  .cloze-replacer:hover {\n    cursor: pointer;\n  }\n\n  .cloze-hidden {\n    display: none;\n  }\n\n  .cloze-replacer .hidden {\n    display: none;\n  }\n\n  #extra.hidden {\n    display: none;\n  }\n</style>\n\n<!--\n Based on the AnKing Notetype, but expanded and modified by phyn.\n Credit to the original authors, except where modified or otherwise indicated.\n-->\n\n<script>\n    (function () {\n      // enables cloze one-by-one even when one-by-one field is empty\n      // minNumberOfClozes is still considered in this case\n      // overridden in importance by selectiveOneByOne\n      var clozeOneByOneEnabled = true;\n\n      // remove the clickAnywhere function from global scope\n      document.documentElement.removeAttribute(\"onclick\")\n\n      // --- CHECK IF ONE BY ONE IS GENERALLY ENABLED FOR THIS NOTE ---\n      var oneByOneFieldNotEmpty = \"{{One by one}}\" !== \"\";\n      try {\n        clozeOneByOneEnabled = alwaysOneByOne || oneByOneFieldNotEmpty;\n      } catch (exception) {\n        console.log(exception)\n      }\n\n      /**\n   * helper functions to show / hide fields containing additional information\n   */\n      const showExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const hideExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const buttonIds = [\n        \"hint-zusatz\",\n        \"hint-definition\",\n        \"hint-hammer\",\n        \"hint-klinik\",\n        \"hint-praeparat\",\n        \"hint-microscope\",\n        \"hint-smartzoom\",\n        \"hint-histotrainer\",\n        \"hint-uafi\",\n        \"hint-merksprueche\",\n        \"hint-memes\",\n        \"hint-image\",\n        \"hint-amboss\",\n        \"hint-thieme\",\n        \"hint-meditricks\",\n        \"hint-linkcontainer\",\n      ];\n\n      const showExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document\n              .getElementById(buttonIds[button])\n              .style.removeProperty(\"display\");\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n      const hideExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document.getElementById(buttonIds[button]).style.display = \"none\";\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n\n      // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n      /**\n       * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n       */\n      const getCardNumber = function () {\n        clz = document.body.className;\n        const regex = /card(\\d+)/gm;\n\n        let clz2;\n        try {\n          clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n        } catch (e) {\n          clz2 = \"\";\n        }\n        const regex2 = /.*?Cloze(\\d+)/gm;\n\n        let m;\n\n        if ((m = regex2.exec(clz2)) !== null) {\n          return m[1];\n        } else if ((m = regex.exec(clz)) !== null) {\n          return m[1];\n        } else {\n          // Should only fire if card is not cloze\n          console.error(\"Cannot find cardN class of body element!\");\n          return \"0\";\n        }\n      }\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (!clozeOneByOneEnabled) {\n        showExtra()\n        showExtraButtons()\n        document.getElementById(\"onebyone-buttons\").style.display = \"none\"\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n        return\n      }\n\n      // Needed for amboss to recognize first word in .cloze-hidden\n      const CLOZE_REPLACER_SEP = \"<span class='hidden'> </span>\"\n\n      const hideAllCloze = function (initial) {\n        let clozes = document.getElementsByClassName(\"cloze\")\n        let count = 0 // hidden cloze count\n        for (const cloze of clozes) {\n          const existingHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n          if (existingHidden) {\n            revealCloze(cloze);\n          }\n          if (cloze.offsetWidth === 0) {\n            continue\n          }\n          const clozeReplacer = document.createElement(\"span\")\n          const clozeHidden = document.createElement(\"span\")\n          clozeReplacer.classList.add(\"cloze-replacer\")\n          clozeHidden.classList.add(\"cloze-hidden\")\n          while (cloze.childNodes.length > 0) {\n            clozeHidden.appendChild(cloze.childNodes[0])\n          }\n          cloze.appendChild(clozeReplacer)\n          cloze.appendChild(clozeHidden)\n\n          var clozeHints = Persistence.getItem(\"clozeHints\");\n          if (clozeHints && clozeHints[count]) {\n            clozeReplacer.classList.add(\"cloze-hint\")\n            clozeReplacer.innerHTML = clozeHints[count] + CLOZE_REPLACER_SEP\n          } else {\n            clozeReplacer.innerHTML = clozeHider(cloze) + CLOZE_REPLACER_SEP\n          }\n          count += 1\n          document.getElementById(\"button-reveal-next\").style.display = \"inline-block\";\n          if (initial) {\n            cloze.addEventListener(\"touchend\", revealClozeClicked)\n            cloze.addEventListener(\"click\", revealClozeClicked)\n            cloze.classList.add(\"one-by-one\");\n          }\n        }\n\n        // Hide #extra until all clozes are shown\n        const extra = document.getElementById(\"extra\");\n        if (extra) {\n          extra.classList.add(\"hidden\");\n        }\n\n        hideExtra();\n        hideExtraButtons();\n        if (revealAnywhere) {\n          document.documentElement.setAttribute(\"onclick\", \"revealNextCloze(); event.stopPropagation()\")\n        }\n\n\n        // Also hide autoReveal fields\n        for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n          const container = document.querySelector(`[data-name=\"${field}\"]`)\n          if (container) {\n            const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n            if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n              // const link = container.getElementsByTagName(\"a\")[0]\n              const button = container.getElementsByTagName(\"button\")[0]\n              const hint = container.getElementsByTagName(\"div\")[0]\n              button.classList.remove(\"expanded-button\")\n              hint.style.display = \"none\"\n              // link.style.display = \"\"\n            }\n          }\n        }\n      }\n\n      const revealCloze = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        cloze.removeChild(clozeReplacer)\n        cloze.removeChild(clozeHidden)\n        while (clozeHidden.childNodes.length > 0) {\n          cloze.appendChild(clozeHidden.childNodes[0])\n        }\n        maybeRevealExtraField()\n      }\n\n      const revealClozeWord = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        let range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundSpace = setRangeEnd(range, clozeHidden, \"beforeFirstSpace\")\n        if (!foundSpace) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        let fragment = range.extractContents()\n        cloze.insertBefore(fragment, clozeReplacer)\n        // Extract whitespaces after word\n        range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundWord = setRangeEnd(range, clozeHidden, \"beforeFirstChar\")\n        if (!foundWord) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        fragment = range.extractContents();\n        cloze.insertBefore(fragment, clozeReplacer)\n        if (!foundWord) {\n          cloze.removeChild(clozeHidden)\n          cloze.removeChild(clozeReplacer)\n          maybeRevealExtraField()\n          return\n        }\n        clozeReplacer.innerHTML = clozeHider(clozeHidden) + CLOZE_REPLACER_SEP\n        if (clozeReplacer.classList.contains(\"cloze-hint\")) [\n          clozeReplacer.classList.remove(\"cloze-hint\")\n        ]\n        maybeRevealExtraField()\n      }\n\n      const revealNextClozeOf = (type) => {\n        const nextHidden = document.querySelectorAll(\".cloze-hidden\")\n        const nextNextHidden = nextHidden.length > 1 ? true : false\n        if (!nextNextHidden) {\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\";\n        }\n        if (!nextHidden) {\n          return\n        }\n        const cloze = clozeElOfClozeHidden(nextHidden[0]);\n        if (type === \"word\") {\n          revealClozeWord(cloze)\n        } else if (type === \"cloze\") {\n          revealCloze(cloze)\n        } else {\n          console.error(\"Invalid type: \" + type)\n        }\n      }\n\n      const revealClozeClicked = function (ev) {\n        let elem = ev.currentTarget\n        if (!ev.altKey && (revealNextClozeMode !== \"word\")) {\n          revealCloze(elem)\n        } else {\n          revealClozeWord(elem)\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      }\n\n      window.revealNextCloze = function () {\n        revealNextClozeOf(revealNextClozeMode)\n      }\n\n      window.toggleAllCloze = function () {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length > 0) {\n          for (const elem of elems) {\n            const cloze = clozeElOfClozeHidden(elem)\n            revealCloze(cloze)\n          }\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\"\n        } else {\n          hideAllCloze(initial = false)\n        }\n      }\n\n      const clozeElOfClozeHidden = (cloze) => {\n        while (!cloze.classList.contains(\"cloze\")) {\n          cloze = cloze.parentElement;\n        }\n        return cloze;\n      }\n\n      const maybeRevealExtraField = () => {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length == 0) {\n          const extra = document.getElementById(\"extra\")\n          if (extra) {\n            extra.classList.remove(\"hidden\")\n          }\n\n          showExtra();\n          showExtraButtons();\n          document.documentElement.removeAttribute(\"onclick\")\n\n          // Also reveal autoReveal fields\n          for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n            const container = document.querySelector(`[data-name=\"${field}\"]`)\n            if (container) {\n              const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n              if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n                // const link = container.getElementsByTagName(\"a\")[0]\n                const button = container.getElementsByTagName(\"button\")[0]\n                const hint = container.getElementsByTagName(\"div\")[0]\n                button.classList.add(\"expanded-button\")\n                hint.style.display = \"block\"\n                // link.style.display = \"none\"\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * mode: 'beforeFirstSpace' or 'beforeFirstChar'\n       * Return `true` if it exists and setEnd() was called, otherwise `false`\n       */\n      const setRangeEnd = function (range, node, mode) {\n        if (node.nodeType === Node.TEXT_NODE) {\n          const regex = mode === 'beforeFirstSpace' ? /\\s/ : /\\S/\n          const match = node.textContent.match(regex)\n          if (match) {\n            if (match.index === 0) {\n              while (node.previousSibling === null) {\n                node = node.parentElement\n              }\n              range.setEndBefore(node)\n            } else {\n              range.setEnd(node, match.index);\n            }\n            return true;\n          } else {\n            return false;\n          }\n        } else if (mode === 'beforeFirstChar' && isCharNode(node)) {\n          range.setEndBefore(node)\n          return true\n        } else if (!ignoreSpaceInNode(node)) {\n          for (const child of node.childNodes) {\n            if (setRangeEnd(range, child, mode)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }\n\n      const ignoreSpaceInNode = function (node) {\n        return node.tagName === \"MJX-ASSISTIVE-MML\"\n      }\n\n      const isCharNode = function (node) {\n        return [\"IMG\", \"MJX-CONTAINER\"].includes(node.tagName)\n      }\n\n      hideAllCloze(initial = true)\n\n      let isShowNextShortcut = shortcutMatcher(window.revealNextShortcut)\n      let isShowWordShortcut = shortcutMatcher(window.revealNextWordShortcut)\n      let isToggleAllShortcut = shortcutMatcher(window.toggleAllShortcut)\n      ankingAddEventListener(\"keydown\", (ev) => {\n        let next = isShowNextShortcut(ev)\n        let word = isShowWordShortcut(ev)\n        let all = isToggleAllShortcut(ev)\n        if (next) {\n          revealNextClozeOf(\"cloze\")\n        } else if (word) {\n          revealNextClozeOf(\"word\")\n        } else if (all) {\n          toggleAllCloze()\n        } else {\n          return;\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      });\n    })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- MEDITRICKS SNIPPETS DATA -->\n<div id=\"meditricks-mtsp-values\" style=\"display:none;\">\n  <div id=\"meditricks-mtsp-nfname\">_meditricks_nf_v1000_ankizin</div>\n  <div id=\"meditricks-mtsp-nid\">{{Note ID}}</div>\n</div>\n<script src=\"_meditricks_mtsp_scripts_v1000_ankizin.js\"></script>\n<link href=\"_meditricks_mtsp_styles_v1000_ankizin.css\" rel=\"stylesheet\" />\n\n<!-- include \"_meditricks_mtsp_nf_v1000_ankizin.js\" -->\n<!-- include \"_meditricks_mtsp_scripts_v1000_iframe.map\" -->\n<!-- include \"_meditricks_mtsp_mtlogo.webp\" -->\n<!-- include \"_meditricks_mtsp_mt-loading.png\" -->\n<!-- include \"_meditricks_mtsp_mt-loading_night.png\" -->\n\n<!-- //MEDITRICKS SNIPPETS DATA -->\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>",
      "bqfmt": "{{Muskel / Leitungsbahn}}",
      "bafmt": "{{Innervation}}",
      "bfont": "Helvetica",
      "bsize": 12
    },
    {
      "name": "ÄsteCloze1",
      "ord": 21,
      "qfmt": "<!-- version f0935e4 -->\n{{#Äste}}\n{{#ÄsteCloze1}}\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TIMER CONFIG  ##############\n  // Timer config (timer length, timer finished message)\n  var minutes = 0\n  var seconds = 15\n  var timeOverMsg = \"<span style='color:#CC5B5B'>!!!</span>\"\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  // Auto flip to back when One by one mode.\n  var autoflip = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Was sind die <i>Äste</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" data-card=\"{{Card}}\"><br>{{Äste}}</div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\"></div>\n\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<script>\n  //DONT FADE BETWEEN CARDS\n  qFade = 0;\n  if (typeof anki !== 'undefined') anki.qFade = qFade;\n</script>\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    if (!indentation) { return; }\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- CLOZE ONE BY ONE FRONT -->\n<div id=\"one-by-one\" style=\"display: none;\"></div>\n\n<script>\n  /**\n   * Based on the AnKing Notetype, but expanded and modified by phyn.\n   * Credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  Persistence.clear();\n\n  // check if OneByOne is generally enabled for this card\n  var oneByOneFieldEmpty = selectiveOneByOne ? \"{{One by one}}\" === \"\" : true;\n  var clozeOneByOneEnabled = alwaysOneByOne ? true : !oneByOneFieldEmpty;\n\n  // avoid flickering. Must unset this in the back.\n  document.getElementById(\"qa\").style.display = \"none\";\n  var clozeHints = [];\n\n  if (clozeOneByOneEnabled) {\n    // collect hints from front side (independent of whether or not OneByOne is enabled)\n    document.getElementById(\"qa\").classList.add('one-by-one');\n    // Save cloze hints to display in the back\n    var clozes = document.getElementsByClassName(\"cloze\")\n    for (var i = 0; i < clozes.length; i++) {\n      clozes[i].classList.add(\"one-by-one\");\n      if (clozes[i].innerHTML === \"[...]\") {\n        clozeHints.push(\"\")\n      } else {\n        clozeHints.push(clozes[i].innerHTML)\n      }\n    }\n\n    // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n    /**\n     * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n     */\n    const getCardNumber = function () {\n      clz = document.body.className;\n      const regex = /card(\\d+)/gm;\n\n      let clz2;\n      try {\n        clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n      } catch (e) {\n        clz2 = \"\";\n      }\n      const regex2 = /.*?Cloze(\\d+)/gm;\n\n      let m;\n\n      if ((m = regex2.exec(clz2)) !== null) {\n        return m[1];\n      } else if ((m = regex.exec(clz)) !== null) {\n        return m[1];\n      } else {\n        // Should only fire if card is not cloze\n        console.error(\"Cannot find cardN class of body element!\");\n        return \"0\";\n      }\n    }\n\n    var alreadyRendered = false;\n\n    function processSelective1b1() {\n      if (alreadyRendered) return;\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (autoflip && clozeOneByOneEnabled) {\n        if (window.pycmd || window.showAnswer) {\n          // avoid flickering. Must unset this in the back.\n          document.getElementById(\"qa\").style.display = \"none\";\n        }\n        if (window.pycmd) {\n          pycmd(\"ans\")\n        } else if (window.showAnswer) {\n          showAnswer()\n        }\n      } else {\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n      }\n      // AnkiMobile JS API doesn't have one for show answer.\n      // Best alternative is to use Taps/Swipes to show answer.\n\n      alreadyRendered = true;\n    }\n\n    function delayedProcessSelective1b1() {\n      if (window.requestAnimationFrame) window.requestAnimationFrame(processSelective1b1); // less flickering\n      else window.setTimeout(processSelective1b1, 0);\n    };\n\n    window.onload = delayedProcessSelective1b1;\n    if (document.readyState === \"complete\") {\n      delayedProcessSelective1b1();\n    }\n    else {\n      document.addEventListener(\"DOMContentLoaded\", delayedProcessSelective1b1);\n    }\n\n    // Observe document.body class changes to trigger re-rendering.\n    // This is useful, because Anki doesn’t always start with an up-to-date class list:\n    // https://forums.ankiweb.net/t/card-card-classes-only-injected-separately-now/27387.\n    const observer = new MutationObserver(function (mutationsList, observer) {\n      for (let mutation of mutationsList) {\n        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {\n          delayedProcessSelective1b1();\n        }\n      }\n    });\n    observer.observe(document.body, { attributes: true });\n  }\n  Persistence.setItem(\"clozeHints\", clozeHints);\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>\n\n\n{{/ÄsteCloze1}}\n{{/Äste}}",
      "afmt": "<!-- version f0935e4 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n<div id=\"back\"></div>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Eigene Notizen & Bilder\": \"Alt + 1\",\n    \"Eigene Prüfungsfragen\": \"Alt + 2\",\n    \"Definitionen\": \"Alt + 3\",\n    \"Merksprüche\": \"Alt + 4\",\n    \"Klinik\": \"Alt + 5\",\n    \"Präparat\": \"Alt + 6\",\n    \"Memes\": \"Alt + 7\",\n    \"linkContainer\": \"Alt + L\",\n    \"Meditricks\": \"Alt + M\",\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Eigene Notizen & Bilder\": false,\n    \"Eigene Prüfungsfragen\": false,\n    \"Definitionen\": false,\n    \"Merksprüche\": false,\n    \"Klinik\": false,\n    \"Präparat\": false,\n    \"Memes\": false,\n    \"linkContainer\": true,\n    \"Meditricks\": false,\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  var revealNextShortcut = \"N\"\n  var revealNextWordShortcut = \"Shift + N\"\n  var toggleAllShortcut = \",\"\n\n  // Enables revealing of next Cloze by simply clicking / tapping anywhere on the card (except the buttons)\n  var revealAnywhere = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // Changes how \"Reveal Next\" and clicking behaves. Either \"cloze\" or \"word\".\n  // \"word\" reveals word by word. \n  var revealNextClozeMode = \"cloze\"\n\n  // Changes how fields with additional information are displayed.\n  // true displays fields with additional information only if all clozes are revealed.\n  var hideAdditional = true;\n  var hideAdditionalButtons = true;\n\n  // What cloze is hidden with\n  var clozeHider = (elem) => \"[&nbsp;_&nbsp;]\"\n  /*\n  You can replace the above line with below examples. '█' or '_' works well for hiding clozes.\n  \n  // Fixed length:\n  var clozeHider = (elem) => \"███\"\n  // Replace each character with \"█\":\n  var clozeHider = (elem) => \"█\".repeat(elem.textContent.length)\n  // Show whitespaces:\n  var clozeHider = (elem) => \"[\" + elem.textContent.split(\" \").map((t) => \"█\".repeat(t.length)).join(\" \") + \"]\"\n  // Color-filled box (doesn't hide images):\n  var clozeHider = (elem) => `<span style=\"background-color: red; color: transparent;\">${elem.innerHTML}</span>`\n  */\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Was sind die <i>Äste</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" class=\"clozefield\" data-card=\"{{Card}}\"><br>{{Äste}}</div>\n\n    <!-- ClOZE ONE BY ONE BUTTONS -->\n    <div id=\"onebyone-buttons\" class=\"onebyone\">\n      <br>\n      <button id=\"button-reveal-next\" class=\"button-general button-one-by-one\"\n        onclick=\"revealNextCloze(); event.stopPropagation()\">Reveal Next</button>\n      <button id=\"button-toggle-all\" class=\"button-general button-one-by-one\"\n        onclick=\"toggleAllCloze(); event.stopPropagation()\">Toggle All</button>\n    </div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- BUTTON FIELDS -->\n    {{#Eigene Notizen & Bilder}}\n    <span id=\"hint-zusatz\" class=\"hintBtn\" data-name=\"Eigene Notizen & Bilder\" style=\"display: none;\">\n      <button id=\"button-zusatz\" class=\"button-general\" onclick=\"toggleHintBtn('hint-zusatz'); event.stopPropagation()\">\n        <img src=\"__zusatz.svg\" style=\"height: 10px;\"> Eigene Notizen & Bilder\n      </button>\n      <div dir=\"auto\" id=\"zusatz\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Notizen & Bilder}}</div>\n    </span>\n    {{/Eigene Notizen & Bilder}}\n\n    {{#Eigene Prüfungsfragen}}\n    <span id=\"hint-hammer\" class=\"hintBtn\" data-name=\"Eigene Prüfungsfragen\" style=\"display: none;\">\n      <button id=\"button-hammer\" class=\"button-general\" onclick=\"toggleHintBtn('hint-hammer'); event.stopPropagation()\">\n        <img src=\"__hammer.svg\" style=\"height: 10px;\"> Eigene Prüfungsfragen\n      </button>\n      <div dir=\"auto\" id=\"hammer\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Prüfungsfragen}}</div>\n    </span>\n    {{/Eigene Prüfungsfragen}}\n\n    {{#Definitionen}}\n    <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Definitionen\" style=\"display: none;\">\n      <button id=\"button-definition\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Definitionen\n      </button>\n      <div dir=\"auto\" id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Definitionen}}</div>\n    </span>\n    {{/Definitionen}}\n\n    {{#Merksprüche}}\n    <span id=\"hint-merksprueche\" class=\"hintBtn\" data-name=\"Merksprüche\" style=\"display: none;\">\n      <button id=\"button-merksprueche\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-merksprueche'); event.stopPropagation()\">\n        <img src=\"__merkhilfe.svg\" style=\"height: 10px;\"> Merksprüche\n      </button>\n      <div dir=\"auto\" id=\"merksprueche\" class=\"hints\" style=\"display: none;\">{{edit:Merksprüche}}</div>\n    </span>\n    {{/Merksprüche}}\n\n    {{#Klinik}}\n    <span id=\"hint-klinik\" class=\"hintBtn\" data-name=\"Klinik\" style=\"display: none;\">\n      <button id=\"button-klinik\" class=\"button-general\" onclick=\"toggleHintBtn('hint-klinik'); event.stopPropagation()\">\n        <img src=\"__stethoscope.svg\" style=\"height: 10px;\"> Klinik\n      </button>\n      <div dir=\"auto\" id=\"klinik\" class=\"hints\" style=\"display: none;\">{{edit:Klinik}}</div>\n    </span>\n    {{/Klinik}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-praeparat\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n        </button>\n      </a>\n    </span>\n    {{/Präparat}}\n\n    {{#Virtuelle Mikroskopie}}\n    <span id=\"hint-microscope-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Virtuelle Mikroskopie}}\">\n        <button id=\"button-microscope\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Virtuelle Mikroskopie\n        </button>\n      </a>\n    </span>\n    {{/Virtuelle Mikroskopie}}\n\n    {{#Smart Zoom}}\n    <span id=\"hint-smartzoom-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-smartzoom\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Smart Zoom\n        </button>\n      </a>\n    </span>\n    {{/Smart Zoom}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat\" class=\"hintBtn\" data-name=\"Präparat\" style=\"display: none;\">\n      <button id=\"button-praeparat\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-praeparat'); event.stopPropagation()\">\n        <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n      </button>\n      <div dir=\"auto\" id=\"praeparat\" class=\"hints\" style=\"display: none;\">{{edit:Präparat}}</div>\n    </span>\n    {{/Präparat}}\n\n    {{#Memes}}\n    <span id=\"hint-memes\" class=\"hintBtn\" data-name=\"Memes\" style=\"display: none;\">\n      <button id=\"button-memes\" class=\"button-general\" onclick=\"toggleHintBtn('hint-memes'); event.stopPropagation()\">\n        <img src=\"__sonstiges.svg\" style=\"height: 10px;\"> Memes\n      </button>\n      <div dir=\"auto\" id=\"memes\" class=\"hints\" style=\"display: none;\">{{edit:Memes}}</div>\n    </span>\n    {{/Memes}}\n\n    <!-- LINEBREAKS IF BUTTONS EXIST -->\n    <script>\n      var array = [`{{Eigene Notizen & Bilder}}`, `{{Eigene Prüfungsfragen}}`, `{{Definitionen}}`, `{{Merksprüche}}`, `{{Klinik}}`, `{{Präparat}}`, `{{Memes}}`];\n      var anyistrue = (element) => element;\n      if (array.some(anyistrue)) {\n        document.getElementById(\"linebreaksIfButtons\").innerHTML = \"<br>\";\n      }\n    </script>\n    <div id=\"linebreaksIfButtons\"></div>\n\n    <!-- Extra field -->\n    {{#Extra}}\n    <div id=\"extra\" style=\"display: none;\">\n      <br>{{edit:Extra}}<br><br>\n    </div>\n    {{/Extra}}\n\n    <!-- Image field -->\n    {{#Bild}}\n    <div id=\"image\" style=\"display: none;\">\n      {{edit:Bild}}<br><br></div>\n    {{/Bild}}\n    {{^Bild}}\n    <span id=\"image\" style=\"display: none;\"></span>\n    {{/Bild}}\n    {{#Bild}}\n    <span id=\"hint-image\" style=\"display: none;\">\n      <button id=\"button-image\" class=\"button-general\"\n        onclick=\"var image = document.getElementById('image'); if (image.style.display == 'none') { image.style.display = 'block' } else { image.style.display = 'none' }; event.stopPropagation()\">\n        <img src=\"__image.svg\" style=\"height: 10px;\"> Abbildung\n      </button>\n    </span>\n    {{/Bild}}\n\n    <span id=\"hint-uafi\" class=\"hintBtn\" data-name=\"Ursprung, Ansatz, Verlauf, Funktion, Innervation, Äste\"\n      style=\"display: none;\">\n      <button id=\"button-uafi\" class=\"button-general expanded-button\"\n        onclick=\"toggleHintBtn('hint-uafi'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Weitere Informationen\n      </button>\n      <div id=\"uafi\" class=\"hints\" style=\"display: block;\">\n        <table class=\"uncloze\">\n          {{#Ursprung}}\n          <tr class=\"uafi-element\" id=\"Ursprung\">\n            <td><i>Ursprung</i></td>\n            <td>{{Ursprung}}</td>\n          </tr>\n          {{/Ursprung}}\n          {{#Ansatz}}\n          <tr class=\"uafi-element\" id=\"Ansatz\">\n            <td><i>Ansatz</i></td>\n            <td>{{Ansatz}}</td>\n          </tr>\n          {{/Ansatz}}\n          {{#Verlauf}}\n          <tr class=\"uafi-element\" id=\"Verlauf\">\n            <td><i>Verlauf</i></td>\n            <td>{{Verlauf}}</td>\n          </tr>\n          {{/Verlauf}}\n          {{#Funktion}}\n          <tr class=\"uafi-element\" id=\"Funktion\">\n            <td><i>Funktion</i></td>\n            <td>{{Funktion}}</td>\n          </tr>\n          {{/Funktion}}\n          {{#Innervation}}\n          <tr class=\"uafi-element\" id=\"Innervation\">\n            <td><i>Innervation</i></td>\n            <td>{{Innervation}}</td>\n          </tr>\n          {{/Innervation}}\n          {{#Äste}}\n          <tr class=\"uafi-element\" id=\"Äste\">\n            <td><i>Äste</i></td>\n            <td>{{Äste}}</td>\n          </tr>\n          {{/Äste}}\n        </table>\n      </div>\n\n      <script>\n        // iterate over all uafi-elements and hide only the one\n        // that is equal to the card's answer (i.e., value of {{Card}})\n        var uafiElements = document.getElementsByClassName(\"uafi-element\");\n        for (var i = 0; i < uafiElements.length; i++) {\n          if (((\"{{Card}}\").startsWith(uafiElements[i].id))) {\n            uafiElements[i].remove()\n          }\n        }\n      </script>\n    </span>\n\n    {{#AMBOSS-Link}}\n    <span id=\"hint-amboss\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:AMBOSS-Link}}\">\n        <button id=\"button-amboss\" class=\"button-general\">\n          <img src=\"__amboss.svg\" style=\"height: 10px;\"> AMBOSS&#8203;\n        </button>\n      </a>\n    </span>\n    {{/AMBOSS-Link}}\n\n    {{#Thieme via medici-Link}}\n    <span id=\"hint-thieme\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Thieme via medici-Link}}\">\n        <button id=\"button-thieme\" class=\"button-general\">\n          <img id=\"button-thieme-img\" src=\"__thieme-heart.svg\" style=\"height: 10px;\"> Thieme via medici\n        </button>\n      </a>\n    </span>\n    {{/Thieme via medici-Link}}\n\n    {{#Meditricks}}\n    <span id=\"hint-meditricks\" class=\"hintBtn\" data-name=\"Meditricks\" style=\"display: none;\">\n      <button id=\"button-meditricks\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-meditricks'); event.stopPropagation()\">\n        <img src=\"__meditricks.svg\" style=\"height: 10px;\"> Meditricks\n      </button>\n      <div dir=\"auto\" id=\"meditricks\" class=\"hints\" style=\"display: none;\">{{edit:Meditricks}}</div>\n    </span>\n    {{/Meditricks}}\n\n    {{#weitere Links}}\n    <span id=\"hint-linkcontainer\" class=\"hintBtn\" data-name=\"linkContainer\" style=\"display: none;\">\n      <button id=\"button-linkcontainer\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-linkcontainer'); event.stopPropagation()\">\n        <img src=\"__internet.svg\" style=\"height: 10px;\"> weitere Links\n      </button>\n      <div id=\"linkcontainer\" class=\"hints\" style=\"display: none;\"></div>\n      <span id=\"linkContainerLinks\" style=\"display: none;\">{{edit:weitere Links}}</span>\n    </span>\n    {{/weitere Links}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n  try {\n    for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n      href = link.href\n      text = link.innerText\n\n      const el = document.createElement('a');\n      el.setAttribute('href', link.href);\n\n      const btn = document.createElement('button');\n      btn.classList.add('button-general');\n      btn.classList.add('expanded-button');\n\n      domain = href.replace(/.+\\/\\/|(www|flexikon|register|de|next|com).|\\..+/g, '');\n      domainDict = {\n        \"amboss\": \"__amboss.svg\",\n        \"wikipedia\": \"__wikipedia.svg\",\n        \"doccheck\": \"__doccheck.png\",\n        \"notfallguru\": \"__notfallguru.svg\",\n        \"awmf\": \"__awmf.svg\",\n        \"gelbe-liste\": \"__gelbe-liste.png\",\n        \"embryotox\": \"__embryotox.svg\",\n        \"radiopaedia\": \"__radiopaedia.png\",\n        \"orphanet\": \"__orphanet.png\",\n      }\n      if (domain in domainDict) {\n        icon = domainDict[domain]\n      } else {\n        icon = \"__internet.svg\"\n      }\n\n      const img = document.createElement('img');\n      img.setAttribute('src', icon);\n      img.setAttribute('style', 'height: 10px;');\n\n      btn.appendChild(img);\n      btn.innerHTML = btn.innerHTML + \" \" + text;\n\n      el.appendChild(btn);\n\n      document.getElementById(\"linkcontainer\").appendChild(el)\n    }\n  }\n  catch (err) {\n    console.log(err)\n  }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-uafi\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- AUTOFLIP BACK SCRIPT -->\n<script>\n  // autoflip hides card in front template\n  document.getElementById(\"qa\").style.removeProperty(\"display\")\n</script>\n\n<!-- CLOZE ONE BY ONE SCRIPT -->\n<style>\n  .cloze-replacer:hover {\n    cursor: pointer;\n  }\n\n  .cloze-hidden {\n    display: none;\n  }\n\n  .cloze-replacer .hidden {\n    display: none;\n  }\n\n  #extra.hidden {\n    display: none;\n  }\n</style>\n\n<!--\n Based on the AnKing Notetype, but expanded and modified by phyn.\n Credit to the original authors, except where modified or otherwise indicated.\n-->\n\n<script>\n    (function () {\n      // enables cloze one-by-one even when one-by-one field is empty\n      // minNumberOfClozes is still considered in this case\n      // overridden in importance by selectiveOneByOne\n      var clozeOneByOneEnabled = true;\n\n      // remove the clickAnywhere function from global scope\n      document.documentElement.removeAttribute(\"onclick\")\n\n      // --- CHECK IF ONE BY ONE IS GENERALLY ENABLED FOR THIS NOTE ---\n      var oneByOneFieldNotEmpty = \"{{One by one}}\" !== \"\";\n      try {\n        clozeOneByOneEnabled = alwaysOneByOne || oneByOneFieldNotEmpty;\n      } catch (exception) {\n        console.log(exception)\n      }\n\n      /**\n   * helper functions to show / hide fields containing additional information\n   */\n      const showExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const hideExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const buttonIds = [\n        \"hint-zusatz\",\n        \"hint-definition\",\n        \"hint-hammer\",\n        \"hint-klinik\",\n        \"hint-praeparat\",\n        \"hint-microscope\",\n        \"hint-smartzoom\",\n        \"hint-histotrainer\",\n        \"hint-uafi\",\n        \"hint-merksprueche\",\n        \"hint-memes\",\n        \"hint-image\",\n        \"hint-amboss\",\n        \"hint-thieme\",\n        \"hint-meditricks\",\n        \"hint-linkcontainer\",\n      ];\n\n      const showExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document\n              .getElementById(buttonIds[button])\n              .style.removeProperty(\"display\");\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n      const hideExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document.getElementById(buttonIds[button]).style.display = \"none\";\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n\n      // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n      /**\n       * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n       */\n      const getCardNumber = function () {\n        clz = document.body.className;\n        const regex = /card(\\d+)/gm;\n\n        let clz2;\n        try {\n          clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n        } catch (e) {\n          clz2 = \"\";\n        }\n        const regex2 = /.*?Cloze(\\d+)/gm;\n\n        let m;\n\n        if ((m = regex2.exec(clz2)) !== null) {\n          return m[1];\n        } else if ((m = regex.exec(clz)) !== null) {\n          return m[1];\n        } else {\n          // Should only fire if card is not cloze\n          console.error(\"Cannot find cardN class of body element!\");\n          return \"0\";\n        }\n      }\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (!clozeOneByOneEnabled) {\n        showExtra()\n        showExtraButtons()\n        document.getElementById(\"onebyone-buttons\").style.display = \"none\"\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n        return\n      }\n\n      // Needed for amboss to recognize first word in .cloze-hidden\n      const CLOZE_REPLACER_SEP = \"<span class='hidden'> </span>\"\n\n      const hideAllCloze = function (initial) {\n        let clozes = document.getElementsByClassName(\"cloze\")\n        let count = 0 // hidden cloze count\n        for (const cloze of clozes) {\n          const existingHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n          if (existingHidden) {\n            revealCloze(cloze);\n          }\n          if (cloze.offsetWidth === 0) {\n            continue\n          }\n          const clozeReplacer = document.createElement(\"span\")\n          const clozeHidden = document.createElement(\"span\")\n          clozeReplacer.classList.add(\"cloze-replacer\")\n          clozeHidden.classList.add(\"cloze-hidden\")\n          while (cloze.childNodes.length > 0) {\n            clozeHidden.appendChild(cloze.childNodes[0])\n          }\n          cloze.appendChild(clozeReplacer)\n          cloze.appendChild(clozeHidden)\n\n          var clozeHints = Persistence.getItem(\"clozeHints\");\n          if (clozeHints && clozeHints[count]) {\n            clozeReplacer.classList.add(\"cloze-hint\")\n            clozeReplacer.innerHTML = clozeHints[count] + CLOZE_REPLACER_SEP\n          } else {\n            clozeReplacer.innerHTML = clozeHider(cloze) + CLOZE_REPLACER_SEP\n          }\n          count += 1\n          document.getElementById(\"button-reveal-next\").style.display = \"inline-block\";\n          if (initial) {\n            cloze.addEventListener(\"touchend\", revealClozeClicked)\n            cloze.addEventListener(\"click\", revealClozeClicked)\n            cloze.classList.add(\"one-by-one\");\n          }\n        }\n\n        // Hide #extra until all clozes are shown\n        const extra = document.getElementById(\"extra\");\n        if (extra) {\n          extra.classList.add(\"hidden\");\n        }\n\n        hideExtra();\n        hideExtraButtons();\n        if (revealAnywhere) {\n          document.documentElement.setAttribute(\"onclick\", \"revealNextCloze(); event.stopPropagation()\")\n        }\n\n\n        // Also hide autoReveal fields\n        for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n          const container = document.querySelector(`[data-name=\"${field}\"]`)\n          if (container) {\n            const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n            if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n              // const link = container.getElementsByTagName(\"a\")[0]\n              const button = container.getElementsByTagName(\"button\")[0]\n              const hint = container.getElementsByTagName(\"div\")[0]\n              button.classList.remove(\"expanded-button\")\n              hint.style.display = \"none\"\n              // link.style.display = \"\"\n            }\n          }\n        }\n      }\n\n      const revealCloze = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        cloze.removeChild(clozeReplacer)\n        cloze.removeChild(clozeHidden)\n        while (clozeHidden.childNodes.length > 0) {\n          cloze.appendChild(clozeHidden.childNodes[0])\n        }\n        maybeRevealExtraField()\n      }\n\n      const revealClozeWord = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        let range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundSpace = setRangeEnd(range, clozeHidden, \"beforeFirstSpace\")\n        if (!foundSpace) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        let fragment = range.extractContents()\n        cloze.insertBefore(fragment, clozeReplacer)\n        // Extract whitespaces after word\n        range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundWord = setRangeEnd(range, clozeHidden, \"beforeFirstChar\")\n        if (!foundWord) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        fragment = range.extractContents();\n        cloze.insertBefore(fragment, clozeReplacer)\n        if (!foundWord) {\n          cloze.removeChild(clozeHidden)\n          cloze.removeChild(clozeReplacer)\n          maybeRevealExtraField()\n          return\n        }\n        clozeReplacer.innerHTML = clozeHider(clozeHidden) + CLOZE_REPLACER_SEP\n        if (clozeReplacer.classList.contains(\"cloze-hint\")) [\n          clozeReplacer.classList.remove(\"cloze-hint\")\n        ]\n        maybeRevealExtraField()\n      }\n\n      const revealNextClozeOf = (type) => {\n        const nextHidden = document.querySelectorAll(\".cloze-hidden\")\n        const nextNextHidden = nextHidden.length > 1 ? true : false\n        if (!nextNextHidden) {\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\";\n        }\n        if (!nextHidden) {\n          return\n        }\n        const cloze = clozeElOfClozeHidden(nextHidden[0]);\n        if (type === \"word\") {\n          revealClozeWord(cloze)\n        } else if (type === \"cloze\") {\n          revealCloze(cloze)\n        } else {\n          console.error(\"Invalid type: \" + type)\n        }\n      }\n\n      const revealClozeClicked = function (ev) {\n        let elem = ev.currentTarget\n        if (!ev.altKey && (revealNextClozeMode !== \"word\")) {\n          revealCloze(elem)\n        } else {\n          revealClozeWord(elem)\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      }\n\n      window.revealNextCloze = function () {\n        revealNextClozeOf(revealNextClozeMode)\n      }\n\n      window.toggleAllCloze = function () {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length > 0) {\n          for (const elem of elems) {\n            const cloze = clozeElOfClozeHidden(elem)\n            revealCloze(cloze)\n          }\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\"\n        } else {\n          hideAllCloze(initial = false)\n        }\n      }\n\n      const clozeElOfClozeHidden = (cloze) => {\n        while (!cloze.classList.contains(\"cloze\")) {\n          cloze = cloze.parentElement;\n        }\n        return cloze;\n      }\n\n      const maybeRevealExtraField = () => {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length == 0) {\n          const extra = document.getElementById(\"extra\")\n          if (extra) {\n            extra.classList.remove(\"hidden\")\n          }\n\n          showExtra();\n          showExtraButtons();\n          document.documentElement.removeAttribute(\"onclick\")\n\n          // Also reveal autoReveal fields\n          for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n            const container = document.querySelector(`[data-name=\"${field}\"]`)\n            if (container) {\n              const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n              if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n                // const link = container.getElementsByTagName(\"a\")[0]\n                const button = container.getElementsByTagName(\"button\")[0]\n                const hint = container.getElementsByTagName(\"div\")[0]\n                button.classList.add(\"expanded-button\")\n                hint.style.display = \"block\"\n                // link.style.display = \"none\"\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * mode: 'beforeFirstSpace' or 'beforeFirstChar'\n       * Return `true` if it exists and setEnd() was called, otherwise `false`\n       */\n      const setRangeEnd = function (range, node, mode) {\n        if (node.nodeType === Node.TEXT_NODE) {\n          const regex = mode === 'beforeFirstSpace' ? /\\s/ : /\\S/\n          const match = node.textContent.match(regex)\n          if (match) {\n            if (match.index === 0) {\n              while (node.previousSibling === null) {\n                node = node.parentElement\n              }\n              range.setEndBefore(node)\n            } else {\n              range.setEnd(node, match.index);\n            }\n            return true;\n          } else {\n            return false;\n          }\n        } else if (mode === 'beforeFirstChar' && isCharNode(node)) {\n          range.setEndBefore(node)\n          return true\n        } else if (!ignoreSpaceInNode(node)) {\n          for (const child of node.childNodes) {\n            if (setRangeEnd(range, child, mode)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }\n\n      const ignoreSpaceInNode = function (node) {\n        return node.tagName === \"MJX-ASSISTIVE-MML\"\n      }\n\n      const isCharNode = function (node) {\n        return [\"IMG\", \"MJX-CONTAINER\"].includes(node.tagName)\n      }\n\n      hideAllCloze(initial = true)\n\n      let isShowNextShortcut = shortcutMatcher(window.revealNextShortcut)\n      let isShowWordShortcut = shortcutMatcher(window.revealNextWordShortcut)\n      let isToggleAllShortcut = shortcutMatcher(window.toggleAllShortcut)\n      ankingAddEventListener(\"keydown\", (ev) => {\n        let next = isShowNextShortcut(ev)\n        let word = isShowWordShortcut(ev)\n        let all = isToggleAllShortcut(ev)\n        if (next) {\n          revealNextClozeOf(\"cloze\")\n        } else if (word) {\n          revealNextClozeOf(\"word\")\n        } else if (all) {\n          toggleAllCloze()\n        } else {\n          return;\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      });\n    })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- MEDITRICKS SNIPPETS DATA -->\n<div id=\"meditricks-mtsp-values\" style=\"display:none;\">\n  <div id=\"meditricks-mtsp-nfname\">_meditricks_nf_v1000_ankizin</div>\n  <div id=\"meditricks-mtsp-nid\">{{Note ID}}</div>\n</div>\n<script src=\"_meditricks_mtsp_scripts_v1000_ankizin.js\"></script>\n<link href=\"_meditricks_mtsp_styles_v1000_ankizin.css\" rel=\"stylesheet\" />\n\n<!-- include \"_meditricks_mtsp_nf_v1000_ankizin.js\" -->\n<!-- include \"_meditricks_mtsp_scripts_v1000_iframe.map\" -->\n<!-- include \"_meditricks_mtsp_mtlogo.webp\" -->\n<!-- include \"_meditricks_mtsp_mt-loading.png\" -->\n<!-- include \"_meditricks_mtsp_mt-loading_night.png\" -->\n\n<!-- //MEDITRICKS SNIPPETS DATA -->\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>",
      "bqfmt": "{{Muskel / Leitungsbahn}}",
      "bafmt": "{{Äste}}",
      "bfont": "Helvetica",
      "bsize": 12
    },
    {
      "name": "ÄsteCloze2",
      "ord": 22,
      "qfmt": "<!-- version f0935e4 -->\n{{#Äste}}\n{{#ÄsteCloze2}}\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TIMER CONFIG  ##############\n  // Timer config (timer length, timer finished message)\n  var minutes = 0\n  var seconds = 15\n  var timeOverMsg = \"<span style='color:#CC5B5B'>!!!</span>\"\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  // Auto flip to back when One by one mode.\n  var autoflip = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Was sind die <i>Äste</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" data-card=\"{{Card}}\"><br>{{Äste}}</div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\"></div>\n\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<script>\n  //DONT FADE BETWEEN CARDS\n  qFade = 0;\n  if (typeof anki !== 'undefined') anki.qFade = qFade;\n</script>\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    if (!indentation) { return; }\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- CLOZE ONE BY ONE FRONT -->\n<div id=\"one-by-one\" style=\"display: none;\"></div>\n\n<script>\n  /**\n   * Based on the AnKing Notetype, but expanded and modified by phyn.\n   * Credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  Persistence.clear();\n\n  // check if OneByOne is generally enabled for this card\n  var oneByOneFieldEmpty = selectiveOneByOne ? \"{{One by one}}\" === \"\" : true;\n  var clozeOneByOneEnabled = alwaysOneByOne ? true : !oneByOneFieldEmpty;\n\n  // avoid flickering. Must unset this in the back.\n  document.getElementById(\"qa\").style.display = \"none\";\n  var clozeHints = [];\n\n  if (clozeOneByOneEnabled) {\n    // collect hints from front side (independent of whether or not OneByOne is enabled)\n    document.getElementById(\"qa\").classList.add('one-by-one');\n    // Save cloze hints to display in the back\n    var clozes = document.getElementsByClassName(\"cloze\")\n    for (var i = 0; i < clozes.length; i++) {\n      clozes[i].classList.add(\"one-by-one\");\n      if (clozes[i].innerHTML === \"[...]\") {\n        clozeHints.push(\"\")\n      } else {\n        clozeHints.push(clozes[i].innerHTML)\n      }\n    }\n\n    // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n    /**\n     * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n     */\n    const getCardNumber = function () {\n      clz = document.body.className;\n      const regex = /card(\\d+)/gm;\n\n      let clz2;\n      try {\n        clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n      } catch (e) {\n        clz2 = \"\";\n      }\n      const regex2 = /.*?Cloze(\\d+)/gm;\n\n      let m;\n\n      if ((m = regex2.exec(clz2)) !== null) {\n        return m[1];\n      } else if ((m = regex.exec(clz)) !== null) {\n        return m[1];\n      } else {\n        // Should only fire if card is not cloze\n        console.error(\"Cannot find cardN class of body element!\");\n        return \"0\";\n      }\n    }\n\n    var alreadyRendered = false;\n\n    function processSelective1b1() {\n      if (alreadyRendered) return;\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (autoflip && clozeOneByOneEnabled) {\n        if (window.pycmd || window.showAnswer) {\n          // avoid flickering. Must unset this in the back.\n          document.getElementById(\"qa\").style.display = \"none\";\n        }\n        if (window.pycmd) {\n          pycmd(\"ans\")\n        } else if (window.showAnswer) {\n          showAnswer()\n        }\n      } else {\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n      }\n      // AnkiMobile JS API doesn't have one for show answer.\n      // Best alternative is to use Taps/Swipes to show answer.\n\n      alreadyRendered = true;\n    }\n\n    function delayedProcessSelective1b1() {\n      if (window.requestAnimationFrame) window.requestAnimationFrame(processSelective1b1); // less flickering\n      else window.setTimeout(processSelective1b1, 0);\n    };\n\n    window.onload = delayedProcessSelective1b1;\n    if (document.readyState === \"complete\") {\n      delayedProcessSelective1b1();\n    }\n    else {\n      document.addEventListener(\"DOMContentLoaded\", delayedProcessSelective1b1);\n    }\n\n    // Observe document.body class changes to trigger re-rendering.\n    // This is useful, because Anki doesn’t always start with an up-to-date class list:\n    // https://forums.ankiweb.net/t/card-card-classes-only-injected-separately-now/27387.\n    const observer = new MutationObserver(function (mutationsList, observer) {\n      for (let mutation of mutationsList) {\n        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {\n          delayedProcessSelective1b1();\n        }\n      }\n    });\n    observer.observe(document.body, { attributes: true });\n  }\n  Persistence.setItem(\"clozeHints\", clozeHints);\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>\n\n\n{{/ÄsteCloze2}}\n{{/Äste}}",
      "afmt": "<!-- version f0935e4 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n<div id=\"back\"></div>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Eigene Notizen & Bilder\": \"Alt + 1\",\n    \"Eigene Prüfungsfragen\": \"Alt + 2\",\n    \"Definitionen\": \"Alt + 3\",\n    \"Merksprüche\": \"Alt + 4\",\n    \"Klinik\": \"Alt + 5\",\n    \"Präparat\": \"Alt + 6\",\n    \"Memes\": \"Alt + 7\",\n    \"linkContainer\": \"Alt + L\",\n    \"Meditricks\": \"Alt + M\",\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Eigene Notizen & Bilder\": false,\n    \"Eigene Prüfungsfragen\": false,\n    \"Definitionen\": false,\n    \"Merksprüche\": false,\n    \"Klinik\": false,\n    \"Präparat\": false,\n    \"Memes\": false,\n    \"linkContainer\": true,\n    \"Meditricks\": false,\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  var revealNextShortcut = \"N\"\n  var revealNextWordShortcut = \"Shift + N\"\n  var toggleAllShortcut = \",\"\n\n  // Enables revealing of next Cloze by simply clicking / tapping anywhere on the card (except the buttons)\n  var revealAnywhere = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // Changes how \"Reveal Next\" and clicking behaves. Either \"cloze\" or \"word\".\n  // \"word\" reveals word by word. \n  var revealNextClozeMode = \"cloze\"\n\n  // Changes how fields with additional information are displayed.\n  // true displays fields with additional information only if all clozes are revealed.\n  var hideAdditional = true;\n  var hideAdditionalButtons = true;\n\n  // What cloze is hidden with\n  var clozeHider = (elem) => \"[&nbsp;_&nbsp;]\"\n  /*\n  You can replace the above line with below examples. '█' or '_' works well for hiding clozes.\n  \n  // Fixed length:\n  var clozeHider = (elem) => \"███\"\n  // Replace each character with \"█\":\n  var clozeHider = (elem) => \"█\".repeat(elem.textContent.length)\n  // Show whitespaces:\n  var clozeHider = (elem) => \"[\" + elem.textContent.split(\" \").map((t) => \"█\".repeat(t.length)).join(\" \") + \"]\"\n  // Color-filled box (doesn't hide images):\n  var clozeHider = (elem) => `<span style=\"background-color: red; color: transparent;\">${elem.innerHTML}</span>`\n  */\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Was sind die <i>Äste</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" class=\"clozefield\" data-card=\"{{Card}}\"><br>{{Äste}}</div>\n\n    <!-- ClOZE ONE BY ONE BUTTONS -->\n    <div id=\"onebyone-buttons\" class=\"onebyone\">\n      <br>\n      <button id=\"button-reveal-next\" class=\"button-general button-one-by-one\"\n        onclick=\"revealNextCloze(); event.stopPropagation()\">Reveal Next</button>\n      <button id=\"button-toggle-all\" class=\"button-general button-one-by-one\"\n        onclick=\"toggleAllCloze(); event.stopPropagation()\">Toggle All</button>\n    </div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- BUTTON FIELDS -->\n    {{#Eigene Notizen & Bilder}}\n    <span id=\"hint-zusatz\" class=\"hintBtn\" data-name=\"Eigene Notizen & Bilder\" style=\"display: none;\">\n      <button id=\"button-zusatz\" class=\"button-general\" onclick=\"toggleHintBtn('hint-zusatz'); event.stopPropagation()\">\n        <img src=\"__zusatz.svg\" style=\"height: 10px;\"> Eigene Notizen & Bilder\n      </button>\n      <div dir=\"auto\" id=\"zusatz\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Notizen & Bilder}}</div>\n    </span>\n    {{/Eigene Notizen & Bilder}}\n\n    {{#Eigene Prüfungsfragen}}\n    <span id=\"hint-hammer\" class=\"hintBtn\" data-name=\"Eigene Prüfungsfragen\" style=\"display: none;\">\n      <button id=\"button-hammer\" class=\"button-general\" onclick=\"toggleHintBtn('hint-hammer'); event.stopPropagation()\">\n        <img src=\"__hammer.svg\" style=\"height: 10px;\"> Eigene Prüfungsfragen\n      </button>\n      <div dir=\"auto\" id=\"hammer\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Prüfungsfragen}}</div>\n    </span>\n    {{/Eigene Prüfungsfragen}}\n\n    {{#Definitionen}}\n    <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Definitionen\" style=\"display: none;\">\n      <button id=\"button-definition\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Definitionen\n      </button>\n      <div dir=\"auto\" id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Definitionen}}</div>\n    </span>\n    {{/Definitionen}}\n\n    {{#Merksprüche}}\n    <span id=\"hint-merksprueche\" class=\"hintBtn\" data-name=\"Merksprüche\" style=\"display: none;\">\n      <button id=\"button-merksprueche\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-merksprueche'); event.stopPropagation()\">\n        <img src=\"__merkhilfe.svg\" style=\"height: 10px;\"> Merksprüche\n      </button>\n      <div dir=\"auto\" id=\"merksprueche\" class=\"hints\" style=\"display: none;\">{{edit:Merksprüche}}</div>\n    </span>\n    {{/Merksprüche}}\n\n    {{#Klinik}}\n    <span id=\"hint-klinik\" class=\"hintBtn\" data-name=\"Klinik\" style=\"display: none;\">\n      <button id=\"button-klinik\" class=\"button-general\" onclick=\"toggleHintBtn('hint-klinik'); event.stopPropagation()\">\n        <img src=\"__stethoscope.svg\" style=\"height: 10px;\"> Klinik\n      </button>\n      <div dir=\"auto\" id=\"klinik\" class=\"hints\" style=\"display: none;\">{{edit:Klinik}}</div>\n    </span>\n    {{/Klinik}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-praeparat\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n        </button>\n      </a>\n    </span>\n    {{/Präparat}}\n\n    {{#Virtuelle Mikroskopie}}\n    <span id=\"hint-microscope-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Virtuelle Mikroskopie}}\">\n        <button id=\"button-microscope\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Virtuelle Mikroskopie\n        </button>\n      </a>\n    </span>\n    {{/Virtuelle Mikroskopie}}\n\n    {{#Smart Zoom}}\n    <span id=\"hint-smartzoom-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-smartzoom\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Smart Zoom\n        </button>\n      </a>\n    </span>\n    {{/Smart Zoom}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat\" class=\"hintBtn\" data-name=\"Präparat\" style=\"display: none;\">\n      <button id=\"button-praeparat\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-praeparat'); event.stopPropagation()\">\n        <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n      </button>\n      <div dir=\"auto\" id=\"praeparat\" class=\"hints\" style=\"display: none;\">{{edit:Präparat}}</div>\n    </span>\n    {{/Präparat}}\n\n    {{#Memes}}\n    <span id=\"hint-memes\" class=\"hintBtn\" data-name=\"Memes\" style=\"display: none;\">\n      <button id=\"button-memes\" class=\"button-general\" onclick=\"toggleHintBtn('hint-memes'); event.stopPropagation()\">\n        <img src=\"__sonstiges.svg\" style=\"height: 10px;\"> Memes\n      </button>\n      <div dir=\"auto\" id=\"memes\" class=\"hints\" style=\"display: none;\">{{edit:Memes}}</div>\n    </span>\n    {{/Memes}}\n\n    <!-- LINEBREAKS IF BUTTONS EXIST -->\n    <script>\n      var array = [`{{Eigene Notizen & Bilder}}`, `{{Eigene Prüfungsfragen}}`, `{{Definitionen}}`, `{{Merksprüche}}`, `{{Klinik}}`, `{{Präparat}}`, `{{Memes}}`];\n      var anyistrue = (element) => element;\n      if (array.some(anyistrue)) {\n        document.getElementById(\"linebreaksIfButtons\").innerHTML = \"<br>\";\n      }\n    </script>\n    <div id=\"linebreaksIfButtons\"></div>\n\n    <!-- Extra field -->\n    {{#Extra}}\n    <div id=\"extra\" style=\"display: none;\">\n      <br>{{edit:Extra}}<br><br>\n    </div>\n    {{/Extra}}\n\n    <!-- Image field -->\n    {{#Bild}}\n    <div id=\"image\" style=\"display: none;\">\n      {{edit:Bild}}<br><br></div>\n    {{/Bild}}\n    {{^Bild}}\n    <span id=\"image\" style=\"display: none;\"></span>\n    {{/Bild}}\n    {{#Bild}}\n    <span id=\"hint-image\" style=\"display: none;\">\n      <button id=\"button-image\" class=\"button-general\"\n        onclick=\"var image = document.getElementById('image'); if (image.style.display == 'none') { image.style.display = 'block' } else { image.style.display = 'none' }; event.stopPropagation()\">\n        <img src=\"__image.svg\" style=\"height: 10px;\"> Abbildung\n      </button>\n    </span>\n    {{/Bild}}\n\n    <span id=\"hint-uafi\" class=\"hintBtn\" data-name=\"Ursprung, Ansatz, Verlauf, Funktion, Innervation, Äste\"\n      style=\"display: none;\">\n      <button id=\"button-uafi\" class=\"button-general expanded-button\"\n        onclick=\"toggleHintBtn('hint-uafi'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Weitere Informationen\n      </button>\n      <div id=\"uafi\" class=\"hints\" style=\"display: block;\">\n        <table class=\"uncloze\">\n          {{#Ursprung}}\n          <tr class=\"uafi-element\" id=\"Ursprung\">\n            <td><i>Ursprung</i></td>\n            <td>{{Ursprung}}</td>\n          </tr>\n          {{/Ursprung}}\n          {{#Ansatz}}\n          <tr class=\"uafi-element\" id=\"Ansatz\">\n            <td><i>Ansatz</i></td>\n            <td>{{Ansatz}}</td>\n          </tr>\n          {{/Ansatz}}\n          {{#Verlauf}}\n          <tr class=\"uafi-element\" id=\"Verlauf\">\n            <td><i>Verlauf</i></td>\n            <td>{{Verlauf}}</td>\n          </tr>\n          {{/Verlauf}}\n          {{#Funktion}}\n          <tr class=\"uafi-element\" id=\"Funktion\">\n            <td><i>Funktion</i></td>\n            <td>{{Funktion}}</td>\n          </tr>\n          {{/Funktion}}\n          {{#Innervation}}\n          <tr class=\"uafi-element\" id=\"Innervation\">\n            <td><i>Innervation</i></td>\n            <td>{{Innervation}}</td>\n          </tr>\n          {{/Innervation}}\n          {{#Äste}}\n          <tr class=\"uafi-element\" id=\"Äste\">\n            <td><i>Äste</i></td>\n            <td>{{Äste}}</td>\n          </tr>\n          {{/Äste}}\n        </table>\n      </div>\n\n      <script>\n        // iterate over all uafi-elements and hide only the one\n        // that is equal to the card's answer (i.e., value of {{Card}})\n        var uafiElements = document.getElementsByClassName(\"uafi-element\");\n        for (var i = 0; i < uafiElements.length; i++) {\n          if (((\"{{Card}}\").startsWith(uafiElements[i].id))) {\n            uafiElements[i].remove()\n          }\n        }\n      </script>\n    </span>\n\n    {{#AMBOSS-Link}}\n    <span id=\"hint-amboss\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:AMBOSS-Link}}\">\n        <button id=\"button-amboss\" class=\"button-general\">\n          <img src=\"__amboss.svg\" style=\"height: 10px;\"> AMBOSS&#8203;\n        </button>\n      </a>\n    </span>\n    {{/AMBOSS-Link}}\n\n    {{#Thieme via medici-Link}}\n    <span id=\"hint-thieme\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Thieme via medici-Link}}\">\n        <button id=\"button-thieme\" class=\"button-general\">\n          <img id=\"button-thieme-img\" src=\"__thieme-heart.svg\" style=\"height: 10px;\"> Thieme via medici\n        </button>\n      </a>\n    </span>\n    {{/Thieme via medici-Link}}\n\n    {{#Meditricks}}\n    <span id=\"hint-meditricks\" class=\"hintBtn\" data-name=\"Meditricks\" style=\"display: none;\">\n      <button id=\"button-meditricks\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-meditricks'); event.stopPropagation()\">\n        <img src=\"__meditricks.svg\" style=\"height: 10px;\"> Meditricks\n      </button>\n      <div dir=\"auto\" id=\"meditricks\" class=\"hints\" style=\"display: none;\">{{edit:Meditricks}}</div>\n    </span>\n    {{/Meditricks}}\n\n    {{#weitere Links}}\n    <span id=\"hint-linkcontainer\" class=\"hintBtn\" data-name=\"linkContainer\" style=\"display: none;\">\n      <button id=\"button-linkcontainer\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-linkcontainer'); event.stopPropagation()\">\n        <img src=\"__internet.svg\" style=\"height: 10px;\"> weitere Links\n      </button>\n      <div id=\"linkcontainer\" class=\"hints\" style=\"display: none;\"></div>\n      <span id=\"linkContainerLinks\" style=\"display: none;\">{{edit:weitere Links}}</span>\n    </span>\n    {{/weitere Links}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n  try {\n    for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n      href = link.href\n      text = link.innerText\n\n      const el = document.createElement('a');\n      el.setAttribute('href', link.href);\n\n      const btn = document.createElement('button');\n      btn.classList.add('button-general');\n      btn.classList.add('expanded-button');\n\n      domain = href.replace(/.+\\/\\/|(www|flexikon|register|de|next|com).|\\..+/g, '');\n      domainDict = {\n        \"amboss\": \"__amboss.svg\",\n        \"wikipedia\": \"__wikipedia.svg\",\n        \"doccheck\": \"__doccheck.png\",\n        \"notfallguru\": \"__notfallguru.svg\",\n        \"awmf\": \"__awmf.svg\",\n        \"gelbe-liste\": \"__gelbe-liste.png\",\n        \"embryotox\": \"__embryotox.svg\",\n        \"radiopaedia\": \"__radiopaedia.png\",\n        \"orphanet\": \"__orphanet.png\",\n      }\n      if (domain in domainDict) {\n        icon = domainDict[domain]\n      } else {\n        icon = \"__internet.svg\"\n      }\n\n      const img = document.createElement('img');\n      img.setAttribute('src', icon);\n      img.setAttribute('style', 'height: 10px;');\n\n      btn.appendChild(img);\n      btn.innerHTML = btn.innerHTML + \" \" + text;\n\n      el.appendChild(btn);\n\n      document.getElementById(\"linkcontainer\").appendChild(el)\n    }\n  }\n  catch (err) {\n    console.log(err)\n  }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-uafi\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- AUTOFLIP BACK SCRIPT -->\n<script>\n  // autoflip hides card in front template\n  document.getElementById(\"qa\").style.removeProperty(\"display\")\n</script>\n\n<!-- CLOZE ONE BY ONE SCRIPT -->\n<style>\n  .cloze-replacer:hover {\n    cursor: pointer;\n  }\n\n  .cloze-hidden {\n    display: none;\n  }\n\n  .cloze-replacer .hidden {\n    display: none;\n  }\n\n  #extra.hidden {\n    display: none;\n  }\n</style>\n\n<!--\n Based on the AnKing Notetype, but expanded and modified by phyn.\n Credit to the original authors, except where modified or otherwise indicated.\n-->\n\n<script>\n    (function () {\n      // enables cloze one-by-one even when one-by-one field is empty\n      // minNumberOfClozes is still considered in this case\n      // overridden in importance by selectiveOneByOne\n      var clozeOneByOneEnabled = true;\n\n      // remove the clickAnywhere function from global scope\n      document.documentElement.removeAttribute(\"onclick\")\n\n      // --- CHECK IF ONE BY ONE IS GENERALLY ENABLED FOR THIS NOTE ---\n      var oneByOneFieldNotEmpty = \"{{One by one}}\" !== \"\";\n      try {\n        clozeOneByOneEnabled = alwaysOneByOne || oneByOneFieldNotEmpty;\n      } catch (exception) {\n        console.log(exception)\n      }\n\n      /**\n   * helper functions to show / hide fields containing additional information\n   */\n      const showExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const hideExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const buttonIds = [\n        \"hint-zusatz\",\n        \"hint-definition\",\n        \"hint-hammer\",\n        \"hint-klinik\",\n        \"hint-praeparat\",\n        \"hint-microscope\",\n        \"hint-smartzoom\",\n        \"hint-histotrainer\",\n        \"hint-uafi\",\n        \"hint-merksprueche\",\n        \"hint-memes\",\n        \"hint-image\",\n        \"hint-amboss\",\n        \"hint-thieme\",\n        \"hint-meditricks\",\n        \"hint-linkcontainer\",\n      ];\n\n      const showExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document\n              .getElementById(buttonIds[button])\n              .style.removeProperty(\"display\");\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n      const hideExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document.getElementById(buttonIds[button]).style.display = \"none\";\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n\n      // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n      /**\n       * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n       */\n      const getCardNumber = function () {\n        clz = document.body.className;\n        const regex = /card(\\d+)/gm;\n\n        let clz2;\n        try {\n          clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n        } catch (e) {\n          clz2 = \"\";\n        }\n        const regex2 = /.*?Cloze(\\d+)/gm;\n\n        let m;\n\n        if ((m = regex2.exec(clz2)) !== null) {\n          return m[1];\n        } else if ((m = regex.exec(clz)) !== null) {\n          return m[1];\n        } else {\n          // Should only fire if card is not cloze\n          console.error(\"Cannot find cardN class of body element!\");\n          return \"0\";\n        }\n      }\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (!clozeOneByOneEnabled) {\n        showExtra()\n        showExtraButtons()\n        document.getElementById(\"onebyone-buttons\").style.display = \"none\"\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n        return\n      }\n\n      // Needed for amboss to recognize first word in .cloze-hidden\n      const CLOZE_REPLACER_SEP = \"<span class='hidden'> </span>\"\n\n      const hideAllCloze = function (initial) {\n        let clozes = document.getElementsByClassName(\"cloze\")\n        let count = 0 // hidden cloze count\n        for (const cloze of clozes) {\n          const existingHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n          if (existingHidden) {\n            revealCloze(cloze);\n          }\n          if (cloze.offsetWidth === 0) {\n            continue\n          }\n          const clozeReplacer = document.createElement(\"span\")\n          const clozeHidden = document.createElement(\"span\")\n          clozeReplacer.classList.add(\"cloze-replacer\")\n          clozeHidden.classList.add(\"cloze-hidden\")\n          while (cloze.childNodes.length > 0) {\n            clozeHidden.appendChild(cloze.childNodes[0])\n          }\n          cloze.appendChild(clozeReplacer)\n          cloze.appendChild(clozeHidden)\n\n          var clozeHints = Persistence.getItem(\"clozeHints\");\n          if (clozeHints && clozeHints[count]) {\n            clozeReplacer.classList.add(\"cloze-hint\")\n            clozeReplacer.innerHTML = clozeHints[count] + CLOZE_REPLACER_SEP\n          } else {\n            clozeReplacer.innerHTML = clozeHider(cloze) + CLOZE_REPLACER_SEP\n          }\n          count += 1\n          document.getElementById(\"button-reveal-next\").style.display = \"inline-block\";\n          if (initial) {\n            cloze.addEventListener(\"touchend\", revealClozeClicked)\n            cloze.addEventListener(\"click\", revealClozeClicked)\n            cloze.classList.add(\"one-by-one\");\n          }\n        }\n\n        // Hide #extra until all clozes are shown\n        const extra = document.getElementById(\"extra\");\n        if (extra) {\n          extra.classList.add(\"hidden\");\n        }\n\n        hideExtra();\n        hideExtraButtons();\n        if (revealAnywhere) {\n          document.documentElement.setAttribute(\"onclick\", \"revealNextCloze(); event.stopPropagation()\")\n        }\n\n\n        // Also hide autoReveal fields\n        for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n          const container = document.querySelector(`[data-name=\"${field}\"]`)\n          if (container) {\n            const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n            if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n              // const link = container.getElementsByTagName(\"a\")[0]\n              const button = container.getElementsByTagName(\"button\")[0]\n              const hint = container.getElementsByTagName(\"div\")[0]\n              button.classList.remove(\"expanded-button\")\n              hint.style.display = \"none\"\n              // link.style.display = \"\"\n            }\n          }\n        }\n      }\n\n      const revealCloze = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        cloze.removeChild(clozeReplacer)\n        cloze.removeChild(clozeHidden)\n        while (clozeHidden.childNodes.length > 0) {\n          cloze.appendChild(clozeHidden.childNodes[0])\n        }\n        maybeRevealExtraField()\n      }\n\n      const revealClozeWord = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        let range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundSpace = setRangeEnd(range, clozeHidden, \"beforeFirstSpace\")\n        if (!foundSpace) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        let fragment = range.extractContents()\n        cloze.insertBefore(fragment, clozeReplacer)\n        // Extract whitespaces after word\n        range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundWord = setRangeEnd(range, clozeHidden, \"beforeFirstChar\")\n        if (!foundWord) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        fragment = range.extractContents();\n        cloze.insertBefore(fragment, clozeReplacer)\n        if (!foundWord) {\n          cloze.removeChild(clozeHidden)\n          cloze.removeChild(clozeReplacer)\n          maybeRevealExtraField()\n          return\n        }\n        clozeReplacer.innerHTML = clozeHider(clozeHidden) + CLOZE_REPLACER_SEP\n        if (clozeReplacer.classList.contains(\"cloze-hint\")) [\n          clozeReplacer.classList.remove(\"cloze-hint\")\n        ]\n        maybeRevealExtraField()\n      }\n\n      const revealNextClozeOf = (type) => {\n        const nextHidden = document.querySelectorAll(\".cloze-hidden\")\n        const nextNextHidden = nextHidden.length > 1 ? true : false\n        if (!nextNextHidden) {\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\";\n        }\n        if (!nextHidden) {\n          return\n        }\n        const cloze = clozeElOfClozeHidden(nextHidden[0]);\n        if (type === \"word\") {\n          revealClozeWord(cloze)\n        } else if (type === \"cloze\") {\n          revealCloze(cloze)\n        } else {\n          console.error(\"Invalid type: \" + type)\n        }\n      }\n\n      const revealClozeClicked = function (ev) {\n        let elem = ev.currentTarget\n        if (!ev.altKey && (revealNextClozeMode !== \"word\")) {\n          revealCloze(elem)\n        } else {\n          revealClozeWord(elem)\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      }\n\n      window.revealNextCloze = function () {\n        revealNextClozeOf(revealNextClozeMode)\n      }\n\n      window.toggleAllCloze = function () {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length > 0) {\n          for (const elem of elems) {\n            const cloze = clozeElOfClozeHidden(elem)\n            revealCloze(cloze)\n          }\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\"\n        } else {\n          hideAllCloze(initial = false)\n        }\n      }\n\n      const clozeElOfClozeHidden = (cloze) => {\n        while (!cloze.classList.contains(\"cloze\")) {\n          cloze = cloze.parentElement;\n        }\n        return cloze;\n      }\n\n      const maybeRevealExtraField = () => {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length == 0) {\n          const extra = document.getElementById(\"extra\")\n          if (extra) {\n            extra.classList.remove(\"hidden\")\n          }\n\n          showExtra();\n          showExtraButtons();\n          document.documentElement.removeAttribute(\"onclick\")\n\n          // Also reveal autoReveal fields\n          for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n            const container = document.querySelector(`[data-name=\"${field}\"]`)\n            if (container) {\n              const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n              if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n                // const link = container.getElementsByTagName(\"a\")[0]\n                const button = container.getElementsByTagName(\"button\")[0]\n                const hint = container.getElementsByTagName(\"div\")[0]\n                button.classList.add(\"expanded-button\")\n                hint.style.display = \"block\"\n                // link.style.display = \"none\"\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * mode: 'beforeFirstSpace' or 'beforeFirstChar'\n       * Return `true` if it exists and setEnd() was called, otherwise `false`\n       */\n      const setRangeEnd = function (range, node, mode) {\n        if (node.nodeType === Node.TEXT_NODE) {\n          const regex = mode === 'beforeFirstSpace' ? /\\s/ : /\\S/\n          const match = node.textContent.match(regex)\n          if (match) {\n            if (match.index === 0) {\n              while (node.previousSibling === null) {\n                node = node.parentElement\n              }\n              range.setEndBefore(node)\n            } else {\n              range.setEnd(node, match.index);\n            }\n            return true;\n          } else {\n            return false;\n          }\n        } else if (mode === 'beforeFirstChar' && isCharNode(node)) {\n          range.setEndBefore(node)\n          return true\n        } else if (!ignoreSpaceInNode(node)) {\n          for (const child of node.childNodes) {\n            if (setRangeEnd(range, child, mode)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }\n\n      const ignoreSpaceInNode = function (node) {\n        return node.tagName === \"MJX-ASSISTIVE-MML\"\n      }\n\n      const isCharNode = function (node) {\n        return [\"IMG\", \"MJX-CONTAINER\"].includes(node.tagName)\n      }\n\n      hideAllCloze(initial = true)\n\n      let isShowNextShortcut = shortcutMatcher(window.revealNextShortcut)\n      let isShowWordShortcut = shortcutMatcher(window.revealNextWordShortcut)\n      let isToggleAllShortcut = shortcutMatcher(window.toggleAllShortcut)\n      ankingAddEventListener(\"keydown\", (ev) => {\n        let next = isShowNextShortcut(ev)\n        let word = isShowWordShortcut(ev)\n        let all = isToggleAllShortcut(ev)\n        if (next) {\n          revealNextClozeOf(\"cloze\")\n        } else if (word) {\n          revealNextClozeOf(\"word\")\n        } else if (all) {\n          toggleAllCloze()\n        } else {\n          return;\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      });\n    })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- MEDITRICKS SNIPPETS DATA -->\n<div id=\"meditricks-mtsp-values\" style=\"display:none;\">\n  <div id=\"meditricks-mtsp-nfname\">_meditricks_nf_v1000_ankizin</div>\n  <div id=\"meditricks-mtsp-nid\">{{Note ID}}</div>\n</div>\n<script src=\"_meditricks_mtsp_scripts_v1000_ankizin.js\"></script>\n<link href=\"_meditricks_mtsp_styles_v1000_ankizin.css\" rel=\"stylesheet\" />\n\n<!-- include \"_meditricks_mtsp_nf_v1000_ankizin.js\" -->\n<!-- include \"_meditricks_mtsp_scripts_v1000_iframe.map\" -->\n<!-- include \"_meditricks_mtsp_mtlogo.webp\" -->\n<!-- include \"_meditricks_mtsp_mt-loading.png\" -->\n<!-- include \"_meditricks_mtsp_mt-loading_night.png\" -->\n\n<!-- //MEDITRICKS SNIPPETS DATA -->\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>",
      "bqfmt": "{{Muskel / Leitungsbahn}}",
      "bafmt": "{{Äste}}",
      "bfont": "Helvetica",
      "bsize": 12
    },
    {
      "name": "ÄsteCloze3",
      "ord": 23,
      "qfmt": "<!-- version f0935e4 -->\n{{#Äste}}\n{{#ÄsteCloze3}}\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TIMER CONFIG  ##############\n  // Timer config (timer length, timer finished message)\n  var minutes = 0\n  var seconds = 15\n  var timeOverMsg = \"<span style='color:#CC5B5B'>!!!</span>\"\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  // Auto flip to back when One by one mode.\n  var autoflip = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Was sind die <i>Äste</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" data-card=\"{{Card}}\"><br>{{Äste}}</div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\"></div>\n\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<script>\n  //DONT FADE BETWEEN CARDS\n  qFade = 0;\n  if (typeof anki !== 'undefined') anki.qFade = qFade;\n</script>\n\n<!-- INDENTING -->\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // use a function for the EventListener in line 284\n  function doIndentText() {\n    if (!indentation) { return; }\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n    // remove uneeded EventListener\n    window.removeEventListener('load', doIndentText);\n  }\n\n  // do the indentation only after the text content of the card is loaded\n  window.addEventListener('load', doIndentText, {\n    once: true\n  });\n  dispatchEvent(new Event('load'));\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- CLOZE ONE BY ONE FRONT -->\n<div id=\"one-by-one\" style=\"display: none;\"></div>\n\n<script>\n  /**\n   * Based on the AnKing Notetype, but expanded and modified by phyn.\n   * Credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  Persistence.clear();\n\n  // check if OneByOne is generally enabled for this card\n  var oneByOneFieldEmpty = selectiveOneByOne ? \"{{One by one}}\" === \"\" : true;\n  var clozeOneByOneEnabled = alwaysOneByOne ? true : !oneByOneFieldEmpty;\n\n  // avoid flickering. Must unset this in the back.\n  document.getElementById(\"qa\").style.display = \"none\";\n  var clozeHints = [];\n\n  if (clozeOneByOneEnabled) {\n    // collect hints from front side (independent of whether or not OneByOne is enabled)\n    document.getElementById(\"qa\").classList.add('one-by-one');\n    // Save cloze hints to display in the back\n    var clozes = document.getElementsByClassName(\"cloze\")\n    for (var i = 0; i < clozes.length; i++) {\n      clozes[i].classList.add(\"one-by-one\");\n      if (clozes[i].innerHTML === \"[...]\") {\n        clozeHints.push(\"\")\n      } else {\n        clozeHints.push(clozes[i].innerHTML)\n      }\n    }\n\n    // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n    /**\n     * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n     */\n    const getCardNumber = function () {\n      clz = document.body.className;\n      const regex = /card(\\d+)/gm;\n\n      let clz2;\n      try {\n        clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n      } catch (e) {\n        clz2 = \"\";\n      }\n      const regex2 = /.*?Cloze(\\d+)/gm;\n\n      let m;\n\n      if ((m = regex2.exec(clz2)) !== null) {\n        return m[1];\n      } else if ((m = regex.exec(clz)) !== null) {\n        return m[1];\n      } else {\n        // Should only fire if card is not cloze\n        console.error(\"Cannot find cardN class of body element!\");\n        return \"0\";\n      }\n    }\n\n    var alreadyRendered = false;\n\n    function processSelective1b1() {\n      if (alreadyRendered) return;\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (autoflip && clozeOneByOneEnabled) {\n        if (window.pycmd || window.showAnswer) {\n          // avoid flickering. Must unset this in the back.\n          document.getElementById(\"qa\").style.display = \"none\";\n        }\n        if (window.pycmd) {\n          pycmd(\"ans\")\n        } else if (window.showAnswer) {\n          showAnswer()\n        }\n      } else {\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n      }\n      // AnkiMobile JS API doesn't have one for show answer.\n      // Best alternative is to use Taps/Swipes to show answer.\n\n      alreadyRendered = true;\n    }\n\n    function delayedProcessSelective1b1() {\n      if (window.requestAnimationFrame) window.requestAnimationFrame(processSelective1b1); // less flickering\n      else window.setTimeout(processSelective1b1, 0);\n    };\n\n    window.onload = delayedProcessSelective1b1;\n    if (document.readyState === \"complete\") {\n      delayedProcessSelective1b1();\n    }\n    else {\n      document.addEventListener(\"DOMContentLoaded\", delayedProcessSelective1b1);\n    }\n\n    // Observe document.body class changes to trigger re-rendering.\n    // This is useful, because Anki doesn’t always start with an up-to-date class list:\n    // https://forums.ankiweb.net/t/card-card-classes-only-injected-separately-now/27387.\n    const observer = new MutationObserver(function (mutationsList, observer) {\n      for (let mutation of mutationsList) {\n        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {\n          delayedProcessSelective1b1();\n        }\n      }\n    });\n    observer.observe(document.body, { attributes: true });\n  }\n  Persistence.setItem(\"clozeHints\", clozeHints);\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>\n\n\n{{/ÄsteCloze3}}\n{{/Äste}}",
      "afmt": "<!-- version f0935e4 -->\n<!-- empty div to make AnkiDroid happy -->\n<div></div>\n\n<!-- include cloze_anything -->\n<script defer src=\"_cloze_anything_0.4.js\"></script>\n<div id=\"back\"></div>\n\n\n<script>\n  // ############## USER CONFIGURATION START ##############\n  // ##############  HINT REVEAL SHORTCUTS  ##############\n  // All shortcuts will also open with \"H\" if using the Hint Hotkeys add-on \n  var ButtonShortcuts = {\n    \"Eigene Notizen & Bilder\": \"Alt + 1\",\n    \"Eigene Prüfungsfragen\": \"Alt + 2\",\n    \"Definitionen\": \"Alt + 3\",\n    \"Merksprüche\": \"Alt + 4\",\n    \"Klinik\": \"Alt + 5\",\n    \"Präparat\": \"Alt + 6\",\n    \"Memes\": \"Alt + 7\",\n    \"linkContainer\": \"Alt + L\",\n    \"Meditricks\": \"Alt + M\",\n    \"Tags\": \"Alt + 8\",\n    \"Quelle\": \"Alt + 9\",\n    \"Note ID\": \"Alt + 0\"\n  }\n  var ToggleNextButtonShortcut = \"H\"\n  var ToggleAllButtonsShortcut = \"J\"\n  // ToggleAllButtonsShortcut currently toggling every button individually (1, 2 open; 3, 4 closed -> 1, 2 closed; 3, 4 open)\n\n  // ##############  SHOW HINTS AUTOMATICALLY  ##############\n  var ButtonAutoReveal = {\n    \"Eigene Notizen & Bilder\": false,\n    \"Eigene Prüfungsfragen\": false,\n    \"Definitionen\": false,\n    \"Merksprüche\": false,\n    \"Klinik\": false,\n    \"Präparat\": false,\n    \"Memes\": false,\n    \"linkContainer\": true,\n    \"Meditricks\": false,\n    \"Tags\": false,\n    \"Quelle\": false,\n    \"Note ID\": false\n  }\n  var ScrollToButton = false;\n\n  // ##############  TAG SHORTCUT  ##############\n  var toggleTagsShortcut = \"C\";\n\n  // ENTER THE TAG TERM WHICH, WHEN PRESENT, WILL TRIGGER A RED BACKGROUND\n  var tagID = \"XXXYYYZZZ\"\n\n  // WHETHER THE WHOLE TAG OR ONLY THE LAST PART SHOULD BE SHOWN\n  var numTagLevelsToShow = 0;\n\n  // ENTER THE UNIVERSITY FOR WHICH CURRICULUM SPECIFIC TAGS SHOULD BE SHOWN\n  var tagUniversity = \"XXXYYYZZZ\"\n\n  // ##############  INDENTATION  ##############\n  // Enable experimental heuristic indentation feature\n  var indentation = true;\n\n  // ##############  DIVI FORMAT  ##############\n  // Enable experimental DIVI medication formatting feature\n  var formattingDIVI = false;\n\n  // ##############  CONFOUNDER FORMAT  ##############\n  // Enable experimental confounder formatting feature\n  var formattingConfounders = false;\n\n  // ############  BIONIC READING  ############\n  // Enable bionic reading feature (based on AnKing add-on)\n  var bionicReading = false;\n\n  // ##############  CLOZE ONE BY ONE  ##############\n  var revealNextShortcut = \"N\"\n  var revealNextWordShortcut = \"Shift + N\"\n  var toggleAllShortcut = \",\"\n\n  // Enables revealing of next Cloze by simply clicking / tapping anywhere on the card (except the buttons)\n  var revealAnywhere = true;\n\n  // INFO ----------------------\n  // to make a card behave like normal clozes without one-by-one, set:\n  // selectiveOneByOne = false, minNumberOfClozes = Infinity, alwaysOneByOne = false\n  // ---------------------------\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables selective cloze one-by-one (e.g. only c1 and c3)\n  // seperate wanted numbers by \",\" in one-by-one field\n  var selectiveOneByOne = false;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // if selective one-by-one is disabled, set this to select a min number of clozes necessary to activate 1b1\n  // can be set to any number to set lower bound, any falsy value (e.g. 0 or null) disables this setting\n  var minNumberOfClozes = 3;\n\n  // THIS NEEDS TO BE SET ON THE BACK AS WELL\n  // enables cloze one-by-one even when one-by-one field is empty\n  // minNumberOfClozes is still considered in this case\n  // overridden in importance by selectiveOneByOne\n  var alwaysOneByOne = true;\n  // ----------------------------\n\n  // Changes how \"Reveal Next\" and clicking behaves. Either \"cloze\" or \"word\".\n  // \"word\" reveals word by word. \n  var revealNextClozeMode = \"cloze\"\n\n  // Changes how fields with additional information are displayed.\n  // true displays fields with additional information only if all clozes are revealed.\n  var hideAdditional = true;\n  var hideAdditionalButtons = true;\n\n  // What cloze is hidden with\n  var clozeHider = (elem) => \"[&nbsp;_&nbsp;]\"\n  /*\n  You can replace the above line with below examples. '█' or '_' works well for hiding clozes.\n  \n  // Fixed length:\n  var clozeHider = (elem) => \"███\"\n  // Replace each character with \"█\":\n  var clozeHider = (elem) => \"█\".repeat(elem.textContent.length)\n  // Show whitespaces:\n  var clozeHider = (elem) => \"[\" + elem.textContent.split(\" \").map((t) => \"█\".repeat(t.length)).join(\" \") + \"]\"\n  // Color-filled box (doesn't hide images):\n  var clozeHider = (elem) => `<span style=\"background-color: red; color: transparent;\">${elem.innerHTML}</span>`\n  */\n\n  // ############### USER CONFIGURATION END ###############\n</script>\n\n<!-- ###################################### -->\n<!-- ##############  HEADER  ############## -->\n<!-- ###################################### -->\n<div id=\"header-container\">\n  <div class=\"header\">\n    <!-- TIMER -->\n    <div class=\"head-flex-left\">\n      <span class=\"timer\" id=\"timer\"></span>\n    </div>\n\n    <div class=\"head-flex-mid\">\n      <!-- TAGS FIELD -->\n      {{#Tags}}\n      <button id=\"button-tags\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\">\n        Tags\n      </button> |\n      {{/Tags}}\n\n      <!-- SOURCE FIELD -->\n      {{#Quelle}}\n      <button id=\"button-src\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\">\n        Quelle\n      </button>\n      {{/Quelle}}\n\n      <!-- NOTE ID FIELD -->\n      {{#Note ID}} |\n      <button id=\"button-nid\" class=\"button-general headhov\"\n        onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\">\n        Note ID\n      </button>\n      {{/Note ID}}\n    </div>\n\n    <!-- ERRATA BUTTON -->\n    <div class=\"head-flex-right\" onclick=\"event.stopPropagation()\">\n      <a id=\"link-ankihub\" href=\"https://app.ankihub.net/\">\n        <button id=\"button-ankihub\" class=\"button-general\" title=\"Karte in AnkiHub\">\n          <strong>AnkiHub</strong>\n        </button>\n      </a>\n      <script>\n        try {\n          document.getElementById(\"link-ankihub\").href =\n            document.getElementsByClassName(\"ankihub-view-note\")[0].href\n        } catch (e) { }\n      </script>\n    </div>\n  </div>\n\n  <!-- CLICKABLE COLORFUL TAGS -->\n  {{#Tags}}\n  <span id=\"hint-tags\" class=\"hintBtn\" data-name=\"Tags\" style=\"display: flex\">\n    <button id=\"button-tags\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-tags'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"tags-container\" class=\"hints\" style=\"display: none\">\n      {{clickable::Tags}}\n    </div>\n  </span>\n  {{/Tags}} {{#Quelle}}\n  <span id=\"hint-src\" class=\"hintBtn\" data-name=\"Quelle\" style=\"display: flex\">\n    <button id=\"button-src\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-src'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"src\" class=\"hints\" style=\"display: none\">\n      Quelle: {{Quelle}}\n      {{#Datum}}<br>Datum: {{Datum}}{{/Datum}}\n    </div>\n  </span>\n  {{/Quelle}} {{#Note ID}}\n  <span id=\"hint-nid\" class=\"hintBtn\" data-name=\"Note ID\" style=\"display: flex\">\n    <button id=\"button-nid\" style=\"all: unset !important; display: none\"\n      onclick=\"toggleHintBtn('hint-nid'); event.stopPropagation()\"></button>\n    <!-- too lazy to rewrite toggleHintBtn script, so a invisible button must do it -->\n    <div id=\"nid\" class=\"hints\" style=\"display: none\">ID: {{Note ID}}</div>\n  </span>\n  {{/Note ID}}\n\n  <hr />\n</div>\n\n\n<div id=\"container\" class=\"anatomietrainer\">\n  <div class=\"col\" id=\"container-content\">\n\n    <!-- ####################################### -->\n    <!-- ##############  CONTENT  ############## -->\n    <!-- ####################################### -->\n\n    Was sind die <i>Äste</i> von <span class=\"frage\">{{Muskel / Leitungsbahn}}</span>?\n\n    <br>\n\n    <!-- has to be <div> to allow for indentation -->\n    <div id=\"cloze\" class=\"clozefield\" data-card=\"{{Card}}\"><br>{{Äste}}</div>\n\n    <!-- ClOZE ONE BY ONE BUTTONS -->\n    <div id=\"onebyone-buttons\" class=\"onebyone\">\n      <br>\n      <button id=\"button-reveal-next\" class=\"button-general button-one-by-one\"\n        onclick=\"revealNextCloze(); event.stopPropagation()\">Reveal Next</button>\n      <button id=\"button-toggle-all\" class=\"button-general button-one-by-one\"\n        onclick=\"toggleAllCloze(); event.stopPropagation()\">Toggle All</button>\n    </div>\n\n    <br>\n    <br>\n\n  </div>\n\n  <div class=\"col\" id=\"container-buttons\">\n\n    <!-- ####################################### -->\n    <!-- ##############  BUTTONS  ############## -->\n    <!-- ####################################### -->\n    <!-- BUTTON FIELDS -->\n    {{#Eigene Notizen & Bilder}}\n    <span id=\"hint-zusatz\" class=\"hintBtn\" data-name=\"Eigene Notizen & Bilder\" style=\"display: none;\">\n      <button id=\"button-zusatz\" class=\"button-general\" onclick=\"toggleHintBtn('hint-zusatz'); event.stopPropagation()\">\n        <img src=\"__zusatz.svg\" style=\"height: 10px;\"> Eigene Notizen & Bilder\n      </button>\n      <div dir=\"auto\" id=\"zusatz\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Notizen & Bilder}}</div>\n    </span>\n    {{/Eigene Notizen & Bilder}}\n\n    {{#Eigene Prüfungsfragen}}\n    <span id=\"hint-hammer\" class=\"hintBtn\" data-name=\"Eigene Prüfungsfragen\" style=\"display: none;\">\n      <button id=\"button-hammer\" class=\"button-general\" onclick=\"toggleHintBtn('hint-hammer'); event.stopPropagation()\">\n        <img src=\"__hammer.svg\" style=\"height: 10px;\"> Eigene Prüfungsfragen\n      </button>\n      <div dir=\"auto\" id=\"hammer\" class=\"hints\" style=\"display: none;\">{{edit:Eigene Prüfungsfragen}}</div>\n    </span>\n    {{/Eigene Prüfungsfragen}}\n\n    {{#Definitionen}}\n    <span id=\"hint-definition\" class=\"hintBtn\" data-name=\"Definitionen\" style=\"display: none;\">\n      <button id=\"button-definition\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-definition'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Definitionen\n      </button>\n      <div dir=\"auto\" id=\"definition\" class=\"hints\" style=\"display: none;\">{{edit:Definitionen}}</div>\n    </span>\n    {{/Definitionen}}\n\n    {{#Merksprüche}}\n    <span id=\"hint-merksprueche\" class=\"hintBtn\" data-name=\"Merksprüche\" style=\"display: none;\">\n      <button id=\"button-merksprueche\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-merksprueche'); event.stopPropagation()\">\n        <img src=\"__merkhilfe.svg\" style=\"height: 10px;\"> Merksprüche\n      </button>\n      <div dir=\"auto\" id=\"merksprueche\" class=\"hints\" style=\"display: none;\">{{edit:Merksprüche}}</div>\n    </span>\n    {{/Merksprüche}}\n\n    {{#Klinik}}\n    <span id=\"hint-klinik\" class=\"hintBtn\" data-name=\"Klinik\" style=\"display: none;\">\n      <button id=\"button-klinik\" class=\"button-general\" onclick=\"toggleHintBtn('hint-klinik'); event.stopPropagation()\">\n        <img src=\"__stethoscope.svg\" style=\"height: 10px;\"> Klinik\n      </button>\n      <div dir=\"auto\" id=\"klinik\" class=\"hints\" style=\"display: none;\">{{edit:Klinik}}</div>\n    </span>\n    {{/Klinik}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-praeparat\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n        </button>\n      </a>\n    </span>\n    {{/Präparat}}\n\n    {{#Virtuelle Mikroskopie}}\n    <span id=\"hint-microscope-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Virtuelle Mikroskopie}}\">\n        <button id=\"button-microscope\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Virtuelle Mikroskopie\n        </button>\n      </a>\n    </span>\n    {{/Virtuelle Mikroskopie}}\n\n    {{#Smart Zoom}}\n    <span id=\"hint-smartzoom-link\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Präparat}}\">\n        <button id=\"button-smartzoom\" class=\"button-general\">\n          <img src=\"__microscope.svg\" style=\"height: 10px;\"> Smart Zoom\n        </button>\n      </a>\n    </span>\n    {{/Smart Zoom}}\n\n    {{#Präparat}}\n    <span id=\"hint-praeparat\" class=\"hintBtn\" data-name=\"Präparat\" style=\"display: none;\">\n      <button id=\"button-praeparat\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-praeparat'); event.stopPropagation()\">\n        <img src=\"__microscope.svg\" style=\"height: 10px;\"> Präparat\n      </button>\n      <div dir=\"auto\" id=\"praeparat\" class=\"hints\" style=\"display: none;\">{{edit:Präparat}}</div>\n    </span>\n    {{/Präparat}}\n\n    {{#Memes}}\n    <span id=\"hint-memes\" class=\"hintBtn\" data-name=\"Memes\" style=\"display: none;\">\n      <button id=\"button-memes\" class=\"button-general\" onclick=\"toggleHintBtn('hint-memes'); event.stopPropagation()\">\n        <img src=\"__sonstiges.svg\" style=\"height: 10px;\"> Memes\n      </button>\n      <div dir=\"auto\" id=\"memes\" class=\"hints\" style=\"display: none;\">{{edit:Memes}}</div>\n    </span>\n    {{/Memes}}\n\n    <!-- LINEBREAKS IF BUTTONS EXIST -->\n    <script>\n      var array = [`{{Eigene Notizen & Bilder}}`, `{{Eigene Prüfungsfragen}}`, `{{Definitionen}}`, `{{Merksprüche}}`, `{{Klinik}}`, `{{Präparat}}`, `{{Memes}}`];\n      var anyistrue = (element) => element;\n      if (array.some(anyistrue)) {\n        document.getElementById(\"linebreaksIfButtons\").innerHTML = \"<br>\";\n      }\n    </script>\n    <div id=\"linebreaksIfButtons\"></div>\n\n    <!-- Extra field -->\n    {{#Extra}}\n    <div id=\"extra\" style=\"display: none;\">\n      <br>{{edit:Extra}}<br><br>\n    </div>\n    {{/Extra}}\n\n    <!-- Image field -->\n    {{#Bild}}\n    <div id=\"image\" style=\"display: none;\">\n      {{edit:Bild}}<br><br></div>\n    {{/Bild}}\n    {{^Bild}}\n    <span id=\"image\" style=\"display: none;\"></span>\n    {{/Bild}}\n    {{#Bild}}\n    <span id=\"hint-image\" style=\"display: none;\">\n      <button id=\"button-image\" class=\"button-general\"\n        onclick=\"var image = document.getElementById('image'); if (image.style.display == 'none') { image.style.display = 'block' } else { image.style.display = 'none' }; event.stopPropagation()\">\n        <img src=\"__image.svg\" style=\"height: 10px;\"> Abbildung\n      </button>\n    </span>\n    {{/Bild}}\n\n    <span id=\"hint-uafi\" class=\"hintBtn\" data-name=\"Ursprung, Ansatz, Verlauf, Funktion, Innervation, Äste\"\n      style=\"display: none;\">\n      <button id=\"button-uafi\" class=\"button-general expanded-button\"\n        onclick=\"toggleHintBtn('hint-uafi'); event.stopPropagation()\">\n        <img src=\"__explanation.svg\" style=\"height: 10px;\"> Weitere Informationen\n      </button>\n      <div id=\"uafi\" class=\"hints\" style=\"display: block;\">\n        <table class=\"uncloze\">\n          {{#Ursprung}}\n          <tr class=\"uafi-element\" id=\"Ursprung\">\n            <td><i>Ursprung</i></td>\n            <td>{{Ursprung}}</td>\n          </tr>\n          {{/Ursprung}}\n          {{#Ansatz}}\n          <tr class=\"uafi-element\" id=\"Ansatz\">\n            <td><i>Ansatz</i></td>\n            <td>{{Ansatz}}</td>\n          </tr>\n          {{/Ansatz}}\n          {{#Verlauf}}\n          <tr class=\"uafi-element\" id=\"Verlauf\">\n            <td><i>Verlauf</i></td>\n            <td>{{Verlauf}}</td>\n          </tr>\n          {{/Verlauf}}\n          {{#Funktion}}\n          <tr class=\"uafi-element\" id=\"Funktion\">\n            <td><i>Funktion</i></td>\n            <td>{{Funktion}}</td>\n          </tr>\n          {{/Funktion}}\n          {{#Innervation}}\n          <tr class=\"uafi-element\" id=\"Innervation\">\n            <td><i>Innervation</i></td>\n            <td>{{Innervation}}</td>\n          </tr>\n          {{/Innervation}}\n          {{#Äste}}\n          <tr class=\"uafi-element\" id=\"Äste\">\n            <td><i>Äste</i></td>\n            <td>{{Äste}}</td>\n          </tr>\n          {{/Äste}}\n        </table>\n      </div>\n\n      <script>\n        // iterate over all uafi-elements and hide only the one\n        // that is equal to the card's answer (i.e., value of {{Card}})\n        var uafiElements = document.getElementsByClassName(\"uafi-element\");\n        for (var i = 0; i < uafiElements.length; i++) {\n          if (((\"{{Card}}\").startsWith(uafiElements[i].id))) {\n            uafiElements[i].remove()\n          }\n        }\n      </script>\n    </span>\n\n    {{#AMBOSS-Link}}\n    <span id=\"hint-amboss\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:AMBOSS-Link}}\">\n        <button id=\"button-amboss\" class=\"button-general\">\n          <img src=\"__amboss.svg\" style=\"height: 10px;\"> AMBOSS&#8203;\n        </button>\n      </a>\n    </span>\n    {{/AMBOSS-Link}}\n\n    {{#Thieme via medici-Link}}\n    <span id=\"hint-thieme\" onclick=\"event.stopPropagation()\" style=\"display: none;\">\n      <a href=\"{{text:Thieme via medici-Link}}\">\n        <button id=\"button-thieme\" class=\"button-general\">\n          <img id=\"button-thieme-img\" src=\"__thieme-heart.svg\" style=\"height: 10px;\"> Thieme via medici\n        </button>\n      </a>\n    </span>\n    {{/Thieme via medici-Link}}\n\n    {{#Meditricks}}\n    <span id=\"hint-meditricks\" class=\"hintBtn\" data-name=\"Meditricks\" style=\"display: none;\">\n      <button id=\"button-meditricks\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-meditricks'); event.stopPropagation()\">\n        <img src=\"__meditricks.svg\" style=\"height: 10px;\"> Meditricks\n      </button>\n      <div dir=\"auto\" id=\"meditricks\" class=\"hints\" style=\"display: none;\">{{edit:Meditricks}}</div>\n    </span>\n    {{/Meditricks}}\n\n    {{#weitere Links}}\n    <span id=\"hint-linkcontainer\" class=\"hintBtn\" data-name=\"linkContainer\" style=\"display: none;\">\n      <button id=\"button-linkcontainer\" class=\"button-general\"\n        onclick=\"toggleHintBtn('hint-linkcontainer'); event.stopPropagation()\">\n        <img src=\"__internet.svg\" style=\"height: 10px;\"> weitere Links\n      </button>\n      <div id=\"linkcontainer\" class=\"hints\" style=\"display: none;\"></div>\n      <span id=\"linkContainerLinks\" style=\"display: none;\">{{edit:weitere Links}}</span>\n    </span>\n    {{/weitere Links}}\n\n  </div>\n</div>\n\n<!-- ##############  TEXT-TO-SPEECH ##############\nreplace the arrows/dashes from the statement below with double curly brackets-->\n<!--tts en_US voices=Apple_Samantha speed=1.4:cloze-only:Text-->\n\n<!-- ####################################### -->\n<!-- ##############  SCRIPTS  ############## -->\n<!-- ####################################### -->\n\n<!-- ############ DO NOT DELETE ############# -->\n<!-- ~~~~~~~~~CUSTOM SCRIPT INSERTION~~~~~~~~ -->\n\n<!-- ############ DO NOT DELETE ############# -->\n\n<script>\n  /**\n* Uses canvas.measureText to compute and return the width of the given text of given font in pixels.\n* \n* @param {String} text: The text to be rendered.\n* @param {String} font: The CSS font descriptor that text is to be rendered with (e.g. \"bold 14px verdana\").\n* \n* @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393\n*/\n  function getTextWidth(text, font) {\n    // re-use canvas object for better performance\n    const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement(\"canvas\"));\n    const context = canvas.getContext(\"2d\");\n    context.font = font;\n    const metrics = context.measureText(text);\n    return metrics.width;\n  }\n\n  function getCSSStyle(element, prop) {\n    return window.getComputedStyle(element, null).getPropertyValue(prop);\n  }\n\n  function getCanvasFont(el = document.body) {\n    const fontWeight = getCSSStyle(el, 'font-weight') || 'normal';\n    const fontSize = getCSSStyle(el, 'font-size') || '16px';\n    const fontFamily = getCSSStyle(el, 'font-family') || 'Times New Roman';\n\n    return `${fontWeight} ${fontSize} ${fontFamily}`;\n  }\n\n  /**\n  * Iterates over a list of divs containing text to be indented\n  *\n  * @param {HTMLCollection} divs: The divs to be iterated over.\n  */\n  function indentText(divs) {\n    // setup the indentation markers\n    var numbers = \"(\" + \"⓪①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳\".split(\"\").join(\"|\") + \")\"\n    var letters = \"(\" + \"ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ\".split(\"\").join(\"|\") + \")\"\n    var bulletP = \"•\"\n    var minus = \"– \"\n    var enter = \"↳(?!( ↳|↳))\"\n    var arrow = \"→\"\n\n    // heuristic indentation hierarchy\n    hierarchy = [numbers, letters, bulletP, minus, enter, bulletP]\n\n    // set up RegEx to analyze the provided divs\n    // negative lookbehinds unfortunately do not work yet on iPad / Android\n    var beginning = '(?<=<(br|td|td rowspan=\"\\\\d\"|td colspan=\"\\\\d\"|hr|div)>)(?<!cloze=\")('\n    var middle = \".*?)((?:<br>)(?=(\"\n    var end = \"))|(?=(<\\/indent>|<\\/div>|<\\/td>|<br><br>|<img)))\"\n\n    // const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + \"))|(?=<\\/div>|<br><br>))\", \"g\")\n    const reNumbers = new RegExp(beginning + hierarchy[0] + middle + hierarchy[0] + end, \"g\")\n    const reLetters = new RegExp(beginning + hierarchy[1] + middle + hierarchy.slice(0, 2).join('|') + end, \"g\")\n    const reBulletP = new RegExp(beginning + hierarchy[2] + middle + hierarchy.slice(0, 3).join('|') + end, \"g\")\n    const reMinus = new RegExp(beginning + hierarchy[3] + middle + hierarchy.slice(0, 4).join('|') + end, \"g\")\n    const reEnter = new RegExp(beginning + hierarchy[4] + middle + hierarchy.slice(0, 5).join('|') + end, \"g\")\n    const reArrow = new RegExp(beginning + hierarchy[5] + middle + hierarchy.slice(0, 6).join('|') + end, \"g\")\n\n    // iterate over divs\n    for (const div of divs) {\n      // calculate indentation depths\n      var canvasFont = getCanvasFont(div)\n      var circledWidth = getTextWidth(\"① \", canvasFont).toString() + \"px\"\n      var bulletPWidth = getTextWidth(\"• \", canvasFont).toString() + \"px\"\n      var minusWidth = getTextWidth(\"– \", canvasFont).toString() + \"px\"\n      var enterWidth = getTextWidth(\"↳ \", canvasFont).toString() + \"px\"\n      var arrowWidth = getTextWidth(\"→ \", canvasFont).toString() + \"px\"\n\n      var indentStart = '<indent style=\"margin: 0; display: block; padding-left:' // display: inline-block; vertical-align: top;\n      var indentEnd = ';\">$2</indent>'\n\n      // do the indentation\n      divHTML = div.outerHTML\n      divHTML = divHTML.replaceAll(/(\\d|<sup>|<sub>)–(\\d|<\\/sup>|<\\/sub>|&#8288;)/g, \"$1‒$2\").replaceAll(\"–&#8288;\", \"‒&#8288;\")\n      divHTML = divHTML.replaceAll(reNumbers, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reLetters, indentStart + circledWidth + '; text-indent: -' + circledWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reBulletP, indentStart + bulletPWidth + '; text-indent: -' + bulletPWidth + indentEnd)\n      divHTML = divHTML.replaceAll(reMinus, indentStart + minusWidth + '; text-indent: -' + minusWidth + indentEnd)\n\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      divHTML = divHTML.replaceAll(\"↳ ↳ \", \"↳ \").replaceAll(\"↳↳ \", \"↳ \")\n      divHTML = divHTML.replaceAll(reEnter, indentStart + enterWidth + '; text-indent: -' + enterWidth + indentEnd)\n      //divHTML = divHTML.replaceAll(reArrow,    indentStart + arrowWidth   + '; text-indent: -' + arrowWidth   + indentEnd)\n\n      div.outerHTML = divHTML.replaceAll(\"<br></indent>\", \"</indent><br>\").replaceAll(\"</indent><br><br>\", \"</indent><br>\").replaceAll(\"</indent><br><img\", \"</indent><img\")\n    }\n  }\n\n  // do the indentation if wanted\n  if (indentation) {\n    indentText(document.getElementById(\"container-content\").getElementsByTagName(\"div\"));\n    indentText(document.getElementById(\"container-buttons\").getElementsByTagName(\"div\"));\n  }\n</script>\n\n<!-- NOT-PERSISTING EVENT LISTENER -->\n<script>\n  if (window.ankingEventListeners) {\n    for (const listener of ankingEventListeners) {\n      const type = listener[0]\n      const handler = listener[1]\n      document.removeEventListener(type, handler)\n    }\n  }\n  window.ankingEventListeners = []\n\n  window.ankingAddEventListener = function (type, handler) {\n    document.addEventListener(type, handler)\n    window.ankingEventListeners.push([type, handler])\n  }\n</script>\n\n<!-- Shortcut Matcher Function -->\n<script>\n  var specialCharCodes = {\n    \"-\": \"minus\",\n    \"=\": \"equal\",\n    \"[\": \"bracketleft\",\n    \"]\": \"bracketright\",\n    \";\": \"semicolon\",\n    \"'\": \"quote\",\n    \"`\": \"backquote\",\n    \"\\\\\": \"backslash\",\n    \",\": \"comma\",\n    \".\": \"period\",\n    \"/\": \"slash\",\n  };\n\n  // Returns function that match keyboard event to see if it matches given shortcut.\n  function shortcutMatcher(shortcut) {\n    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())\n    let mainKey = shortcutKeys[shortcutKeys.length - 1]\n    if (mainKey.length === 1) {\n      if (/\\d/.test(mainKey)) {\n        mainKey = \"digit\" + mainKey\n      } else if (/[a-zA-Z]/.test(mainKey)) {\n        mainKey = \"key\" + mainKey\n      } else {\n        let code = specialCharCodes[mainKey];\n        if (code) {\n          mainKey = code\n        }\n      }\n    }\n    let ctrl = shortcutKeys.includes(\"ctrl\")\n    let shift = shortcutKeys.includes(\"shift\")\n    let alt = shortcutKeys.includes(\"alt\")\n\n    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {\n      if (mainKey !== event.code.toLowerCase()) return false\n      if (ctrl !== (event.ctrlKey || event.metaKey)) return false\n      if (shift !== event.shiftKey) return false\n      if (alt !== event.altKey) return false\n      return true\n    }.bind(window, ctrl, shift, alt, mainKey)\n\n    return matchShortcut\n  }\n</script>\n\n<!-- IMAGE BLUR -->\n<script>\n  function makeImagesBlur() {\n    for (const image of document.querySelectorAll(\".blur\")) {\n      image.classList.add(\"tappable\");\n      image.addEventListener(\"click\", () => {\n        setTimeout(function () {\n          image.classList.toggle(\"blur\");\n        }, 200);\n      });\n    }\n  }\n\n  makeImagesBlur();\n</script>\n\n<!-- CLICKABLE COLORFUL TAGS -->\n{{#Tags}}\n<script>\n  var tagContainer = document.getElementById(\"tags-container\")\n\n  function formatTag(tag) {\n    // remove unnecessary whitespace\n    tag = tag.trim()\n\n    // numTagLevelsToShow == 0 means the whole tag should be shown\n    if (numTagLevelsToShow != 0) {\n      tag = tag.split(\"::\").slice(-numTagLevelsToShow).join(\"::\");\n    }\n\n    // Ankizin / Ankiphil specific functionality to disable showing irrelevant university-specific curriculum tags\n    if (((tag.split(\"::\")[1] == \"#UNIVERSITÄTEN\") || (tag.split(\"::\")[1] == \"#Universitäten\")) && (tag.split(\"::\")[2] != tagUniversity)) return null;\n    if (tag.split(\"::\")[1] == \"§NEW_CARDS\") return null;\n    if (tag.split(\"::\")[1] == \"§Projekt_Anki\") return null;\n    if (tag.split(\"::\")[0] == \"AnkiHub_Subdeck\") return null;\n\n    // improve legibility of tags\n    // remove unnecessary prefixes\n    tag = tag.replaceAll(\"#Ankizin_v1::\", \"\").replaceAll(\"#Ankizin_v2::\", \"\").replaceAll(\"#Ankizin_v3::\", \"\").replaceAll(\"#Ankizin_vAnkihub::\", \"\")\n    tag = tag.replaceAll(\"#Ankiphil_Vorklinik_v4.3::\", \"\").replaceAll(\"#Ankiphil_Klinik_v1.4::\", \"\");\n    // clean duplicated prefixes\n    tag = tag.replaceAll(\"#AMBOSS::\", \"\").replaceAll(\"Bibliothek-Vorklinik::\", \"\").replaceAll(\"Bibliothek-Klinik::\", \"\").replaceAll(\"#M2_M3_Klinik::\", \"Klinik::\").replaceAll(\"#M1_Vorklinik_(work_in_progress)::\", \"Vorklinik::\");\n    // clean unncessarily long \"Lernplan\" tags\n    tag = tag.replaceAll(\"M1-50-Tage-Lernplan_Intensiv\", \"M1_50_Tage_Intensiv\").replaceAll(\"M1-30-Tage-Lernplan_Turbo\", \"M1_30_Tage_Turbo\").replaceAll(\"M2-100-Tage-Lernplan\", \"M2_100_Tage\").replaceAll(\"M3-Kenntnisprüfung\", \"M3\");\n    tag = tag.replaceAll(\"M1-30-T_\", \"\").replaceAll(\"M1-50-I_\", \"\").replaceAll(\"M2_Lerntag\", \"Lerntag\")\n    // change HTML symbols\n    tag = tag.replaceAll(\"::\", \" →&nbsp;\").replaceAll(\"-\", \"&#8209;\").replaceAll(\"_\", \" \");\n\n    return tag.trim();\n  }\n\n  if (tagContainer.childElementCount == 0) {\n    var tagList = tagContainer.innerHTML.trim().split(\" \");\n    var kbdList = [];\n    var newTagContent = document.createElement(\"div\");\n\n    for (var i = 0; i < tagList.length; i++) {\n      var newTag = document.createElement(\"kbd\");\n      var tag = tagList[i];\n\n      formattedTag = formatTag(tag);\n      if (formattedTag == null) continue;\n\n      newTag.innerHTML = formattedTag;\n      newTagContent.append(newTag)\n    }\n\n    tagContainer.innerHTML = newTagContent.innerHTML;\n    tagContainer.style.cursor = \"default\";\n  }\n\n  if (tagContainer.innerHTML.indexOf(tagID) != -1) {\n    tagContainer.style.backgroundColor = \"rgba(251,11,11,.15)\";\n  }\n\n  function showtags() {\n    var tagContainerShortcut = document.getElementById(\"tags-container\");\n\n    if (tagContainerShortcut.style.display === \"none\") {\n      tagContainerShortcut.style.display = \"inline\";\n    } else {\n      tagContainerShortcut.style.display = \"none\";\n    }\n  }\n\n  var isShortcut = shortcutMatcher(toggleTagsShortcut)\n\n  ankingAddEventListener('keyup', function (e) {\n    if (isShortcut(e)) {\n      toggleHintBtn('hint-tags');\n      showtags();\n    }\n  });\n\n  var elements = document.getElementsByTagName('kbd');\n  for (index = elements.length - 1; index >= 0; index--) {\n    formattedTag = formatTag(elements[index].innerHTML);\n\n    if (formattedTag == null) {\n      elements[index].remove();\n      continue;\n    }\n\n    elements[index].innerHTML = formattedTag;\n  }\n</script>\n{{/Tags}}\n\n<!-- HINT BUTTONS SETUP -->\n<script>\n  (function () {\n    window.toggleHintBtn = function (containerId, noScrolling = false) {\n      const container = document.getElementById(containerId)\n      // const link = container.getElementsByTagName(\"a\")[0]\n      const button = container.getElementsByTagName(\"button\")[0]\n      const hint = container.getElementsByTagName(\"div\")[0]\n\n      if (hint.style.display == \"none\") {\n        button.classList.add(\"expanded-button\")\n        hint.style.display = \"block\"\n        // link.style.display = \"none\"\n        if (ScrollToButton && !noScrolling) {\n          hint.scrollIntoView({\n            behavior: \"smooth\", // \"auto\" for instant scrolling\n            block: \"start\",\n            inline: \"nearest\"\n          });\n        }\n      } else {\n        button.classList.remove(\"expanded-button\")\n        hint.style.display = \"none\"\n        // link.style.display = \"\"\n      }\n    }\n\n    window.toggleNextButton = function () {\n      // adapted from Hint Hotkey add-on\n      var customEvent = document.createEvent('MouseEvents');\n      customEvent.initEvent('click', false, true);\n      var arr = document.getElementsByTagName('a');\n      for (var i = 0; i < arr.length; i++) {\n        var el = arr[i];\n        if (\n          window.getComputedStyle(el).display === 'none' ||\n          window.getComputedStyle(el.parentElement).display === 'none'\n        ) {\n          continue;\n        }\n        if (el.classList.contains(\"hint\")) {\n          el.dispatchEvent(customEvent);\n          break\n        }\n      }\n    }\n\n    const isToggleNextShortcut = shortcutMatcher(ToggleNextButtonShortcut)\n    ankingAddEventListener(\"keydown\", (evt) => {\n      if (evt.repeat) return\n      if (isToggleNextShortcut(evt)) {\n        toggleNextButton()\n      }\n    })\n\n    const setupHintBtn = function (elem) {\n      const containerId = elem.id\n      const fieldName = elem.dataset.name\n      const button = elem.getElementsByClassName(\"button\")[0]\n      const tag = `autoopen::${fieldName.toLowerCase().replace(' ', '_')}`\n      if (ButtonAutoReveal[fieldName] || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n        toggleHintBtn(containerId, noScrolling = true)\n      }\n\n      const isShortcut = shortcutMatcher(ButtonShortcuts[fieldName])\n      const isToggleAllShortcut = shortcutMatcher(ToggleAllButtonsShortcut)\n      ankingAddEventListener(\"keydown\", (evt) => {\n        if (evt.repeat) return\n        if (isShortcut(evt) || isToggleAllShortcut(evt)) {\n          toggleHintBtn(containerId)\n        }\n      })\n    }\n\n    const hints = document.getElementsByClassName(\"hintBtn\")\n    for (let i = 0; i < hints.length; i++) {\n      setupHintBtn(hints[i])\n    }\n  })()\n</script>\n\n<script>\n  try {\n    for (const link of document.getElementById(\"linkContainerLinks\").querySelectorAll(\"a\")) {\n      href = link.href\n      text = link.innerText\n\n      const el = document.createElement('a');\n      el.setAttribute('href', link.href);\n\n      const btn = document.createElement('button');\n      btn.classList.add('button-general');\n      btn.classList.add('expanded-button');\n\n      domain = href.replace(/.+\\/\\/|(www|flexikon|register|de|next|com).|\\..+/g, '');\n      domainDict = {\n        \"amboss\": \"__amboss.svg\",\n        \"wikipedia\": \"__wikipedia.svg\",\n        \"doccheck\": \"__doccheck.png\",\n        \"notfallguru\": \"__notfallguru.svg\",\n        \"awmf\": \"__awmf.svg\",\n        \"gelbe-liste\": \"__gelbe-liste.png\",\n        \"embryotox\": \"__embryotox.svg\",\n        \"radiopaedia\": \"__radiopaedia.png\",\n        \"orphanet\": \"__orphanet.png\",\n      }\n      if (domain in domainDict) {\n        icon = domainDict[domain]\n      } else {\n        icon = \"__internet.svg\"\n      }\n\n      const img = document.createElement('img');\n      img.setAttribute('src', icon);\n      img.setAttribute('style', 'height: 10px;');\n\n      btn.appendChild(img);\n      btn.innerHTML = btn.innerHTML + \" \" + text;\n\n      el.appendChild(btn);\n\n      document.getElementById(\"linkcontainer\").appendChild(el)\n    }\n  }\n  catch (err) {\n    console.log(err)\n  }\n</script>\n\n<script>\n  var buttonIds = [\"extra\", \"image\", \"hint-zusatz\", \"hint-definition\", \"hint-hammer\", \"hint-klinik\", \"hint-praeparat\", \"hint-microscope\", \"hint-smartzoom\", \"hint-histotrainer\", \"hint-uafi\", \"hint-merksprueche\", \"hint-memes\", \"hint-image\", \"hint-amboss\", \"hint-thieme\", \"hint-meditricks\", \"hint-linkcontainer\"]\n\n  for (const button in buttonIds) {\n    try {\n      document.getElementById(buttonIds[button]).style.removeProperty(\"display\")\n    } catch (exception) {\n      console.log(exception)\n    }\n  }\n</script>\n\n<!-- Credit: Anki Persistence, MIT: https://github.com/SimonLammer/anki-persistence/blob/8190116c95df202773aa692c5e9ae704fb407bc9/script.js -->\n\n<script>\n  if (typeof (window.Persistence) === 'undefined') {\n    var _persistenceKey = 'github.com/SimonLammer/anki-persistence/';\n    var _defaultKey = '_default';\n    window.Persistence_sessionStorage = function () { // used in android, iOS, web\n      var isAvailable = false;\n      try {\n        if (typeof (window.sessionStorage) === 'object') {\n          isAvailable = true;\n          this.clear = function () {\n            for (var i = 0; i < sessionStorage.length; i++) {\n              var k = sessionStorage.key(i);\n              if (k.indexOf(_persistenceKey) == 0) {\n                sessionStorage.removeItem(k);\n                i--;\n              }\n            };\n          };\n          this.setItem = function (key, value) {\n            if (value == undefined) {\n              value = key;\n              key = _defaultKey;\n            }\n            sessionStorage.setItem(_persistenceKey + key, JSON.stringify(value));\n          };\n          this.getItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            return JSON.parse(sessionStorage.getItem(_persistenceKey + key));\n          };\n          this.removeItem = function (key) {\n            if (key == undefined) {\n              key = _defaultKey;\n            }\n            sessionStorage.removeItem(_persistenceKey + key);\n          };\n          this.getAllKeys = function () {\n            var keys = [];\n            var prefixedKeys = Object.keys(sessionStorage);\n            for (var i = 0; i < prefixedKeys.length; i++) {\n              var k = prefixedKeys[i];\n              if (k.indexOf(_persistenceKey) == 0) {\n                keys.push(k.substring(_persistenceKey.length, k.length));\n              }\n            };\n            return keys.sort()\n          }\n        }\n      } catch (err) { }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    window.Persistence_windowKey = function (persistentKey) { // used in windows, linux, mac\n      var obj = window[persistentKey];\n      var isAvailable = false;\n      if (typeof (obj) === 'object') {\n        isAvailable = true;\n        this.clear = function () {\n          obj[_persistenceKey] = {};\n        };\n        this.setItem = function (key, value) {\n          if (value == undefined) {\n            value = key;\n            key = _defaultKey;\n          }\n          obj[_persistenceKey][key] = value;\n        };\n        this.getItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          return obj[_persistenceKey][key] == undefined ? null : obj[_persistenceKey][key];\n        };\n        this.removeItem = function (key) {\n          if (key == undefined) {\n            key = _defaultKey;\n          }\n          delete obj[_persistenceKey][key];\n        };\n        this.getAllKeys = function () {\n          return Object.keys(obj[_persistenceKey]);\n        }\n\n        if (obj[_persistenceKey] == undefined) {\n          this.clear();\n        }\n      }\n      this.isAvailable = function () {\n        return isAvailable;\n      };\n    };\n    /*\n     *   client  | sessionStorage | persistentKey | useful location |\n     * ----------|----------------|---------------|-----------------|\n     * web       |       YES      |       -       |       NO        |\n     * windows   |       NO       |       py      |       NO        |\n     * android   |       YES      |       -       |       NO        |\n     * linux 2.0 |       NO       |       qt      |       YES       |\n     * linux 2.1 |       NO       |       qt      |       YES       |\n     * mac 2.0   |       NO       |       py      |       NO        |\n     * mac 2.1   |       NO       |       qt      |       YES       |\n     * iOS       |       YES      |       -       |       NO        |\n     */\n    window.Persistence = new Persistence_sessionStorage(); // android, iOS, web\n    if (!Persistence.isAvailable()) {\n      window.Persistence = new Persistence_windowKey(\"py\"); // windows, mac (2.0)\n    }\n    if (!Persistence.isAvailable()) {\n      var titleStartIndex = window.location.toString().indexOf('title'); // if titleStartIndex > 0, window.location is useful\n      var titleContentIndex = window.location.toString().indexOf('main', titleStartIndex);\n      if (titleStartIndex > 0 && titleContentIndex > 0 && (titleContentIndex - titleStartIndex) < 10) {\n        window.Persistence = new Persistence_windowKey(\"qt\"); // linux, mac (2.1)\n      }\n    }\n  }\n</script>\n\n<!-- AUTOFLIP BACK SCRIPT -->\n<script>\n  // autoflip hides card in front template\n  document.getElementById(\"qa\").style.removeProperty(\"display\")\n</script>\n\n<!-- CLOZE ONE BY ONE SCRIPT -->\n<style>\n  .cloze-replacer:hover {\n    cursor: pointer;\n  }\n\n  .cloze-hidden {\n    display: none;\n  }\n\n  .cloze-replacer .hidden {\n    display: none;\n  }\n\n  #extra.hidden {\n    display: none;\n  }\n</style>\n\n<!--\n Based on the AnKing Notetype, but expanded and modified by phyn.\n Credit to the original authors, except where modified or otherwise indicated.\n-->\n\n<script>\n    (function () {\n      // enables cloze one-by-one even when one-by-one field is empty\n      // minNumberOfClozes is still considered in this case\n      // overridden in importance by selectiveOneByOne\n      var clozeOneByOneEnabled = true;\n\n      // remove the clickAnywhere function from global scope\n      document.documentElement.removeAttribute(\"onclick\")\n\n      // --- CHECK IF ONE BY ONE IS GENERALLY ENABLED FOR THIS NOTE ---\n      var oneByOneFieldNotEmpty = \"{{One by one}}\" !== \"\";\n      try {\n        clozeOneByOneEnabled = alwaysOneByOne || oneByOneFieldNotEmpty;\n      } catch (exception) {\n        console.log(exception)\n      }\n\n      /**\n   * helper functions to show / hide fields containing additional information\n   */\n      const showExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.removeProperty(\"display\");\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const hideExtra = function () {\n        try {\n          document.getElementById(\"extra\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n        try {\n          document.getElementById(\"image\").style.display = \"none\";\n        } catch (exception) {\n          console.log(exception);\n        }\n      };\n\n      const buttonIds = [\n        \"hint-zusatz\",\n        \"hint-definition\",\n        \"hint-hammer\",\n        \"hint-klinik\",\n        \"hint-praeparat\",\n        \"hint-microscope\",\n        \"hint-smartzoom\",\n        \"hint-histotrainer\",\n        \"hint-uafi\",\n        \"hint-merksprueche\",\n        \"hint-memes\",\n        \"hint-image\",\n        \"hint-amboss\",\n        \"hint-thieme\",\n        \"hint-meditricks\",\n        \"hint-linkcontainer\",\n      ];\n\n      const showExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document\n              .getElementById(buttonIds[button])\n              .style.removeProperty(\"display\");\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n      const hideExtraButtons = function () {\n        for (const button in buttonIds) {\n          try {\n            document.getElementById(buttonIds[button]).style.display = \"none\";\n          } catch (exception) {\n            console.log(exception);\n          }\n        }\n      };\n\n\n      // --- CHECK IF ONE BY ONE SHOULD BE ENABLED FOR THIS SPECIFIC CARD ---\n      /**\n       * Credit for the getCardNumber function goes to foenixx (GitHub) / ollevolle (AnkiWeb Forum)\n       */\n      const getCardNumber = function () {\n        clz = document.body.className;\n        const regex = /card(\\d+)/gm;\n\n        let clz2;\n        try {\n          clz2 = document.getElementById(\"cloze\").getAttribute(\"data-card\");\n        } catch (e) {\n          clz2 = \"\";\n        }\n        const regex2 = /.*?Cloze(\\d+)/gm;\n\n        let m;\n\n        if ((m = regex2.exec(clz2)) !== null) {\n          return m[1];\n        } else if ((m = regex.exec(clz)) !== null) {\n          return m[1];\n        } else {\n          // Should only fire if card is not cloze\n          console.error(\"Cannot find cardN class of body element!\");\n          return \"0\";\n        }\n      }\n\n      var clozeType = \"cloze\"\n      // parse the cloze numbers for which selectiveOneByOne is enabled\n      var clozeNumbers = \"{{One by one}}\".split(',').filter(element => element).map(Number)\n      var cardNumberIsOneByOne = !clozeNumbers.filter(n => !Number.isNaN(n)).length || clozeNumbers.includes(parseInt(getCardNumber()))\n\n      var numClozesForNumber = 0;\n\n      // Only count if minNumberOfClozes is set (truthy)\n      if (minNumberOfClozes) {\n        const clozeFieldExists = document.querySelector('.clozefield') !== null; // Check if any element with the class 'clozefield' exists\n\n        if (clozeFieldExists && clozeType == \"cloze\") { // If 'clozefield' exists, count '.cloze' elements within it\n          numClozesForNumber = document.querySelectorAll('.clozefield .cloze').length;\n        } else if (clozeType == \"cloze\") {\n          numClozesForNumber = document.querySelectorAll('.cloze').length;\n        } else if (clozeType == \"imageOcclusion\") {\n          numClozesForNumber = document.querySelectorAll(\".cloze[data-ordinal='\" + getCardNumber() + \"']\").length;\n        } else if (clozeType == \"imageOcclusionBack\") {\n          numClozesForNumber = document.querySelectorAll('.cloze-highlight').length;\n        }\n      }\n      // If minNumberOfClozes is not set (falsy), numClozesForNumber remains 0\n\n      // | alwaysOneByOne | selectiveOneByOne | !oneByOneFieldEmpty | minNumberOfClozes reached | cardNumberIsOneByOne | OneByOne |\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | TRUE           | TRUE              | TRUE                | FALSE                     | FALSE                | TRUE     |\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | TRUE           | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | TRUE                 | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | TRUE                      | FALSE                | TRUE     |\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // A && !S && !M\n      // | TRUE           | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // A && !S && !M\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | TRUE                      | FALSE                | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | TRUE                 | TRUE     |\n      // | FALSE          | TRUE              | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && S && F && !M && !C\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | TRUE                      | FALSE                | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | TRUE                 | FALSE    | // S && !F\n      // | FALSE          | TRUE              | FALSE               | FALSE                     | FALSE                | FALSE    | // S && !F\n      // |----------------|-------------------|---------------------|---------------------------|----------------------|----------|\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | TRUE                | FALSE                     | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | TRUE                      | FALSE                | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | TRUE                 | FALSE    | // !A && !S\n      // | FALSE          | FALSE             | FALSE               | FALSE                     | FALSE                | FALSE    | // !A && !S\n\n      // Determine if OneByOne should be disabled based on the logic table.\n      // The condition below evaluates to TRUE when OneByOne should be DISABLED (clozeOneByOneEnabled = false),\n      // corresponding to the rows where 'OneByOne' is FALSE in the table.\n      // Variables mapping: A=alwaysOneByOne, S=selectiveOneByOne, F=!oneByOneFieldEmpty, M=(numClozesForNumber >= minNumberOfClozes), C=cardNumberIsOneByOne\n      // Code variables: oneByOneFieldEmpty (!F), (numClozesForNumber < minNumberOfClozes) (!M)\n\n      if (\n        // Case 1: !A && !S (Covers all rows where A=F, S=F)\n        (!alwaysOneByOne && !selectiveOneByOne) ||\n\n        // Case 2: A && !S && !M (Covers rows where A=T, S=F, M=F)\n        (alwaysOneByOne && !selectiveOneByOne && (numClozesForNumber < minNumberOfClozes)) ||\n\n        // Case 3: S && !F (Covers rows where S=T, F=F; In code: selectiveOneByOne && oneByOneFieldEmpty)\n        (selectiveOneByOne && oneByOneFieldEmpty) ||\n\n        // Case 4: !A && S && F && !M && !C (Covers row A=F, S=T, F=T, M=F, C=F; In code: !A && S && !oneByOneFieldEmpty && !M && !C)\n        (!alwaysOneByOne && selectiveOneByOne && !oneByOneFieldEmpty && (numClozesForNumber < minNumberOfClozes) && !cardNumberIsOneByOne)\n      ) {\n        clozeOneByOneEnabled = false;\n      }\n\n      if (!clozeOneByOneEnabled) {\n        showExtra()\n        showExtraButtons()\n        document.getElementById(\"onebyone-buttons\").style.display = \"none\"\n        document.getElementById(\"qa\").style.removeProperty(\"display\")\n        return\n      }\n\n      // Needed for amboss to recognize first word in .cloze-hidden\n      const CLOZE_REPLACER_SEP = \"<span class='hidden'> </span>\"\n\n      const hideAllCloze = function (initial) {\n        let clozes = document.getElementsByClassName(\"cloze\")\n        let count = 0 // hidden cloze count\n        for (const cloze of clozes) {\n          const existingHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n          if (existingHidden) {\n            revealCloze(cloze);\n          }\n          if (cloze.offsetWidth === 0) {\n            continue\n          }\n          const clozeReplacer = document.createElement(\"span\")\n          const clozeHidden = document.createElement(\"span\")\n          clozeReplacer.classList.add(\"cloze-replacer\")\n          clozeHidden.classList.add(\"cloze-hidden\")\n          while (cloze.childNodes.length > 0) {\n            clozeHidden.appendChild(cloze.childNodes[0])\n          }\n          cloze.appendChild(clozeReplacer)\n          cloze.appendChild(clozeHidden)\n\n          var clozeHints = Persistence.getItem(\"clozeHints\");\n          if (clozeHints && clozeHints[count]) {\n            clozeReplacer.classList.add(\"cloze-hint\")\n            clozeReplacer.innerHTML = clozeHints[count] + CLOZE_REPLACER_SEP\n          } else {\n            clozeReplacer.innerHTML = clozeHider(cloze) + CLOZE_REPLACER_SEP\n          }\n          count += 1\n          document.getElementById(\"button-reveal-next\").style.display = \"inline-block\";\n          if (initial) {\n            cloze.addEventListener(\"touchend\", revealClozeClicked)\n            cloze.addEventListener(\"click\", revealClozeClicked)\n            cloze.classList.add(\"one-by-one\");\n          }\n        }\n\n        // Hide #extra until all clozes are shown\n        const extra = document.getElementById(\"extra\");\n        if (extra) {\n          extra.classList.add(\"hidden\");\n        }\n\n        hideExtra();\n        hideExtraButtons();\n        if (revealAnywhere) {\n          document.documentElement.setAttribute(\"onclick\", \"revealNextCloze(); event.stopPropagation()\")\n        }\n\n\n        // Also hide autoReveal fields\n        for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n          const container = document.querySelector(`[data-name=\"${field}\"]`)\n          if (container) {\n            const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n            if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n              // const link = container.getElementsByTagName(\"a\")[0]\n              const button = container.getElementsByTagName(\"button\")[0]\n              const hint = container.getElementsByTagName(\"div\")[0]\n              button.classList.remove(\"expanded-button\")\n              hint.style.display = \"none\"\n              // link.style.display = \"\"\n            }\n          }\n        }\n      }\n\n      const revealCloze = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        cloze.removeChild(clozeReplacer)\n        cloze.removeChild(clozeHidden)\n        while (clozeHidden.childNodes.length > 0) {\n          cloze.appendChild(clozeHidden.childNodes[0])\n        }\n        maybeRevealExtraField()\n      }\n\n      const revealClozeWord = function (cloze) {\n        const clozeReplacer = cloze.getElementsByClassName(\"cloze-replacer\")[0]\n        const clozeHidden = cloze.getElementsByClassName(\"cloze-hidden\")[0]\n        if (!clozeReplacer || !clozeHidden) return;\n\n        let range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundSpace = setRangeEnd(range, clozeHidden, \"beforeFirstSpace\")\n        if (!foundSpace) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        let fragment = range.extractContents()\n        cloze.insertBefore(fragment, clozeReplacer)\n        // Extract whitespaces after word\n        range = new Range()\n        range.setStart(clozeHidden, 0)\n        const foundWord = setRangeEnd(range, clozeHidden, \"beforeFirstChar\")\n        if (!foundWord) {\n          range.setEnd(clozeHidden, clozeHidden.childNodes.length)\n        }\n        fragment = range.extractContents();\n        cloze.insertBefore(fragment, clozeReplacer)\n        if (!foundWord) {\n          cloze.removeChild(clozeHidden)\n          cloze.removeChild(clozeReplacer)\n          maybeRevealExtraField()\n          return\n        }\n        clozeReplacer.innerHTML = clozeHider(clozeHidden) + CLOZE_REPLACER_SEP\n        if (clozeReplacer.classList.contains(\"cloze-hint\")) [\n          clozeReplacer.classList.remove(\"cloze-hint\")\n        ]\n        maybeRevealExtraField()\n      }\n\n      const revealNextClozeOf = (type) => {\n        const nextHidden = document.querySelectorAll(\".cloze-hidden\")\n        const nextNextHidden = nextHidden.length > 1 ? true : false\n        if (!nextNextHidden) {\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\";\n        }\n        if (!nextHidden) {\n          return\n        }\n        const cloze = clozeElOfClozeHidden(nextHidden[0]);\n        if (type === \"word\") {\n          revealClozeWord(cloze)\n        } else if (type === \"cloze\") {\n          revealCloze(cloze)\n        } else {\n          console.error(\"Invalid type: \" + type)\n        }\n      }\n\n      const revealClozeClicked = function (ev) {\n        let elem = ev.currentTarget\n        if (!ev.altKey && (revealNextClozeMode !== \"word\")) {\n          revealCloze(elem)\n        } else {\n          revealClozeWord(elem)\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      }\n\n      window.revealNextCloze = function () {\n        revealNextClozeOf(revealNextClozeMode)\n      }\n\n      window.toggleAllCloze = function () {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length > 0) {\n          for (const elem of elems) {\n            const cloze = clozeElOfClozeHidden(elem)\n            revealCloze(cloze)\n          }\n          document.documentElement.removeAttribute(\"onclick\")\n          document.getElementById(\"button-reveal-next\").style.display = \"none\"\n        } else {\n          hideAllCloze(initial = false)\n        }\n      }\n\n      const clozeElOfClozeHidden = (cloze) => {\n        while (!cloze.classList.contains(\"cloze\")) {\n          cloze = cloze.parentElement;\n        }\n        return cloze;\n      }\n\n      const maybeRevealExtraField = () => {\n        let elems = document.querySelectorAll(\".cloze-hidden\")\n        if (elems.length == 0) {\n          const extra = document.getElementById(\"extra\")\n          if (extra) {\n            extra.classList.remove(\"hidden\")\n          }\n\n          showExtra();\n          showExtraButtons();\n          document.documentElement.removeAttribute(\"onclick\")\n\n          // Also reveal autoReveal fields\n          for (const [field, autoReveal] of Object.entries(ButtonAutoReveal)) {\n            const container = document.querySelector(`[data-name=\"${field}\"]`)\n            if (container) {\n              const tag = `autoopen::${field.toLowerCase().replace(' ', '_')}`\n              if (autoReveal || (globalThis.tagList && globalThis.tagList.includes(tag))) {\n                // const link = container.getElementsByTagName(\"a\")[0]\n                const button = container.getElementsByTagName(\"button\")[0]\n                const hint = container.getElementsByTagName(\"div\")[0]\n                button.classList.add(\"expanded-button\")\n                hint.style.display = \"block\"\n                // link.style.display = \"none\"\n              }\n            }\n          }\n        }\n      }\n\n      /**\n       * mode: 'beforeFirstSpace' or 'beforeFirstChar'\n       * Return `true` if it exists and setEnd() was called, otherwise `false`\n       */\n      const setRangeEnd = function (range, node, mode) {\n        if (node.nodeType === Node.TEXT_NODE) {\n          const regex = mode === 'beforeFirstSpace' ? /\\s/ : /\\S/\n          const match = node.textContent.match(regex)\n          if (match) {\n            if (match.index === 0) {\n              while (node.previousSibling === null) {\n                node = node.parentElement\n              }\n              range.setEndBefore(node)\n            } else {\n              range.setEnd(node, match.index);\n            }\n            return true;\n          } else {\n            return false;\n          }\n        } else if (mode === 'beforeFirstChar' && isCharNode(node)) {\n          range.setEndBefore(node)\n          return true\n        } else if (!ignoreSpaceInNode(node)) {\n          for (const child of node.childNodes) {\n            if (setRangeEnd(range, child, mode)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }\n\n      const ignoreSpaceInNode = function (node) {\n        return node.tagName === \"MJX-ASSISTIVE-MML\"\n      }\n\n      const isCharNode = function (node) {\n        return [\"IMG\", \"MJX-CONTAINER\"].includes(node.tagName)\n      }\n\n      hideAllCloze(initial = true)\n\n      let isShowNextShortcut = shortcutMatcher(window.revealNextShortcut)\n      let isShowWordShortcut = shortcutMatcher(window.revealNextWordShortcut)\n      let isToggleAllShortcut = shortcutMatcher(window.toggleAllShortcut)\n      ankingAddEventListener(\"keydown\", (ev) => {\n        let next = isShowNextShortcut(ev)\n        let word = isShowWordShortcut(ev)\n        let all = isToggleAllShortcut(ev)\n        if (next) {\n          revealNextClozeOf(\"cloze\")\n        } else if (word) {\n          revealNextClozeOf(\"word\")\n        } else if (all) {\n          toggleAllCloze()\n        } else {\n          return;\n        }\n        ev.stopPropagation()\n        ev.preventDefault()\n      });\n    })()\n</script>\n\n<!-- COUNTDOWN TIMER -->\n<script>\n  function countdown(elementName, minutes, seconds) {\n    var element, endTime, mins, msLeft, time;\n    function twoDigits(n) {\n      return (n <= 9 ? \"0\" + n : n);\n    }\n    function updateTimer() {\n      msLeft = endTime - (+new Date);\n\n      if (msLeft < 1000) {\n        element.innerHTML = timeOverMsg;\n      } else {\n        time = new Date(msLeft);\n        mins = time.getUTCMinutes();\n        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());\n        setTimeout(updateTimer, time.getUTCMilliseconds() + 500);\n      }\n    }\n    element = document.getElementById(elementName);\n    endTime = (+new Date) + 1000 * (60 * minutes + seconds) + 500;\n    updateTimer();\n  }\n  countdown(\"timer\", minutes, seconds); //2nd value is the minute, 3rd is the seconds\n</script>\n\n<script>\n  /*\n    MODIFIED VERSION OF:\n    * @name        replaceUsingDictionary\n    * @author      Rob W http://stackoverflow.com/users/938089/rob-w\n    * @description Replaces phrases in a string, based on keys in a given dictionary.\n    *              Each key is used only once, and the replacements are case-insensitive\n    * @param       Object dictionary  {key: phrase, ...}\n    * @param       String content\n    * @param       Function replacehandler\n    * @returns     Modified string\n  */\n  function replaceUsingDictionary(dictionary, content, replacehandler) {\n    if (typeof replacehandler != \"function\") {\n      // Default replacehandler function.\n      replacehandler = function (key, dictionary) {\n        return dictionary[key];\n      }\n    }\n\n    var patterns = [], // \\b is used to mark boundaries \"foo\" doesn't match food\n      patternHash = {},\n      oldkey, key, index = 0,\n      output = [];\n    for (key in dictionary) {\n      // Case-insensitivity:\n      key = (oldkey = key).toLowerCase();\n      dictionary[key] = dictionary[oldkey];\n\n      // Sanitize the key, and push it in the list\n      // patterns.push('\\\\b(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')\\\\b');\n      patterns.push('(?:' + key.replace(/([[^$.|?*+(){}])/g, '\\\\$1') + ')');\n\n      // Add entry to hash variable, for an optimized backtracking at the next loop\n      patternHash[key] = index++;\n    }\n    var pattern = new RegExp(patterns.join('|'), 'gi'),\n      lastIndex = 0;\n\n    // We should actually test using !== null, but for foolproofness,\n    //  we also reject empty strings\n    while (key = pattern.exec(content)) {\n      // Case-insensitivity\n      key = key[0].toLowerCase();\n\n      // Add to output buffer\n      output.push(content.substring(lastIndex, pattern.lastIndex - key.length));\n      // The next line is the actual replacement method\n      output.push(replacehandler(key, dictionary));\n\n      // Update lastIndex variable\n      lastIndex = pattern.lastIndex;\n\n      // Don't match again by removing the matched word, create new pattern\n      // patterns[patternHash[key]] = '^';\n      // pattern = new RegExp(patterns.join('|'), 'gi');\n\n      // IMPORTANT: Update lastIndex property. Otherwise, enjoy an infinite loop\n      pattern.lastIndex = lastIndex;\n    }\n    output.push(content.substring(lastIndex, content.length));\n    return output.join('');\n  }\n</script>\n\n<!-- DIVI FORMATTING -->\n<script>\n  var diviDict = {\n    \"Esketamin\": \"esKETAmin\",\n    \"Ketamin\": \"KETAmin\",\n    \"Clonazepam\": \"clonazePAM\",\n    \"Lorazepam\": \"LORazepam\",\n    \"Pancuronium\": \"PANcuronium\",\n    \"Rocuronium\": \"ROCuronium\",\n    \"Vecuronium\": \"VECuronium\",\n    \"Fentanyl\": \"fentaNYL\",\n    \"Hydromorphon\": \"HYDROmorphon\",\n    \"Oxycodon\": \"oxyCODON\",\n    \"Piritramid\": \"PIRItramid\",\n    \"Sufentanil\": \"SUFentanil\",\n    \"Tramadol\": \"traMADol\",\n    \"Dopamin\": \"DOPamin\",\n    \"Ephedrin\": \"ePHEDrin\",\n    \"Epinephrin\": \"EPINEPHrin\",\n    \"Clonidin\": \"cloNIDin\",\n    \"Dihydralazin\": \"dihydrALAZIN\",\n    \"Nifedipin\": \"NIFEdipin\",\n    \"Nimodipin\": \"niMODipin\",\n    \"Bupivacain\": \"BUPIvacain\",\n    \"Ropivacain\": \"ROPIvacain\",\n    \"Physostigmin\": \"pHYSostigmin\",\n    \"Pyridostigmin\": \"pYRIDostigmin\",\n    \"Dimenhydrinat\": \"dimenhyDRINAT\",\n    \"Dolasetron\": \"DOLAsetron\",\n    \"Granisetron\": \"GRANIsetron\",\n    \"Ondansetron\": \"ONDANsetron\",\n    \"Tropisetron\": \"TROPIsetron\",\n    \"Adenosin\": \"aDENOsin\",\n    \"Ajmalin\": \"aJMALin\",\n    \"Amiodaron\": \"aMIOdaron\",\n    \"Levetiracetam\": \"levETIRAcetam\",\n    \"Desmopressin\": \"desmoPRESSIN\",\n    \"Dexamethason\": \"DEXAmethason\",\n    \"Levothyroxin\": \"LEVOthyroxin\",\n    \"Liothyronin\": \"LIOthyronin\",\n    \"Methylprednisolon\": \"methylPREDNISolon\",\n    \"Prednisolon\": \"prednisoLON\",\n    \"Octreotid\": \"ocTREOtid\",\n    \"Oxytocin\": \"OXYTOcin\",\n    \"Dobutamin\": \"DOBUTamin\",\n    \"Dopexamin\": \"dOPEXamin\",\n    \"Cimetidin\": \"cIMEtidin\",\n    \"Clemastin\": \"cLEMAstin\",\n    \"Furosemid\": \"fUROsemid\",\n    \"Glyceroltrinitrat\": \"<strong>G</strong><small>lycerol</small><strong>T</strong><small>ri</small><strong>N</strong><small>itrat</small>\",\n    \"Metoclopramid\": \"<strong>M</strong><small>eto</small><strong>C</strong><small>lo</small><strong>P</strong><small>ramid</small>\",\n    \"Acetylsalicylsäure\": \"<strong>A</strong><small>cetyl</small><strong>S</strong><small>alicyl</small><strong>S</strong><small>äure</small>\",\n    \"4-Dimethylaminophenol\": \"4&#8209;<strong>D</strong><small>i</small><strong>M</strong><small>ethyl</small><strong>A</strong><small>mino</small><strong>P</strong><small>henol</small>\",\n    \"Tranexamsäure\": \"Tranexam<small>säure</small>\",\n    \"Valproinsäure\": \"Valproin<small>säure</small>\",\n    \"Calciumchlorid\": \"Calcium<small>chlorid</small>\",\n    \"Calciumgluconat\": \"Calcium<small>gluconat</small>\",\n    \"Glyceroldihydrogen-Phosphat\": \"<small>Glyceroldihydrogen</small>-Phosphat\",\n    \"Magnesiumasparat\": \"Magnesium<small>asparat</small>\",\n    \"Magnesiumsulfat\": \"Magnesium<small>sulfat</small>\",\n    \"Na-Hydrogencarbonat\": \"<small>Na</small>&#8209;Hydrogencarbonat\",\n    \"Na-Thiosulfat\": \"<small>Na</small>&#8209;Thiosulfat\",\n    \"Na-Phosphat\": \"<small>Na</small>&#8209;Phosphat\",\n    \"Ca-Folinat\": \"<small>Ca</small>&#8209;FOLINAT\",\n    \"Nitroprussid-Na\": \"Nitroprussid&#8209;<small>Na</small>\"\n  }\n\n  if (formattingDIVI) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      diviDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<!-- CONFOUNDER FORMATTING -->\n<script>\n  var confounderDict = {\n    \"atypisch\": '<emu>a</emu>typisch',\n    \"Atypisch\": '<emu>A</emu>typisch',\n    \"Antagonist\": '<emu>Ant</emu>agonist',\n    \"hyper\": 'hyp<emu>er</emu>',\n    \"Hyper\": 'Hyp<emu>er</emu>',\n    \"hypo\": 'hyp<emu>o</emu>',\n    \"Hypo\": 'Hyp<emu>o</emu>',\n    \"inter\": 'int<emu>er</emu>',\n    \"Inter\": 'Int<emu>er</emu>',\n    \"intra\": 'int<emu>ra</emu>',\n    \"Intra\": 'int<emu>ra</emu>',\n    \"post\": '<emu>post</emu>',\n    \"Post\": '<emu>Post</emu>',\n    \"pre\": '<emu>pre</emu>',\n    \"Pre\": '<emu>Pre</emu>',\n    \"ab\": '<emu>ab</emu>',\n    \"Ab\": '<emu>Ab</emu>',\n    \"ad\": '<emu>ad</emu>',\n    \"Ad\": '<emu>Ad</emu>',\n    \"Insuffizienz\": '<emu>In</emu>suffizienz',\n  }\n\n  if (formattingConfounders) {\n    document.getElementById(\"container\").innerHTML = replaceUsingDictionary(\n      confounderDict,\n      document.getElementById(\"container\").innerHTML,\n      function (key, dictionary) {\n        return dictionary[key];\n      }\n    );\n  }\n</script>\n\n\n<script>\n  /**\n   * Based on the AnKing Bionic Reading AddOn, but slightly expanded and modified by phyn.\n   * Full credit to the original authors, except where modified or otherwise indicated.\n   */\n\n  /**\n   *\n   * We try to respect that people use various note types\n   * which may do 'weird' stuff.\n   * Elements may have event listeners that can be removed if we just innerHTML stuff\n   * <i> may be styled 'i { display: block }', etc.\n   *\n   * Another problem that complicate the design of this script is that\n   * a word may not be cleanly separated by html tags.\n   * e.g. \"A<i>long</i>word\"\n   *\n   */\n\n  (function () {\n    /**\n     * @param {String} text\n     * @returns {number}\n     */\n    function getBoldLength(text) {\n      return Math.floor(text.length / 2);\n    }\n\n    // Ignore node if any of the filters return true\n    const excludeFilters = [\n      (elem) => elem.tagName === \"SCRIPT\",\n      (elem) => elem.tagName === \"STYLE\",\n      (elem) => elem.classList.contains(\"cloze\"),\n    ];\n\n    function newBoldElement(text) {\n      const elem = document.createElement(\"strong\");\n      elem.innerText = text;\n      return elem;\n    }\n\n    function indexOfWhitespace(text, startPos) {\n      const whitespaces = [\n        \" \",\n        \"\\n\",\n        \"\\t\",\n        \" \",\n        \"&nbsp;\",\n        \"‑\",\n        \"-\",\n        \"/\",\n        \"(\",\n        \")\",\n      ];\n      let nextPos = text.length;\n      for (const whitespace of whitespaces) {\n        const next = text.indexOf(whitespace, startPos);\n        if (next !== -1 && next < nextPos) {\n          nextPos = next;\n        }\n      }\n      if (nextPos === text.length) {\n        nextPos = -1;\n      }\n      return nextPos;\n    }\n\n    // Bolds a line of words\n    class BionicReaderBolder {\n      constructor(nodes) {\n        this.nodes = nodes;\n        this.startNodeIndex = 0;\n        this.startPos = 0;\n        this.replaceNodes = [];\n        while (!this.isFinished()) {\n          this.runWithinNode();\n          this.runInterNode();\n        }\n      }\n\n      static run(nodes) {\n        new BionicReaderBolder(nodes);\n      }\n\n      isFinished() {\n        return this.startNodeIndex === this.nodes.length;\n      }\n\n      replaceNode() {\n        const node = this.nodes[this.startNodeIndex];\n        const parent = node.parentNode;\n        for (let add of this.replaceNodes) {\n          parent.insertBefore(add, node);\n        }\n        parent.removeChild(node);\n        this.replaceNodes = [];\n      }\n\n      runWithinNode() {\n        const textContent = this.nodes[this.startNodeIndex].textContent;\n        let nextPos = indexOfWhitespace(textContent, this.startPos);\n        while (nextPos !== -1) {\n          const word = textContent.substring(this.startPos, nextPos);\n          const boldLength = getBoldLength(word);\n          this.replaceNodes.push(newBoldElement(word.substring(0, boldLength)));\n          this.replaceNodes.push(\n            document.createTextNode(\n              word.substring(boldLength, nextPos) + textContent[nextPos]\n            )\n          );\n          this.startPos = nextPos + 1;\n          nextPos = indexOfWhitespace(textContent, this.startPos);\n        }\n      }\n\n      // after this, startPos is likely to be at whitespace char\n      runInterNode() {\n        let word = \"\";\n        let endNodeIndex = this.startNodeIndex;\n        let endPos = this.startPos; // last word char pos + 1\n\n        // Find word boundary\n        while (endNodeIndex < this.nodes.length) {\n          const textContent = this.nodes[endNodeIndex].textContent;\n          let nextPos = indexOfWhitespace(textContent, endPos);\n          if (nextPos === -1) {\n            word += textContent.substring(endPos);\n            endNodeIndex += 1;\n            endPos = 0;\n          } else {\n            word += textContent.substring(endPos, nextPos);\n            endPos = nextPos;\n            break;\n          }\n        }\n        // Calculate bold length\n        let remainingBoldLength = getBoldLength(word);\n\n        // Bold part of word\n        while (remainingBoldLength > 0) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          if (remainingBoldLength > textContent.length - this.startPos) {\n            const wordPart = textContent.substring(this.startPos);\n            remainingBoldLength -= wordPart.length;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            this.replaceNode();\n            this.startNodeIndex += 1;\n            this.startPos = 0;\n          } else {\n            const wordPart = textContent.substring(\n              this.startPos,\n              this.startPos + remainingBoldLength\n            );\n            this.startPos += remainingBoldLength;\n            this.replaceNodes.push(newBoldElement(wordPart));\n            remainingBoldLength -= wordPart.length;\n          }\n        }\n\n        // Add non-bolded part of words\n        while (this.startNodeIndex < endNodeIndex) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.replaceNode();\n          this.startNodeIndex += 1;\n          this.startPos = 0;\n        }\n\n        if (this.startPos < endPos) {\n          const textContent = this.nodes[this.startNodeIndex].textContent;\n          const wordPart = textContent.substring(this.startPos, endPos);\n          if (wordPart.length > 0) {\n            this.replaceNodes.push(document.createTextNode(wordPart));\n          }\n          this.startPos = endPos;\n        }\n      }\n    }\n\n    /**\n     * Builds a list of (list of nodes that makes up one non-line-broken line)\n     * @param {Node} elem\n     * @param {Node[][]} - list of list of text nodes. Must not be empty, last element must be a list.\n     * @returns {void}\n     */\n    function forTextNodesInTree(elem, nodes, exclude = false) {\n      const children = elem.childNodes;\n      for (const filter of excludeFilters) {\n        if (filter(elem)) {\n          exclude = true;\n          break;\n        }\n      }\n      for (const child of children) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          const style = window.getComputedStyle(child);\n          if (\n            child.tagName !== \"BR\" &&\n            (style === \"inline\" || style === \"inline-block\")\n          ) {\n            forTextNodesInTree(child, nodes, exclude);\n          } else {\n            if (nodes[nodes.length - 1].length > 0) {\n              nodes.push([]);\n            }\n            forTextNodesInTree(child, nodes, exclude);\n          }\n        } else if (\n          !exclude &&\n          child.nodeType === Node.TEXT_NODE &&\n          child.textContent.length > 0\n        ) {\n          nodes[nodes.length - 1].push(child);\n        }\n      }\n    }\n\n    function makeBionic() {\n      const cardContainer = document.getElementById(\"container\");\n      cardContainer.normalize();\n\n      let nodesLines = [[]];\n      forTextNodesInTree(cardContainer, nodesLines);\n      for (const nodes of nodesLines) {\n        BionicReaderBolder.run(nodes);\n      }\n\n      cardContainer.innerHTML = cardContainer.innerHTML.replaceAll(\n        \"<strong></strong>\",\n        \"\"\n      );\n      cardContainer.normalize();\n    }\n\n    let start = performance.now();\n    if (bionicReading) {\n      makeBionic();\n    }\n    let end = performance.now();\n    console.log(`Initialized bionic reading: ${end - start}ms`);\n  })();\n</script>\n\n\n<!-- table div wrapper -->\n<script>\n  for (let table of document.querySelectorAll(\"table\")) {\n    let tableDiv = document.createElement(\"div\");\n    tableDiv.style.overflowY = \"scroll\";\n    table.parentNode.insertBefore(tableDiv, table);\n    tableDiv.appendChild(table);\n  };\n</script>\n\n<!-- MEDITRICKS SNIPPETS DATA -->\n<div id=\"meditricks-mtsp-values\" style=\"display:none;\">\n  <div id=\"meditricks-mtsp-nfname\">_meditricks_nf_v1000_ankizin</div>\n  <div id=\"meditricks-mtsp-nid\">{{Note ID}}</div>\n</div>\n<script src=\"_meditricks_mtsp_scripts_v1000_ankizin.js\"></script>\n<link href=\"_meditricks_mtsp_styles_v1000_ankizin.css\" rel=\"stylesheet\" />\n\n<!-- include \"_meditricks_mtsp_nf_v1000_ankizin.js\" -->\n<!-- include \"_meditricks_mtsp_scripts_v1000_iframe.map\" -->\n<!-- include \"_meditricks_mtsp_mtlogo.webp\" -->\n<!-- include \"_meditricks_mtsp_mt-loading.png\" -->\n<!-- include \"_meditricks_mtsp_mt-loading_night.png\" -->\n\n<!-- //MEDITRICKS SNIPPETS DATA -->\n\n<!-- ANKIMOBILE USER ACTIONS -->\n<script>\n  var userJs1 = undefined\n  var userJs2 = undefined\n  var userJs3 = undefined\n  var userJs4 = undefined\n  var userJs5 = undefined\n  var userJs6 = undefined\n  var userJs7 = undefined\n  var userJs8 = undefined\n</script>",
      "bqfmt": "{{Muskel / Leitungsbahn}}",
      "bafmt": "{{Äste}}",
      "bfont": "Helvetica",
      "bsize": 12
    }
  ],
  "flds": [
    {
      "name": "Muskel / Leitungsbahn",
      "ord": 0,
      "sticky": false,
      "rtl": false,
      "size": 16,
      "font": "Helvetica",
      "media": []
    },
    {
      "name": "Ursprung",
      "ord": 1,
      "sticky": false,
      "rtl": false,
      "size": 16,
      "font": "Helvetica",
      "media": []
    },
    {
      "name": "Ansatz",
      "ord": 2,
      "sticky": false,
      "rtl": false,
      "size": 16,
      "font": "Helvetica",
      "media": []
    },
    {
      "name": "Verlauf",
      "ord": 3,
      "sticky": false,
      "rtl": false,
      "size": 16,
      "font": "Helvetica",
      "media": []
    },
    {
      "name": "Funktion",
      "ord": 4,
      "sticky": false,
      "rtl": false,
      "size": 16,
      "font": "Helvetica",
      "media": []
    },
    {
      "name": "Innervation",
      "ord": 5,
      "sticky": false,
      "rtl": false,
      "size": 16,
      "font": "Helvetica",
      "media": []
    },
    {
      "name": "Äste",
      "ord": 6,
      "sticky": false,
      "rtl": false,
      "size": 16,
      "font": "Helvetica",
      "media": []
    },
    {
      "name": "Bild",
      "ord": 7,
      "sticky": false,
      "rtl": false,
      "size": 16,
      "font": "Helvetica",
      "media": []
    },
    {
      "name": "Extra",
      "ord": 8,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": []
    },
    {
      "name": "Eigene Notizen & Bilder",
      "ord": 9,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": []
    },
    {
      "name": "Eigene Prüfungsfragen",
      "ord": 10,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": []
    },
    {
      "name": "Definitionen",
      "ord": 11,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": []
    },
    {
      "name": "Merksprüche",
      "ord": 12,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": []
    },
    {
      "name": "Klinik",
      "ord": 13,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": []
    },
    {
      "name": "Präparat",
      "ord": 14,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": []
    },
    {
      "name": "Virtuelle Mikroskopie",
      "ord": 15,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": []
    },
    {
      "name": "Smart Zoom",
      "ord": 16,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": []
    },
    {
      "name": "Memes",
      "ord": 17,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": []
    },
    {
      "name": "Meditricks",
      "ord": 18,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": []
    },
    {
      "name": "AMBOSS-Link",
      "ord": 19,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": []
    },
    {
      "name": "Thieme via medici-Link",
      "ord": 20,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": []
    },
    {
      "name": "weitere Links",
      "ord": 21,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": []
    },
    {
      "name": "Quelle",
      "ord": 22,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": []
    },
    {
      "name": "Datum",
      "ord": 23,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": []
    },
    {
      "name": "Note ID",
      "ord": 24,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 16,
      "media": [],
      "meta": "noteid"
    },
    {
      "name": "One by one",
      "ord": 25,
      "sticky": false,
      "rtl": false,
      "font": "Helvetica",
      "size": 8,
      "media": []
    },
    {
      "name": "UrsprungCloze1",
      "ord": 26,
      "font": "Helvetica",
      "size": 8,
      "sticky": false,
      "rtl": false,
      "media": []
    },
    {
      "name": "UrsprungCloze2",
      "ord": 27,
      "font": "Helvetica",
      "size": 8,
      "sticky": false,
      "rtl": false,
      "media": []
    },
    {
      "name": "UrsprungCloze3",
      "ord": 28,
      "font": "Helvetica",
      "size": 8,
      "sticky": false,
      "rtl": false,
      "media": []
    },
    {
      "name": "AnsatzCloze1",
      "ord": 29,
      "font": "Helvetica",
      "size": 8,
      "sticky": false,
      "rtl": false,
      "media": []
    },
    {
      "name": "AnsatzCloze2",
      "ord": 30,
      "font": "Helvetica",
      "size": 8,
      "sticky": false,
      "rtl": false,
      "media": []
    },
    {
      "name": "AnsatzCloze3",
      "ord": 31,
      "font": "Helvetica",
      "size": 8,
      "sticky": false,
      "rtl": false,
      "media": []
    },
    {
      "name": "VerlaufCloze1",
      "ord": 32,
      "font": "Helvetica",
      "size": 8,
      "sticky": false,
      "rtl": false,
      "media": []
    },
    {
      "name": "VerlaufCloze2",
      "ord": 33,
      "font": "Helvetica",
      "size": 8,
      "sticky": false,
      "rtl": false,
      "media": []
    },
    {
      "name": "VerlaufCloze3",
      "ord": 34,
      "font": "Helvetica",
      "size": 8,
      "sticky": false,
      "rtl": false,
      "media": []
    },
    {
      "name": "FunktionCloze1",
      "ord": 35,
      "font": "Helvetica",
      "size": 8,
      "sticky": false,
      "rtl": false,
      "media": []
    },
    {
      "name": "FunktionCloze2",
      "ord": 36,
      "font": "Helvetica",
      "size": 8,
      "sticky": false,
      "rtl": false,
      "media": []
    },
    {
      "name": "FunktionCloze3",
      "ord": 37,
      "font": "Helvetica",
      "size": 8,
      "sticky": false,
      "rtl": false,
      "media": []
    },
    {
      "name": "InnervationCloze1",
      "ord": 38,
      "font": "Helvetica",
      "size": 8,
      "sticky": false,
      "rtl": false,
      "media": []
    },
    {
      "name": "InnervationCloze2",
      "ord": 39,
      "font": "Helvetica",
      "size": 8,
      "sticky": false,
      "rtl": false,
      "media": []
    },
    {
      "name": "InnervationCloze3",
      "ord": 40,
      "font": "Helvetica",
      "size": 8,
      "sticky": false,
      "rtl": false,
      "media": []
    },
    {
      "name": "ÄsteCloze1",
      "ord": 41,
      "font": "Helvetica",
      "size": 8,
      "sticky": false,
      "rtl": false,
      "media": []
    },
    {
      "name": "ÄsteCloze2",
      "ord": 42,
      "font": "Helvetica",
      "size": 8,
      "sticky": false,
      "rtl": false,
      "media": []
    },
    {
      "name": "ÄsteCloze3",
      "ord": 43,
      "font": "Helvetica",
      "size": 8,
      "sticky": false,
      "rtl": false,
      "media": []
    }
  ],
  "css": "",
  "latexPre": "\\documentclass[12pt]{article}\n\\special{papersize=3in,5in}\n\\usepackage{amssymb,amsmath}\n\\pagestyle{empty}\n\\setlength{\\parindent}{0in}\n\\begin{document}\n",
  "latexPost": "\\end{document}",
  "latexsvg": true,
  "req": [
    [
      0,
      "any",
      [
        0
      ]
    ]
  ],
  "tags": [],
  "vers": []
}